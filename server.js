// ======================
// 1. CORE IMPORTS
// ======================

// Core Node.js Modules
const path = require("path");
const os = require("os");
const url = require("url");
const fs = require("fs");
const fsPromises = require("fs").promises;
const { exec } = require("child_process");
const { promisify } = require("util");
const { pipeline } = require("stream/promises");
const { createServer } = require("http");
const FormData = require("form-data");
const { Readable } = require("stream");
const mime = require("mime-types");

// Third-party Libraries
// Framework & Middleware
const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const { setupNeonWebhooks } = require("./neon-webhook-integration");

// API Clients & Communication
const axios = require("axios");
const fetch = require("node-fetch");
const WebSocket = require("ws");
const { google } = require("googleapis");
const OpenAI = require("openai");
const {
  Client,
  LocalAuth,
  RemoteAuth,
  MessageMedia,
} = require("whatsapp-web.js");

// Database & Storage
const Redis = require("ioredis");
const { neon, neonConfig } = require("@neondatabase/serverless");
const { Pool } = require("pg");
const multer = require("multer");

// Queue & Scheduling
const { Queue, Worker, QueueScheduler } = require("bullmq");
const cron = require("node-cron");
const schedule = require("node-schedule");

// Utilities
require("dotenv").config();
const moment = require("moment-timezone");
const qrcode = require("qrcode");
const qrcodeTerminal = require("qrcode-terminal");
const CryptoJS = require("crypto-js");
const { v4: uuidv4 } = require("uuid");
const csv = require("csv-parser");
const ffmpeg = require("ffmpeg-static");
const { PDFDocument, rgb, StandardFonts } = require("pdf-lib");

// Custom Modules
const FirebaseWWebJS = require("./firebaseWweb.js");
const admin = require("./firebase.js");
const AutomatedMessaging = require("./blast/automatedMessaging");
const sqlDb = require("./db");
const {
  handleNewMessagesPersonalAssistant,
} = require("./bots/handleMessagesPersonalAssistant.js");
const { handleTagFollowUp } = require("./blast/tag.js");
const dialog360 = require("./services/whatsapp/dialog360");

// Import logging system
const ServerLogger = require("./logger");
const LogManager = require("./logManager");
const feedbackFormsRouter = require("./routes/feedbackForms.js");
const eventsRouter = require("./routes/events");
const enrolleesRouter = require("./routes/enrollees");
const participantsRouter = require("./routes/participants");
const attendanceEventsRouter = require("./routes/attendanceEvents");
const attendanceRecordsRouter = require("./routes/attendanceRecords");
const feedbackResponsesRouter = require("./routes/feedbackResponse");
const mtdcSpreadsheet = require("./spreadsheet/mtdcSpreadsheet.js");
const certificatesRouter = require("./routes/certificates");
const contactSyncRouter = require("./routes/contactSync");
const serverManagerRouter = require("./routes/serverManager");

// WhatsApp Embedded Signup & Cloud API routes
const whatsappApiRoutes = require("./src/routes/whatsapp");
const metaWebhookRoutes = require("./src/routes/webhooks/meta");

// Initialize logger
const logger = new ServerLogger();
const logManager = new LogManager();

// Add rate limiting configuration at the top of the file
const RATE_LIMIT_DELAY = 5000; // 5 seconds between requests
const MAX_REQUESTS_PER_MINUTE = 60;
const requestCounts = new Map();

// Rate limiting function
function checkRateLimit(identifier) {
  const now = Date.now();
  const minuteAgo = now - 60000;

  if (!requestCounts.has(identifier)) {
    requestCounts.set(identifier, []);
  }

  const requests = requestCounts.get(identifier);
  const recentRequests = requests.filter((time) => time > minuteAgo);

  if (recentRequests.length >= MAX_REQUESTS_PER_MINUTE) {
    return false;
  }

  recentRequests.push(now);
  requestCounts.set(identifier, recentRequests);
  return true;
}
function getPlanBasedQuota(plan) {
  switch (plan?.toLowerCase()) {
    case "free":
      return 100;
    case "premium":
      return 5000;
    case "enterprise":
      return 20000;
    default:
      return 100; // Default to free plan quota
  }
}

// Helper function to check if plan uses monthly reset
function isMonthlyResetPlan(plan) {
  const planLower = plan?.toLowerCase();
  return planLower === "premium" || planLower === "enterprise";
}

// Helper function to get quota key (monthly for paid plans, lifetime for free)
function getQuotaKey(plan) {
  if (isMonthlyResetPlan(plan)) {
    const now = new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, "0");
    return `${year}-${month}`;
  } else {
    return "lifetime"; // Free plan uses lifetime quota
  }
}
// ======================
// 2. CONFIGURATION
// ======================

// Event listeners configuration
require("events").EventEmitter.defaultMaxListeners = 70;
require("events").EventEmitter.prototype._maxListeners = 70;
require("events").defaultMaxListeners = 70;

// Configure Neon for WebSocket pooling
neonConfig.webSocketConstructor = WebSocket;

// File System Utilities
const readFileAsync = promisify(fs.readFile);
const writeFileAsync = promisify(fs.writeFile);
const LAST_PROCESSED_ROW_FILE = "last_processed_row.json";
const MEDIA_DIR = path.join(__dirname, "public", "media");
// Ensure media directory exists
if (!fs.existsSync(MEDIA_DIR)) {
  fs.mkdirSync(MEDIA_DIR, { recursive: true });
}
let companyConfig = {};

// ======================
// 3. SERVICE CONNECTIONS
// ======================

// Database connections
// Database connections
const sql = neon(process.env.DATABASE_URL); // // ======================
// ENHANCED DATABASE CONNECTION MANAGEMENT
// ======================

// Improved database pool configuration with better limits
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 200, // Reduced from 10 to prevent overwhelming
  min: 1, // Reduced from 2
  idleTimeoutMillis: 30000, // 30 seconds
  connectionTimeoutMillis: 5000, // 5 seconds - reduced from 10000
  acquireTimeoutMillis: 10000, // 10 seconds - reduced from 30000
  createTimeoutMillis: 5000, // 5 seconds - reduced from 10000
  destroyTimeoutMillis: 5000,
  reapIntervalMillis: 1000,
  createRetryIntervalMillis: 100,
  allowExitOnIdle: false,
  connectionRetryInterval: 500,
  maxConnectionRetries: 5, // Reduced from 10
  // Add statement timeout to prevent long-running queries
  statement_timeout: 15000, // 15 seconds - reduced from 30000
  // Add query timeout
  query_timeout: 15000, // 15 seconds - reduced from 30000
  // Add idle in transaction timeout
  idle_in_transaction_session_timeout: 15000, // 15 seconds - reduced from 30000
});

// Enhanced connection management functions
async function safeRollback(sqlClient) {
  if (sqlClient && typeof sqlClient.query === "function") {
    try {
      await sqlClient.query("ROLLBACK");
      console.log("Transaction rolled back successfully");
    } catch (rollbackError) {
      console.error("Error during rollback:", rollbackError);
    }
  }
}

async function safeRelease(sqlClient) {
  if (sqlClient && typeof sqlClient.release === "function") {
    try {
      await sqlClient.release();
      console.log("Database connection released successfully");
    } catch (releaseError) {
      console.error("Error releasing connection:", releaseError);
    }
  }
}

// Enhanced connection acquisition with timeout and retry
async function getDatabaseConnection(timeoutMs = 5000) {
  const startTime = Date.now();
  let attempts = 0;
  const maxAttempts = 3;

  while (attempts < maxAttempts) {
    try {
      console.log(
        `Attempting to get database connection (attempt ${
          attempts + 1
        }/${maxAttempts})`
      );

      const client = await Promise.race([
        pool.connect(),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Connection timeout")), timeoutMs)
        ),
      ]);

      console.log(
        `Database connection acquired successfully in ${
          Date.now() - startTime
        }ms`
      );
      return client;
    } catch (error) {
      attempts++;
      console.error(
        `Database connection attempt ${attempts} failed:`,
        error.message
      );

      // Handle network-related errors more gracefully
      if (
        error.code === "EADDRNOTAVAIL" ||
        error.code === "ENOTFOUND" ||
        error.code === "ECONNREFUSED" ||
        error.code === "ETIMEDOUT" ||
        error.message.includes("read EADDRNOTAVAIL") ||
        error.message.includes("TLSWrap")
      ) {
        console.error(
          "Network connectivity error detected in database connection"
        );

        if (attempts >= maxAttempts) {
          console.error(
            "Max attempts reached for database connection - continuing without connection"
          );
          return null; // Return null instead of throwing
        }

        // Wait longer for network issues
        await new Promise((resolve) => setTimeout(resolve, 2000 * attempts));
        continue;
      }

      if (attempts >= maxAttempts) {
        console.error(
          "Max attempts reached for database connection - continuing without connection"
        );
        return null; // Return null instead of throwing
      }

      // Wait before retrying
      await new Promise((resolve) => setTimeout(resolve, 1000 * attempts));
    }
  }
}

// ======================
// PHONE NUMBER EXTRACTION UTILITIES WITH @LID FAILSAFE
// ======================

// Utility function to safely extract phone number with @lid failsafe
async function safeExtractPhoneNumber(msg, client = null) {
  try {
    let phoneNumber;

    // Check if it's a @lid case
    if (msg.from && msg.from.includes("@lid")) {
      console.log(
        "🔧 [safeExtractPhoneNumber] @lid detected, using chat/contact method"
      );

      if (!client) {
        console.error(
          "❌ [safeExtractPhoneNumber] Client required for @lid extraction but not provided"
        );
        return null;
      }

      try {
        const chat = await msg.getChat();
        const contact = await chat.getContact();

        if (contact && contact.id && contact.id._serialized) {
          // Extract phone number from contact.id._serialized
          phoneNumber = contact.id._serialized.split("@")[0];
          console.log(
            "✅ [safeExtractPhoneNumber] Extracted from contact:",
            phoneNumber
          );
        } else {
          console.error(
            "❌ [safeExtractPhoneNumber] Could not get contact info from chat"
          );
          return null;
        }
      } catch (error) {
        console.error(
          "❌ [safeExtractPhoneNumber] Error getting chat/contact for @lid:",
          error
        );
        return null;
      }
    } else {
      // Standard extraction method
      phoneNumber = msg.from.split("@")[0];
      console.log(
        "✅ [safeExtractPhoneNumber] Standard extraction:",
        phoneNumber
      );
    }

    // Add + prefix if not present
    if (phoneNumber && !phoneNumber.startsWith("+")) {
      phoneNumber = "+" + phoneNumber;
    }

    return phoneNumber;
  } catch (error) {
    console.error("❌ [safeExtractPhoneNumber] Unexpected error:", error);
    return null;
  }
}

// Utility function to safely extract "to" phone number with @lid failsafe
async function safeExtractToPhoneNumber(msg, client = null) {
  try {
    let phoneNumber;

    // Check if it's a @lid case
    if (msg.to && msg.to.includes("@lid")) {
      console.log(
        '🔧 [safeExtractToPhoneNumber] @lid detected in "to", using chat/contact method'
      );

      if (!client) {
        console.error(
          "❌ [safeExtractToPhoneNumber] Client required for @lid extraction but not provided"
        );
        return null;
      }

      try {
        const chat = await msg.getChat();
        const contact = await chat.getContact();

        if (contact && contact.id && contact.id._serialized) {
          // Extract phone number from contact.id._serialized
          phoneNumber = contact.id._serialized.split("@")[0];
          console.log(
            "✅ [safeExtractToPhoneNumber] Extracted from contact:",
            phoneNumber
          );
        } else {
          console.error(
            "❌ [safeExtractToPhoneNumber] Could not get contact info from chat"
          );
          return null;
        }
      } catch (error) {
        console.error(
          "❌ [safeExtractToPhoneNumber] Error getting chat/contact for @lid:",
          error
        );
        return null;
      }
    } else {
      // Standard extraction method
      phoneNumber = msg.to.split("@")[0];
      console.log(
        "✅ [safeExtractToPhoneNumber] Standard extraction:",
        phoneNumber
      );
    }

    // Add + prefix if not present
    if (phoneNumber && !phoneNumber.startsWith("+")) {
      phoneNumber = "+" + phoneNumber;
    }

    return phoneNumber;
  } catch (error) {
    console.error("❌ [safeExtractToPhoneNumber] Unexpected error:", error);
    return null;
  }
}

// Enhanced worker creation with better // ======================
// COMPLETE FIXED WORKER CODE WITH SAFE JSON PARSING
// ======================

const createQueueAndWorker = (botId) => {
  const queue = new Queue(`scheduled-messages-${botId}`, {
    connection: {
      host: process.env.REDIS_HOST,
      port: process.env.REDIS_PORT,
      password: process.env.REDIS_PASSWORD,
    },
    defaultJobOptions: {
      removeOnComplete: false,
      removeOnFail: false,
      attempts: 3,
      backoff: {
        type: "exponential",
        delay: 5000, // Increased from 2000
      },
    },
  });

  // Enhanced worker with better concurrency control and safe JSON parsing
  // ======================
  // FIXED WORKER CODE - HANDLE BOTH JSON STRINGS AND PARSED ARRAYS
  // ======================

  // Enhanced worker with better concurrency control and safe JSON parsing
  const worker = new Worker(
    `scheduled-messages-${botId}`,
    async (job) => {
      if (job.name === "send-message-batch") {
        const { companyId, messageId, batchId, isDuplicate } = job.data;
        console.log(`Bot ${botId} - Processing scheduled message batch:`, {
          messageId,
          batchId,
        });

        if (isDuplicate) {
          console.log(
            `Bot ${botId} - Skipping duplicate job ${job.id} for batch ${batchId}`
          );
          return { skipped: true, reason: "Duplicate message" };
        }

        let client = null;
        try {
          // Get database connection with timeout
          client = await getDatabaseConnection(5000);

          await client.query("BEGIN");

          const batchQuery = `
          SELECT * FROM scheduled_messages 
          WHERE id = $1 AND company_id = $2
          FOR UPDATE
        `;
          const batchResult = await client.query(batchQuery, [
            batchId,
            companyId,
          ]);

          if (batchResult.rowCount === 0) {
            // Gracefully handle missing batch row: rollback and skip this job
            console.warn(
              `Bot ${botId} - Batch ${batchId} not found in database, rolling back and skipping job`
            );
            try {
              await safeRollback(client);
            } catch (rbErr) {
              console.error(
                `Bot ${botId} - Error during rollback for missing batch ${batchId}:`,
                rbErr
              );
            }

            return {
              skipped: true,
              reason: `Batch ${batchId} not found in database`,
            };
          }

          const batchData = batchResult.rows[0];

          if (batchData.status === "skipped") {
            console.log(
              `Bot ${botId} - Batch ${batchId} was already marked as skipped`
            );
            return {
              skipped: true,
              reason: batchData.skipped_reason || "Already skipped",
            };
          }

          if (batchData.status === "sent" || batchData.status === "completed") {
            console.log(
              `Bot ${botId} - Batch ${batchId} was already ${batchData.status}`
            );
            return {
              skipped: true,
              reason: `Already ${batchData.status}`,
            };
          }

          // FIXED: Handle both JSON strings and parsed arrays for chat_ids
          let chatIdsCount = 0;
          let chatIds = [];

          try {
            if (batchData.chat_ids) {
              // Check if it's already an array (parsed by database driver)
              if (Array.isArray(batchData.chat_ids)) {
                chatIds = batchData.chat_ids;
                chatIdsCount = chatIds.length;
                console.log(
                  `Bot ${botId} - chat_ids is already an array with ${chatIdsCount} items`
                );
              } else if (typeof batchData.chat_ids === "string") {
                // It's a JSON string, parse it
                chatIds = JSON.parse(batchData.chat_ids);
                chatIdsCount = Array.isArray(chatIds) ? chatIds.length : 0;
                console.log(
                  `Bot ${botId} - chat_ids parsed from JSON string with ${chatIdsCount} items`
                );
              } else {
                console.warn(
                  `Bot ${botId} - chat_ids is neither array nor string:`,
                  typeof batchData.chat_ids
                );
                chatIdsCount = 0;
              }
            }
          } catch (parseError) {
            console.error(
              `Bot ${botId} - Error parsing chat_ids for batch ${batchId}:`,
              {
                error: parseError.message,
                chat_ids: batchData.chat_ids,
                chat_ids_type: typeof batchData.chat_ids,
                batchId: batchId,
              }
            );

            // Mark this batch as failed due to malformed data
            await client.query(
              "UPDATE scheduled_messages SET status = $1, skipped_reason = $2 WHERE id = $3",
              [
                "failed",
                `Malformed chat_ids data: ${parseError.message}`,
                batchId,
              ]
            );

            await client.query("COMMIT");
            return {
              skipped: true,
              reason: `Malformed data: ${parseError.message}`,
            };
          }

          // Check if we have valid chat IDs to process
          if (chatIdsCount === 0) {
            console.log(
              `Bot ${botId} - Batch ${batchId} has no valid chat IDs, marking as completed`
            );
            await client.query(
              "UPDATE scheduled_messages SET status = $1, skipped_reason = $2 WHERE id = $3",
              ["completed", "No valid chat IDs to process"]
            );
            await client.query("COMMIT");
            return {
              skipped: true,
              reason: "No valid chat IDs to process",
            };
          }

          console.log(`Bot ${botId} - Sending scheduled message batch:`, {
            batchId,
            messageId,
            status: batchData.status,
            chatIds: chatIdsCount,
            chatIdsSample: chatIds.slice(0, 3), // Show first 3 chat IDs for debugging
          });

          const result = await sendScheduledMessage(batchData);

          if (result && result.success) {
            console.log(
              `Bot ${botId} - Successfully sent batch ${batchId} for message ${messageId}`
            );

            await client.query(
              "UPDATE scheduled_messages SET status = $1, sent_at = NOW() WHERE id = $2",
              ["sent", batchId]
            );

            // Check if all batches are now processed
            const batchesCheckQuery = `
            SELECT COUNT(*) as pending_count,
            (SELECT status FROM scheduled_messages WHERE id = $1::uuid) as main_status
            FROM scheduled_messages 
            -- schedule_id column is stored as text/character varying in some schemas
            -- ensure we compare like-types: cast the parameter to text when comparing
            WHERE schedule_id = $1::text
            AND company_id = $2 
            AND status != 'sent'
            AND id != $1::uuid
          `;
            const batchesCheck = await client.query(batchesCheckQuery, [
              messageId,
              companyId,
            ]);

            console.log(`Bot ${botId} - Batch status check:`, {
              pendingCount: batchesCheck.rows[0].pending_count,
              mainStatus: batchesCheck.rows[0].main_status,
            });

            if (batchesCheck.rows[0].pending_count === 0) {
              if (batchesCheck.rows[0].main_status !== "sent") {
                await client.query(
                  "UPDATE scheduled_messages SET status = $1, sent_at = NOW() WHERE id = $2",
                  ["sent", messageId]
                );
                console.log(
                  `Bot ${botId} - All batches completed for message ${messageId}`
                );
              }
            }
          } else {
            const errorMsg =
              result && result.error ? result.error : "Unknown error";
            throw new Error(`Failed to send batch: ${errorMsg}`);
          }

          await client.query("COMMIT");
        } catch (error) {
          if (client) {
            await safeRollback(client);
          }
          console.error(
            `Bot ${botId} - Error processing scheduled message batch:`,
            {
              error: error.message,
              stack: error.stack,
              batchId: batchId,
              messageId: messageId,
            }
          );
          throw error;
        } finally {
          if (client) {
            await safeRelease(client);
          }
        }
      } else if (job.name === "send-single-message") {
        const { companyId, messageId } = job.data;
        console.log(`Bot ${botId} - Processing scheduled single message:`, {
          messageId,
        });

        let client = null;
        try {
          // Get database connection with timeout
          client = await getDatabaseConnection(5000);

          await client.query("BEGIN");

          const messageQuery = `
            SELECT * FROM scheduled_messages 
            WHERE id = $1 AND company_id = $2
            FOR UPDATE
          `;
          const messageResult = await client.query(messageQuery, [
            messageId,
            companyId,
          ]);

          if (messageResult.rowCount === 0) {
            throw new Error(`Message ${messageId} not found in database`);
          }

          const messageData = messageResult.rows[0];

          if (
            messageData.status === "skipped" ||
            messageData.status === "sent" ||
            messageData.status === "completed"
          ) {
            console.log(
              `Bot ${botId} - Message ${messageId} was already ${messageData.status}`
            );
            return {
              skipped: true,
              reason: `Already ${messageData.status}`,
            };
          }

          console.log(`Bot ${botId} - Sending scheduled single message:`, {
            messageId,
            status: messageData.status,
          });

          const result = await sendScheduledMessage(messageData);

          if (result && result.success) {
            await client.query(
              "UPDATE scheduled_messages SET status = $1, sent_at = NOW() WHERE id = $2",
              ["sent", messageId]
            );
          } else {
            const errorMsg =
              result && result.error ? result.error : "Unknown error";
            throw new Error(`Failed to send message: ${errorMsg}`);
          }

          await client.query("COMMIT");
        } catch (error) {
          if (client) {
            await safeRollback(client);
          }
          console.error(
            `Bot ${botId} - Error processing scheduled single message:`,
            {
              error: error.message,
              stack: error.stack,
              messageId: messageId,
            }
          );
          throw error;
        } finally {
          if (client) {
            await safeRelease(client);
          }
        }
      }
    },
    {
      connection: {
        host: process.env.REDIS_HOST,
        port: process.env.REDIS_PORT,
        password: process.env.REDIS_PASSWORD,
      },
      concurrency: 1, // Reduced to 1 to prevent overwhelming database
      limiter: {
        max: 3, // Reduced from 5
        duration: 1000,
      },
      lockDuration: 30000,
      maxStalledCount: 1,
      settings: {
        stalledInterval: 15000,
        lockRenewTime: 10000,
      },
    }
  );

  // Enhanced completed event handler
  worker.on("completed", async (job) => {
    console.log(`Bot ${botId} - Job ${job.id} completed successfully`);

    try {
      await job.updateProgress(100);
      await job.updateData({
        ...job.data,
        completedAt: new Date().toISOString(),
        status: "completed",
        success: true,
      });
    } catch (error) {
      console.error(`Bot ${botId} - Error updating completed job data:`, error);
    }
  });

  // Enhanced failed event handler
  worker.on("failed", async (job, err) => {
    console.error(`Bot ${botId} - Job ${job.id} failed:`, {
      error: err.message,
      stack: err.stack,
      attempts: job.attemptsMade,
      maxAttempts: job.opts?.attempts || 3,
    });

    try {
      await job.updateData({
        ...job.data,
        failedAt: new Date().toISOString(),
        error: {
          message: err?.message || "Unknown error",
          stack: err?.stack || "No stack trace",
          name: err?.name || "Error",
        },
        status: "failed",
        finalAttempt: job.attemptsMade >= (job.opts?.attempts || 3),
      });
    } catch (updateError) {
      console.error(
        `Bot ${botId} - Error updating failed job data:`,
        updateError
      );
    }
  });

  // Enhanced error event handler
  worker.on("error", async (err) => {
    console.error(`Bot ${botId} - Worker error:`, {
      message: err.message,
      stack: err.stack,
      name: err.name,
      timestamp: new Date().toISOString(),
    });
  });

  // Enhanced stalled event handler
  worker.on("stalled", async (jobId) => {
    console.warn(`Bot ${botId} - Job ${jobId} stalled`);
  });

  // Store references
  botQueues.set(botId, queue);
  botWorkers.set(botId, worker);
  return { queue, worker };
};

// Add pool error handling to prevent crashes
pool.on("error", (err) => {
  console.error("=== DATABASE POOL ERROR ===");
  console.error("Error:", err);
  console.error("Time:", new Date().toISOString());

  // Handle specific connection errors
  if (
    err.message &&
    err.message.includes("Connection terminated unexpectedly")
  ) {
    console.error(
      "Database connection terminated - attempting to reconnect..."
    );
    // Log to file for debugging
    if (typeof logger !== "undefined" && logger.logToFile) {
      logger.logToFile(
        "db_connection_errors",
        `Connection terminated: ${err.message}`
      );
    }
  }

  // Don't exit the process, just log the error
  console.log("Continuing operation despite database pool error...");
});

pool.on("connect", (client) => {
  console.log("New database connection established");

  // Set connection-specific error handlers
  client.on("error", (err) => {
    console.error("=== DATABASE CLIENT ERROR ===");
    console.error("Error:", err);
    console.error("Time:", new Date().toISOString());

    if (
      err.message &&
      err.message.includes("Connection terminated unexpectedly")
    ) {
      console.error("Client connection terminated - will be replaced by pool");
      // Log to file for debugging
      if (typeof logger !== "undefined" && logger.logToFile) {
        logger.logToFile(
          "db_connection_errors",
          `Client connection terminated: ${err.message}`
        );
      }
    }
  });
});

// Redis connection
const connection = new Redis(process.env.REDIS_URL || "redis://redis:6379", {
  maxRetriesPerRequest: null,
  maxmemoryPolicy: "noeviction",
});

// OpenAI Configuration
const openai = new OpenAI({
  apiKey: process.env.OPENAIKEY,
});

// Google Sheets API Configuration
const auth = new google.auth.GoogleAuth({
  keyFile: "service_account.json",
  scopes: ["https://www.googleapis.com/auth/spreadsheets.readonly"],
});
const sheets = google.sheets({ version: "v4", auth });

// ======================
// 4. APPLICATION STATE
// ======================

const botMap = new Map();
const chatSubscriptions = new Map();
const dailyReportCrons = new Map();
const messageQueue = new Queue("scheduled-messages", { connection });

// ======================
// 5. EXPRESS SETUP
// ======================

const app = express();
const server = createServer(app);

// Make botMap available to routes via app.locals
app.locals.botMap = botMap;

// CORS Configuration - Define whitelist before WebSocket server
const whitelist = [
  "https://juta.ngrok.app",
  "https://juta-crm-v3.vercel.app",
  "http://localhost:5173",
  "http://localhost:3000",
  "http://localhost:8443",
  "https://app.xyzaibot.com",
  "http://localhost:8080",
  "https://d178-2001-e68-5409-64f-f850-607e-e056-2a9e.ngrok-free.app",
  "https://web.jutateknologi.com",
  "http://web.jutateknologi.com",
  "https://app.jutateknologi.com",
  "https://server.jutateknologi.com",
  "https://bisnesgpt.vercel.app",
  "https://app.omniyal.com",
  "https://bisnesgpt.jutateknologi.com",
  "http://bisnesgpt.jutateknologi.com",
];

// Also allow serveo.net domains dynamically
const isServeoOrigin = (origin) => {
  return origin;
};

// WebSocket server configuration
const wss = new WebSocket.Server({
  server,
  verifyClient: (info, done) => {
    const origin = info.origin || info.req.headers.origin;

    // Allow connections with no origin (like mobile apps or non-browser clients)
    if (!origin) return done(true);

    // Define allowed origin patterns
    const allowedOriginPatterns = [
      /^https?:\/\/localhost(:\d+)?(?:$|\/)/i, // Localhost with any port
      /^https?:\/\/127\.0\.0\.1(:\d+)?(?:$|\/)/i, // 127.0.0.1 with any port
      /^https?:\/\/([a-zA-Z0-9-]+\.)*ngrok\.(io|dev|app)(?:$|\/)/i, // ngrok domains
      /^https?:\/\/([a-zA-Z0-9-]+\.)*jutateknologi\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*bisnesgpt\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*omniyal\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*xyzaibot\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*vercel\.app(?:$|\/)/i,
    ];

    // Check if origin matches any allowed pattern
    const isAllowed = allowedOriginPatterns.some((pattern) =>
      pattern.test(origin)
    );

    if (isAllowed) {
      console.log("WebSocket connection allowed from origin:", origin);
      return done(true);
    }

    console.log("WebSocket connection blocked from origin:", origin);
    return done(false, 403, "Origin not allowed");
  },
});
const db = admin.firestore();
global.wss = wss;
// CORS Configuration
// Apply CORS with options
app.use((req, res, next) => {
  // Handle preflight requests
  if (req.method === "OPTIONS") {
    const origin = req.headers.origin;
    if (origin) {
      res.header("Access-Control-Allow-Origin", origin);
      res.header(
        "Access-Control-Allow-Methods",
        corsOptions.methods.join(", ")
      );
      res.header(
        "Access-Control-Allow-Headers",
        corsOptions.allowedHeaders.join(", ")
      );
      res.header("Access-Control-Allow-Credentials", "true");
      return res.status(204).end();
    }
  }

  // Apply CORS for actual requests
  cors(corsOptions)(req, res, next);
});

// Error handler for CORS
app.use((err, req, res, next) => {
  if (err.message === "Not allowed by CORS") {
    return res.status(403).json({
      success: false,
      error: "Not allowed by CORS",
      message: "The origin is not allowed by CORS policy",
    });
  }
  next(err);
});

const corsOptions = {
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);

    // Define allowed origin patterns
    const allowedOrigins = [
      /^https?:\/\/localhost(:\d+)?(?:$|\/)/i, // Localhost with any port
      /^https?:\/\/127\.0\.0\.1(:\d+)?(?:$|\/)/i, // 127.0.0.1 with any port
      /^https?:\/\/([a-zA-Z0-9-]+\.)*ngrok\.(io|dev|app)(?:$|\/)/i, // ngrok domains
      /^https?:\/\/([a-zA-Z0-9-]+\.)*jutateknologi\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*bisnesgpt\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*omniyal\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*xyzaibot\.com(?:$|\/)/i,
      /^https?:\/\/([a-zA-Z0-9-]+\.)*vercel\.app(?:$|\/)/i,
    ];

    // Check if the origin matches any allowed pattern
    const isAllowed = allowedOrigins.some((regex) => regex.test(origin));

    if (isAllowed) {
      return callback(null, origin); // Return the origin for dynamic CORS
    } else {
      console.log("CORS blocked origin:", origin);
      return callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true, // Required for cookies, authorization headers with HTTPS
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: [
    "Content-Type",
    "Authorization",
    "ngrok-skip-browser-warning",
    "x-requested-with",
    "x-csrf-token",
    "Accept",
    "Origin",
    "X-Requested-With",
  ],
  preflightContinue: false,
  optionsSuccessStatus: 204,
  maxAge: 3600, // 1 hour
};

// Custom CORS middleware to handle credentials properly
app.use((req, res, next) => {
  const origin = req.headers.origin;

  // Log CORS requests for debugging

  // Check if the origin is allowed
  if (origin) {
    corsOptions.origin(origin, (err, isAllowed) => {
      if (!err && isAllowed) {
        res.header("Access-Control-Allow-Origin", origin);
        res.header("Access-Control-Allow-Credentials", "true");

        // Handle preflight requests
        if (req.method === "OPTIONS") {
          res.header(
            "Access-Control-Allow-Methods",
            corsOptions.methods.join(", ")
          );
          res.header(
            "Access-Control-Allow-Headers",
            corsOptions.allowedHeaders.join(", ")
          );
          res.header("Access-Control-Max-Age", "3600");
          return res.status(204).end();
        }
      }
      next();
    });
  } else {
    next();
  }
});

app.use(express.json({ limit: "50mb" }));
app.use(bodyParser.json({ limit: "50mb" }));
app.use(bodyParser.urlencoded({ extended: true, limit: "50mb" }));
app.use("/media", express.static(MEDIA_DIR));
app.use(express.static("public"));

// Serve topup success page
app.get("/topup-success", (req, res) => {
  const origin = req.headers.origin;
  if (origin) {
    res.setHeader("Access-Control-Allow-Origin", origin);
  } else {
    res.setHeader("Access-Control-Allow-Origin", "*");
  }
  res.setHeader(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, DELETE, OPTIONS"
  );
  res.setHeader(
    "Access-Control-Allow-Headers",
    "Content-Type, Authorization, Origin, X-Requested-With"
  );
  res.setHeader("Access-Control-Allow-Credentials", "true");

  // Get payment details from query parameters or try to get from recent transactions
  const { payment_intent, reference_number, company_id } = req.query;

  // If we have payment_intent, try to get the transaction details
  let transactionDetails = null;
  if (payment_intent) {
    // Try to get transaction details from database
    sqlDb
      .query(
        `SELECT * FROM topup_transactions WHERE payment_intent_id = $1 ORDER BY completed_at DESC LIMIT 1`,
        [payment_intent]
      )
      .then((result) => {
        if (result.rows.length > 0) {
          transactionDetails = result.rows[0];
        }
      })
      .catch((err) => {
        console.log("Error fetching transaction details:", err);
      });
  }

  // Build redirect URL with payment information

  const webUrl = `https://web.jutateknologi.com/chat?payment_intent=${
    payment_intent || ""
  }&reference_number=${reference_number || ""}&company_id=${
    company_id || ""
  }&status=success`;

  res.send(`    <!DOCTYPE html>
    <html>
    <head>
      <title>Top-up Success</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f5f5f5; }
        .success { background: white; padding: 40px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 500px; margin: 0 auto; }
        .checkmark { color: #4CAF50; font-size: 60px; margin-bottom: 20px; }
        h1 { color: #333; margin-bottom: 20px; }
        p { color: #666; line-height: 1.6; }
        .btn { background: #4CAF50; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin-top: 20px; }
        .btn:hover { background: #45a049; }
        #countdown { font-size: 48px; color: #4CAF50; font-weight: bold; margin: 20px 0; }
        .small { font-size: 14px; color: #999; }
        .payment-info { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0; text-align: left; }
        .payment-info h3 { margin: 0 0 10px 0; color: #333; }
        .payment-info p { margin: 5px 0; color: #666; }
      </style>
    </head>
    <body>
      <div class="success">
        <div class="checkmark">✓</div>
        <h1>Payment Successful!</h1>
        <p>Your AI message quota has been successfully topped up.</p>
        
        ${
          transactionDetails
            ? `
        <div class="payment-info">
          <h3>Payment Details:</h3>
          <p><strong>Transaction ID:</strong> ${
            transactionDetails.txn_id || "N/A"
          }</p>
          <p><strong>Amount:</strong> RM ${transactionDetails.amount}</p>
          <p><strong>AI Responses:</strong> ${
            transactionDetails.ai_responses
          }</p>
          <p><strong>Reference:</strong> ${
            transactionDetails.reference_number || "N/A"
          }</p>
        </div>
        `
            : ""
        }
        
        <p>Redirecting you back to your application...</p>
        <div id="countdown">5</div>
        <p class="small">You will be redirected automatically in <span id="timer">5</span> seconds</p>
        <a href="${webUrl}" class="btn" id="redirectBtn">Go to Application</a>
      </div>
      
      <script>
        // Auto-redirect after 5 seconds
        let countdown = 5;
        const timerElement = document.getElementById('timer');
        const countdownElement = document.getElementById('countdown');
        const redirectBtn = document.getElementById('redirectBtn');
        
        const interval = setInterval(() => {
          countdown--;
          timerElement.textContent = countdown;
          countdownElement.textContent = countdown;
          
          if (countdown <= 0) {
            clearInterval(interval);
            // Redirect to localhost with payment information
            window.location.href = '${webUrl}';
          }
        }, 1000);
        
        // Also try to detect if localhost is accessible
        fetch('https://web.jutateknologi.com', { mode: 'no-cors' })
          .then(() => {
            // localhost is accessible, use it
            redirectBtn.href = '${webUrl}';
          })
          .catch(() => {
            // localhost not accessible, use web.jutateknologi.com
            redirectBtn.href = '${webUrl}';
            // Update the auto-redirect as well
            setTimeout(() => {
              window.location.href = '${webUrl}';
            }, 5000);
          });
      </script>
    </body>
    </html>`);
});

// Handle OPTIONS for topup-success (CORS preflight)
app.options("/topup-success", (req, res) => {
  const origin = req.headers.origin;
  if (origin) {
    res.setHeader("Access-Control-Allow-Origin", origin);
  } else {
    res.setHeader("Access-Control-Allow-Origin", "*");
  }
  res.setHeader(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, DELETE, OPTIONS"
  );
  res.setHeader(
    "Access-Control-Allow-Headers",
    "Content-Type, Authorization, Origin, X-Requested-With, Accept, Referer"
  );
  res.setHeader("Access-Control-Allow-Credentials", "true");
  res.setHeader("Access-Control-Max-Age", "86400"); // 24 hours
  res.status(204).end();
});

// Handle PayEx POST redirect to success page
app.post("/topup-success", (req, res) => {
  console.log("PayEx redirect received:", req.body);
  console.log("Headers:", req.headers);

  // Set comprehensive CORS headers
  const origin = req.headers.origin;
  if (origin) {
    res.setHeader("Access-Control-Allow-Origin", origin);
  } else {
    res.setHeader("Access-Control-Allow-Origin", "*");
  }
  res.setHeader(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, DELETE, OPTIONS"
  );
  res.setHeader(
    "Access-Control-Allow-Headers",
    "Content-Type, Authorization, Origin, X-Requested-With, Accept, Referer"
  );
  res.setHeader("Access-Control-Allow-Credentials", "true");

  // Extract payment information from PayEx redirect
  const {
    payment_intent,
    reference_number,
    txn_id,
    amount,
    response,
    metadata,
  } = req.body;

  // Parse metadata if available
  let companyId = null;
  let aiResponses = 100;
  try {
    if (metadata) {
      const metadataObj = JSON.parse(metadata);
      companyId = metadataObj.companyId;
      aiResponses = metadataObj.aiResponses || aiResponses;
    }
  } catch (e) {
    console.log("Could not parse metadata:", e.message);
  }

  // Build redirect URL with payment information
  const webUrl = `https://web.jutateknologi.com/chat?payment_intent=${
    payment_intent || ""
  }&reference_number=${reference_number || ""}&company_id=${
    companyId || ""
  }&txn_id=${txn_id || ""}&amount=${
    amount || ""
  }&ai_responses=${aiResponses}&status=success`;

  // Send the same success page with payment information
  res.send(`    <!DOCTYPE html>
    <html>
    <head>
      <title>Top-up Success</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #f5f5f5; }
        .success { background: white; padding: 40px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); max-width: 500px; margin: 0 auto; }
        .checkmark { color: #4CAF50; font-size: 60px; margin-bottom: 20px; }
        h1 { color: #333; margin-bottom: 20px; }
        p { color: #666; line-height: 1.6; }
        .btn { background: #4CAF50; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block; margin-top: 20px; }
        .btn:hover { background: #45a049; }
        #countdown { font-size: 48px; color: #4CAF50; font-weight: bold; margin: 20px 0; }
        .small { font-size: 14px; color: #999; }
        .payment-info { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 20px 0; text-align: left; }
        .payment-info h3 { margin: 0 0 10px 0; color: #333; }
        .payment-info p { margin: 5px 0; color: #666; }
      </style>
    </head>
    <body>
      <div class="success">
        <div class="checkmark">✓</div>
        <h1>Payment Successful!</h1>
        <p>Your AI message quota has been successfully topped up.</p>
        
        ${
          payment_intent
            ? `
        <div class="payment-info">
          <h3>Payment Details:</h3>
          <p><strong>Transaction ID:</strong> ${txn_id || "N/A"}</p>
          <p><strong>Amount:</strong> RM ${
            amount ? (parseFloat(amount) / 100).toFixed(2) : "N/A"
          }</p>
          <p><strong>AI Responses:</strong> ${aiResponses}</p>
          <p><strong>Reference:</strong> ${reference_number || "N/A"}</p>
          <p><strong>Payment Intent:</strong> ${payment_intent}</p>
        </div>
        `
            : ""
        }
        
        <p>Redirecting you back to your application...</p>
        <div id="countdown">5</div>
        <p class="small">You will be redirected automatically in <span id="timer">5</span> seconds</p>
        <a href="${webUrl}" class="btn" id="redirectBtn">Go to Application</a>
      </div>
      
      <script>
        // Auto-redirect after 5 seconds
        let countdown = 5;
        const timerElement = document.getElementById('timer');
        const countdownElement = document.getElementById('countdown');
        const redirectBtn = document.getElementById('redirectBtn');
        
        const interval = setInterval(() => {
          countdown--;
          timerElement.textContent = countdown;
          countdownElement.textContent = countdown;
          
          if (countdown <= 0) {
            clearInterval(interval);
            // Redirect to localhost with payment information
            window.location.href = '${webUrl}';
          }
        }, 1000);
        
        // Also try to detect if localhost is accessible
        fetch('https://web.jutateknologi.com', { mode: 'no-cors' })
          .then(() => {
            // localhost is accessible, use it
            redirectBtn.href = '${webUrl}';
          })
          .catch(() => {
            // localhost not accessible, use web.jutateknologi.com
            redirectBtn.href = '${webUrl}';
            // Update the auto-redirect as well
            setTimeout(() => {
              window.location.href = '${webUrl}';
            }, 5000);
          });
      </script>
    </body>
    </html>`);
});

// API endpoint to verify payment status
app.get("/api/verify-payment", async (req, res) => {
  try {
    const { payment_intent, reference_number, company_id } = req.query;

    if (!payment_intent) {
      return res.status(400).json({ error: "Payment intent is required" });
    }

    // Query the database for payment status
    const result = await sqlDb.query(
      `SELECT * FROM topup_transactions WHERE payment_intent_id = $1 ORDER BY completed_at DESC LIMIT 1`,
      [payment_intent]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Payment not found" });
    }

    const transaction = result.rows[0];

    // Also check if there's a pending topup
    const pendingResult = await sqlDb.query(
      `SELECT * FROM pending_topups WHERE payment_intent_id = $1`,
      [payment_intent]
    );

    const response = {
      payment_intent,
      reference_number: transaction.reference_number || reference_number,
      company_id: transaction.company_id,
      amount: transaction.amount,
      ai_responses: transaction.ai_responses,
      status: transaction.status,
      completed_at: transaction.completed_at,
      metadata: transaction.metadata,
      has_pending_topup: pendingResult.rows.length > 0,
    };

    res.json(response);
  } catch (error) {
    console.error("Error verifying payment:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

const splitTestRouter = require("./routes/splitTest");
app.use("/api/split-test", splitTestRouter);

// Configure Multer storage
const storage = multer.diskStorage({
  destination: MEDIA_DIR,
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const baseName = path.basename(file.originalname, ext);
    const uniqueName = `${uuidv4()}_${baseName}${ext}`;
    cb(null, uniqueName);
  },
});

const upload = multer({
  storage,
  limits: {
    fileSize: 200 * 1024 * 1024, // 200MB file size limit
    fieldSize: 200 * 1024 * 1024, // 200MB field size limit (for non-file fields)
    files: 1, // Limit to 1 file per upload
    fields: 10, // Limit to 10 non-file fields
  },
});

// ======================
// 6. ROUTES
// ======================

// Basic Routes
app.get("/", (req, res) => res.send("Bot is running"));
app.get("/logs", (req, res) =>
  res.sendFile(path.join(__dirname, "public", "logs.html"))
);
app.get("/log-manager", (req, res) =>
  res.sendFile(path.join(__dirname, "public", "log-manager.html"))
);
// Health check endpoint for frontend
app.get("/api/health", (req, res) => {
  res.status(200).json({
    status: "ok",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    service: "bisnesgpt-server",
  });
});

app.get("/status", (req, res) =>
  res.sendFile(path.join(__dirname, "public", "status.html"))
);
app.get("/queue", (req, res) =>
  res.sendFile(path.join(__dirname, "public", "queue.html"))
);

// Webhook Handlers
// app.post("/extremefitness/blast", async (req, res) => {
//   const botData = botMap.get("074");
//   if (!botData)
//     return res.status(404).json({ error: "WhatsApp client not found" });
//   await handleExtremeFitnessBlast(req, res, botData[0].client);
// });

// app.post("/hajoon/blast", async (req, res) => {
//   const botData = botMap.get("045");
//   if (!botData)
//     return res.status(404).json({ error: "WhatsApp client not found" });
//   await handleHajoonCreateContact(req, res, botData[0].client);
// });

// app.post("/juta/blast", async (req, res) => {
//   const botData = botMap.get("001");
//   if (!botData)
//     return res.status(404).json({ error: "WhatsApp client not found" });
//   await handleJutaCreateContact(req, res, botData[0].client);
// });

// app.post("/zahin/hubspot", (req, res) => {
//   const getClient = () => botMap.get("042")?.[0].client;
//   handleZahinHubspot(req, res, getClient);
// });

// API Handlers
// app.post("/api/bina/tag", handleBinaTag);
// app.post("/api/edward/tag", handleEdwardTag);
app.post("/api/tag/followup", handleTagFollowUp);

// ============================================
// CERTIFICATE GENERATION & WHATSAPP SENDING
// ============================================

// Integrated endpoint for certificate generation and WhatsApp sending
app.post("/api/certificates/generate-and-send", async (req, res) => {
  const requestId = uuidv4().substring(0, 8);
  console.log(`[Certificates][${requestId}] ===== NEW REQUEST STARTED =====`);
  console.log(
    `[Certificates][${requestId}] Request body:`,
    JSON.stringify(req.body, null, 2)
  );

  try {
    const { phoneNumber, formId, formTitle, companyId } = req.body;

    // Validate required fields
    if (!phoneNumber || !formId || !formTitle || !companyId) {
      console.log(
        `[Certificates][${requestId}] ❌ Validation failed - missing required fields`
      );
      console.log(
        `[Certificates][${requestId}] phoneNumber: ${phoneNumber ? "✓" : "❌"}`
      );
      console.log(
        `[Certificates][${requestId}] formId: ${formId ? "✓" : "❌"}`
      );
      console.log(
        `[Certificates][${requestId}] formTitle: ${formTitle ? "✓" : "❌"}`
      );
      console.log(
        `[Certificates][${requestId}] companyId: ${companyId ? "✓" : "❌"}`
      );

      return res.status(400).json({
        success: false,
        error: "Missing required fields",
        details: "phoneNumber, formId, formTitle, and companyId are required",
      });
    }

    console.log(`[Certificates][${requestId}] ✅ All required fields present`);
    console.log(
      `[Certificates][${requestId}] Processing request for phone: ${phoneNumber}, form: ${formId}, company: ${companyId}`
    );

    // Send immediate response to user
    res.json({
      success: true,
      message: "Certificate generation and sending process started",
      requestId,
      status: "processing",
      participantPhone: phoneNumber,
      companyId,
    });

    // Continue processing in background (non-blocking)
    processCertificateInBackground(
      requestId,
      phoneNumber,
      formId,
      formTitle,
      companyId
    );
  } catch (error) {
    console.error(`[Certificates][${requestId}] ❌ VALIDATION ERROR:`, error);
    console.error(`[Certificates][${requestId}] Error details:`, {
      message: error.message,
      stack: error.stack,
      name: error.name,
      code: error.code,
    });

    res.status(500).json({
      success: false,
      error: "Request validation failed",
      details: error.message,
    });

    console.log(`[Certificates][${requestId}] ===== REQUEST FAILED =====`);

    // Send admin notification about the failure
    try {
      const adminPhone = "60127332108";
      const adminMessage = `❌ Certificate Generation Failed

Request ID: ${requestId}
User Phone: ${phoneNumber}
Company ID: ${companyId}
Form ID: ${formId}
Form Title: ${formTitle}

Error: ${error.message}

Please check the logs for more details.`;

      // Try to get WhatsApp client for admin notification
      const botData = botMap.get(companyId);
      if (botData && botData[0]?.client) {
        const formattedAdminPhone = adminPhone.startsWith("+")
          ? adminPhone.slice(1)
          : adminPhone;
        await botData[0].client.sendMessage(
          `${formattedAdminPhone}@c.us`,
          adminMessage
        );
        console.log(
          `[Certificates][${requestId}] ✅ Admin notification sent to ${adminPhone}`
        );
      } else {
        console.log(
          `[Certificates][${requestId}] ⚠️ Could not send admin notification - no WhatsApp client available`
        );
      }
    } catch (notificationError) {
      console.error(
        `[Certificates][${requestId}] ❌ Failed to send admin notification:`,
        notificationError
      );
    }
  }
});
// ============================================
// ALIST BLAST - Round Robin Message Sending
// ============================================

const ALIST_COMPANIES = ["0156", "092", "296245"];

app.post("/alist/blast", async (req, res) => {
  const requestId = uuidv4().substring(0, 8);
  console.log(`[AlistBlast][${requestId}] ===== NEW REQUEST STARTED =====`);
  console.log(
    `[AlistBlast][${requestId}] Request body:`,
    JSON.stringify(req.body, null, 2)
  );

  try {
    const { phone, phoneNumber, message, first_name, email, company } =
      req.body;

    // Support both 'phone' and 'phoneNumber' field names
    const recipientPhone = phone || phoneNumber;

    // Validate required fields
    if (!recipientPhone) {
      console.log(
        `[AlistBlast][${requestId}] ❌ Validation failed - missing phone number`
      );
      return res.status(400).json({
        success: false,
        error: "Missing required fields",
        details: "phone or phoneNumber is required",
      });
    }

    // Build message - use provided message or create default welcome message
    let messageText = message;
    if (!messageText) {
      messageText = `Thank you for reaching out to The A-List Malaysia!`;
      console.log(
        `[AlistBlast][${requestId}] No message provided, using default welcome message`
      );
    } else {
      console.log(`[AlistBlast][${requestId}] Using provided message`);
    }

    // Format phone number early for duplicate check
    let formattedPhone = recipientPhone.replace(/\D/g, "");
    if (!formattedPhone.startsWith("+")) {
      formattedPhone = "+" + formattedPhone;
    }

    // Check if message already sent to this lead (check across all companies)
    const duplicateCheck = await sqlDb.query(
      `SELECT contact_id, company_id FROM messages
       WHERE contact_id LIKE $1
       AND tags @> $2::jsonb
       LIMIT 1`,
      [`%-${formattedPhone.substring(1)}`, JSON.stringify(["alist-blast"])]
    );

    if (duplicateCheck.rows.length > 0) {
      console.log(
        `[AlistBlast][${requestId}] ⚠️ Duplicate detected - message already sent to ${formattedPhone}`
      );
      return res.status(200).json({
        success: true,
        duplicate: true,
        message: "Message already sent to this lead",
        data: {
          existingCompanyId: duplicateCheck.rows[0].company_id,
          phoneNumber: formattedPhone,
        },
      });
    }

    console.log(
      `[AlistBlast][${requestId}] No duplicate found, proceeding with message send`
    );

    // Get current round robin index from Neon database
    let currentSetting = await sqlDb.query(
      `SELECT round_robin_index FROM alist_blast_config LIMIT 1`
    );

    let currentIndex = currentSetting.rows[0]?.round_robin_index || 0;

    // Get next company ID using round robin
    const companyId = ALIST_COMPANIES[currentIndex];
    const nextIndex = (currentIndex + 1) % ALIST_COMPANIES.length;

    // Update round robin index in database
    await sqlDb.query(
      `UPDATE alist_blast_config
       SET round_robin_index = $1, updated_at = CURRENT_TIMESTAMP
       WHERE id = 1`,
      [nextIndex]
    );

    console.log(
      `[AlistBlast][${requestId}] Selected company ID: ${companyId} (current index: ${currentIndex}, next index: ${nextIndex})`
    );

    // Create WhatsApp chat ID
    const chatId = formattedPhone.substring(1) + "@c.us";

    console.log(
      `[AlistBlast][${requestId}] Formatted phone: ${formattedPhone}, chatId: ${chatId}`
    );

    // Send message using v2/messages/text API
    console.log(
      `[AlistBlast][${requestId}] Sending message from company ${companyId}`
    );

    await axios.post(
      `http://localhost:${port}/api/v2/messages/text/${companyId}/${encodeURIComponent(
        chatId
      )}`,
      {
        message: messageText,
        phoneIndex: 0,
      }
    );

    console.log(`[AlistBlast][${requestId}] Message sent successfully`);

    // Save to Neon database
    const contactID = companyId + "-" + formattedPhone.substring(1);
    const messageId = `blast_${requestId}_${Date.now()}`;

    await sqlDb.query(
      `INSERT INTO messages (
        company_id,
        contact_id,
        message_id,
        content,
        message_type,
        from_me,
        timestamp,
        tags
      ) VALUES ($1, $2, $3, $4, $5, $6, NOW(), $7)`,
      [
        companyId,
        contactID,
        messageId,
        messageText,
        "text",
        true,
        JSON.stringify(["alist-blast"]),
      ]
    );

    console.log(`[AlistBlast][${requestId}] Message saved to Neon database`);

    // Return success response
    res.json({
      success: true,
      data: {
        companyId,
        phoneNumber: formattedPhone,
        chatId,
        messageId,
      },
    });

    console.log(`[AlistBlast][${requestId}] ===== REQUEST COMPLETED =====`);
  } catch (error) {
    console.error(`[AlistBlast][${requestId}] ❌ Error:`, error.message);
    console.error(`[AlistBlast][${requestId}] Stack:`, error.stack);

    res.status(500).json({
      success: false,
      error: "Failed to send blast message",
      details: error.message,
    });
  }
});

// Background processing function
async function processCertificateInBackground(
  requestId,
  phoneNumber,
  formId,
  formTitle,
  companyId
) {
  try {
    console.log(
      `[Certificates][${requestId}] 🔄 Starting background processing...`
    );

    // Get WhatsApp client for the company
    console.log(
      `[Certificates][${requestId}] 🔍 Checking WhatsApp client for company: ${companyId}`
    );
    const botData = botMap.get(companyId);
    console.log(
      `[Certificates][${requestId}] Bot data found:`,
      botData ? "✓" : "❌"
    );

    let whatsappClient = null;
    let hasWhatsAppClient = false;

    if (botData && botData[0]?.client) {
      whatsappClient = botData[0].client;
      hasWhatsAppClient = true;
      console.log(
        `[Certificates][${requestId}] ✅ WhatsApp client found for company ${companyId}`
      );
      console.log(`[Certificates][${requestId}] Client info:`, {
        hasInfo: Boolean(whatsappClient.info),
        isReady: Boolean(whatsappClient.info),
      });
    } else {
      console.log(
        `[Certificates][${requestId}] ⚠️ No WhatsApp client found for company ${companyId}`
      );
      console.log(`[Certificates][${requestId}] Bot data structure:`, {
        exists: Boolean(botData),
        isArray: Array.isArray(botData),
        length: botData ? botData.length : 0,
        hasClient: botData && botData[0] ? Boolean(botData[0].client) : false,
      });
      console.log(
        `[Certificates][${requestId}] Will save certificate to folder only`
      );
    }

    // Fetch participant data from CSV
    console.log(
      `[Certificates][${requestId}] 📊 Fetching participant data from CSV...`
    );
    const participants = await fetchParticipantData();
    console.log(
      `[Certificates][${requestId}] ✅ Fetched ${participants.length} participants from CSV`
    );

    // Find participant by phone number
    console.log(
      `[Certificates][${requestId}] 🔍 Searching for participant with phone: ${phoneNumber}`
    );
    const participant = findParticipantByPhone(participants, phoneNumber);

    if (!participant || participant._notFound) {
      console.log(
        `[Certificates][${requestId}] ❌ Participant not found in any data source`
      );
      return;
    }

    // Extract participant information - FIXED to use the correct field names
    const participantName = participant.name || "Unknown Participant";

    // Extract program date from event_name or use event_date
    let programDate = "Unknown Date";
    if (participant.event_name) {
      // Extract date from event name like "21 August 2025 (Thursday) – AI Immersion..."
      const dateMatch = participant.event_name.match(/(\d{1,2}\s+\w+\s+\d{4})/);
      if (dateMatch) {
        programDate = dateMatch[1];
      } else {
        programDate = participant.event_name;
      }
    } else if (participant.event_date) {
      // If event_date is available, format it nicely
      const eventDate = new Date(participant.event_date);
      if (!isNaN(eventDate.getTime())) {
        programDate = eventDate.toLocaleDateString("en-GB", {
          day: "numeric",
          month: "long",
          year: "numeric",
        });
      }
    }

    console.log(
      `[Certificates][${requestId}] ✅ Participant found: ${participantName}`
    );
    console.log(`[Certificates][${requestId}] 📅 Program date: ${programDate}`);

    // Generate certificate PDF
    console.log(
      `[Certificates][${requestId}] 🎨 Generating certificate PDF for ${participantName}...`
    );
    const startTime = Date.now();
    const pdfBuffer = await generateCertificate(participantName, programDate);
    const generationTime = Date.now() - startTime;
    console.log(
      `[Certificates][${requestId}] ✅ Generated certificate PDF in ${generationTime}ms`
    );
    console.log(
      `[Certificates][${requestId}] 📏 PDF buffer size: ${pdfBuffer.length} bytes`
    );

    // Create certificates directory if it doesn't exist
    console.log(
      `[Certificates][${requestId}] 📁 Creating certificates directory...`
    );
    const certificatesDir = path.join(__dirname, "generated_certificates");
    if (!fs.existsSync(certificatesDir)) {
      await fsPromises.mkdir(certificatesDir, { recursive: true });
      console.log(
        `[Certificates][${requestId}] ✅ Created certificates directory: ${certificatesDir}`
      );
    } else {
      console.log(
        `[Certificates][${requestId}] ✅ Certificates directory already exists: ${certificatesDir}`
      );
    }

    // Save certificate to generated_certificates folder
    const certificateId = uuidv4();
    const filename = `${participantName.replace(
      /\s+/g,
      "_"
    )}_FUTUREX.AI_2025_Certificate.pdf`;
    const certificatePath = path.join(certificatesDir, filename);

    console.log(
      `[Certificates][${requestId}] �� Saving certificate to: ${certificatePath}`
    );
    await fsPromises.writeFile(certificatePath, pdfBuffer);
    console.log(
      `[Certificates][${requestId}] ✅ Certificate saved successfully`
    );

    // Verify file was created
    const fileStats = await fsPromises.stat(certificatePath);
    console.log(`[Certificates][${requestId}] �� File verification:`, {
      exists: true,
      size: fileStats.size,
      created: fileStats.birthtime,
      modified: fileStats.mtime,
    });

    let whatsappStatus = "Not sent (no WhatsApp client)";

    // If WhatsApp client is available, send the message and certificate
    if (hasWhatsAppClient && whatsappClient) {
      console.log(
        `[Certificates][${requestId}] 📱 WhatsApp client available, proceeding with sending...`
      );

      try {
        // Format phone number for WhatsApp
        console.log(
          `[Certificates][${requestId}] 🔢 Formatting phone number: ${phoneNumber}`
        );
        const formattedPhone = formatPhoneForWhatsApp(phoneNumber);
        console.log(
          `[Certificates][${requestId}] ✅ Formatted phone: ${formattedPhone}`
        );

        // Prepare WhatsApp message content
        const thankYouText = `Dear ${participantName}

Thank You for Attending FUTUREX.AI 2025

On behalf of the organizing team, we would like to extend our heartfelt thanks for your participation in FUTUREX.AI 2025 held on 26 August 2025.

Your presence and engagement in the AI Agent & Agentic AI Day 2025: Empowering Malaysia's Workforce with Artificial Intelligence Automation session greatly contributed to the success of the event.

We hope the experience was insightful and inspiring as we continue to explore how artificial intelligence and robotics can shape the future.

We hope you can join our next event as well.

Please find your digital certificate of participation attached.

Warm regards,
Co9P AI Chatbot`;

        console.log(
          `[Certificates][${requestId}] 📤 Sending WhatsApp message to ${formattedPhone}`
        );

        // Send WhatsApp message
        const messageStartTime = Date.now();
        await whatsappClient.sendMessage(formattedPhone, thankYouText);
        const messageTime = Date.now() - messageStartTime;
        console.log(
          `[Certificates][${requestId}] ✅ WhatsApp message sent in ${messageTime}ms to ${participantName}`
        );

        // Send certificate as document
        console.log(
          `[Certificates][${requestId}] 📎 Preparing to send certificate document...`
        );
        const media = MessageMedia.fromFilePath(certificatePath);
        console.log(`[Certificates][${requestId}] 📎 Media prepared:`, {
          filename: filename,
          path: certificatePath,
          mediaType: media.mimetype,
        });

        const documentStartTime = Date.now();
        await whatsappClient.sendMessage(formattedPhone, media, {
          caption: "Certificate of Participation",
          filename: filename,
        });
        const documentTime = Date.now() - documentStartTime;
        console.log(
          `[Certificates][${requestId}] ✅ Certificate document sent in ${documentTime}ms to ${participantName}`
        );

        whatsappStatus = "Sent successfully";
        console.log(
          `[Certificates][${requestId}] 🎉 WhatsApp sending completed successfully`
        );
      } catch (whatsappError) {
        console.error(
          `[Certificates][${requestId}] ❌ WhatsApp sending failed:`,
          whatsappError
        );
        console.error(`[Certificates][${requestId}] Error details:`, {
          message: whatsappError.message,
          stack: whatsappError.stack,
          name: whatsappError.name,
        });
        whatsappStatus = `Failed: ${whatsappError.message}`;
      }
    } else {
      console.log(
        `[Certificates][${requestId}] ⏭️ Skipping WhatsApp sending - no client available`
      );
    }

    console.log(
      `[Certificates][${requestId}] ===== BACKGROUND PROCESSING COMPLETED =====`
    );
    console.log(`[Certificates][${requestId}] Final status:`, {
      participantName,
      filename,
      certificatePath,
      whatsappStatus,
      companyId,
      hasWhatsAppClient,
    });
  } catch (error) {
    console.error(
      `[Certificates][${requestId}] ❌ BACKGROUND PROCESSING ERROR:`,
      error
    );
    console.error(`[Certificates][${requestId}] Error details:`, {
      message: error.message,
      stack: error.stack,
      name: error.name,
      code: error.code,
    });
    console.log(
      `[Certificates][${requestId}] ===== BACKGROUND PROCESSING FAILED =====`
    );

    // Send admin notification about the failure
    try {
      const adminPhone = "60127332108";
      const adminMessage = `❌ Certificate Generation Failed

Request ID: ${requestId}
User Phone: ${phoneNumber}
Company ID: ${companyId}
Form ID: ${formId}
Form Title: ${formTitle}

Error: ${error.message}

Please check the logs for more details.`;

      // Try to get WhatsApp client for admin notification
      const botData = botMap.get(companyId);
      if (botData && botData[0]?.client) {
        const formattedAdminPhone = adminPhone.startsWith("+")
          ? adminPhone.slice(1)
          : adminPhone;
        await botData[0].client.sendMessage(
          `${formattedAdminPhone}@c.us`,
          adminMessage
        );
        console.log(
          `[Certificates][${requestId}] ✅ Admin notification sent to ${adminPhone}`
        );
      } else {
        console.log(
          `[Certificates][${requestId}] ⚠️ Could not send admin notification - no WhatsApp client available`
        );
      }
    } catch (notificationError) {
      console.error(
        `[Certificates][${requestId}] ❌ Failed to send admin notification:`,
        notificationError
      );
    }
  }
}

// Helper functions for certificate generation
// Helper functions for certificate generation
async function fetchParticipantData() {
  const allParticipants = [];

  try {
    console.log(
      "[Certificates] 📊 Fetching participant data from multiple sources..."
    );

    // 1. Fetch from Neon database
    try {
      const baseUrl =
        process.env.BASE_URL || "https://bisnesgpt.jutateknologi.com";
      const companyId = "0380";

      const [participantsResponse, enrolleesResponse, eventsResponse] =
        await Promise.allSettled([
          axios.get(`${baseUrl}/api/participants?company_id=${companyId}`),
          axios.get(
            `${baseUrl}/api/enrollees?company_id=${companyId}&limit=5000`
          ), // Set high limit to get all enrollees
          axios.get(`${baseUrl}/api/events?company_id=${companyId}`),
        ]);

      if (
        participantsResponse.status === "fulfilled" &&
        enrolleesResponse.status === "fulfilled" &&
        eventsResponse.status === "fulfilled"
      ) {
        console.log(
          "[Certificates] ✅ Successfully fetched from Neon database"
        );

        const participantsData = participantsResponse.value.data;
        const enrolleesData = enrolleesResponse.value.data;
        const eventsData = eventsResponse.value.data;

        console.log("[Certificates] 🔍 Database response structure check:");
        console.log("- Participants type:", typeof participantsData);
        console.log("- Enrollees type:", typeof enrolleesData);
        console.log("- Events type:", typeof eventsData);

        // Extract arrays from the response data
        const participantsArray =
          participantsData.participants ||
          participantsData.rows ||
          participantsData.data ||
          [];
        const enrolleesArray =
          enrolleesData.enrollees ||
          enrolleesData.rows ||
          enrolleesData.data ||
          [];
        const eventsArray =
          eventsData.events || eventsData.rows || eventsData.data || [];

        console.log(
          "[Certificates] 📊 Parsed arrays: participants=" +
            participantsArray.length +
            ", enrollees=" +
            enrolleesArray.length +
            ", events=" +
            eventsArray.length
        );

        // Process participants and join with enrollee and event data
        const dbParticipants = participantsArray
          .filter(
            (participant) =>
              participant && participant.enrollee_id && participant.event_id
          )
          .map((participant) => {
            const enrollee = enrolleesArray.find(
              (e) => e.id === participant.enrollee_id
            );
            const event = eventsArray.find(
              (ev) => ev.id === participant.event_id
            );

            if (enrollee && event) {
              return {
                name: enrollee.name || "Unknown",
                phone: enrollee.mobile_number || enrollee.phone || "",
                email: enrollee.email || "",
                organisation: enrollee.organisation || "",
                event_name: event.name || "Unknown Event",
                event_date: event.start_date || "",
                source: "database",
                priority: 2,
              };
            }
            return null;
          })
          .filter(
            (p) =>
              p !== null &&
              p.name &&
              p.name !== "Unknown" &&
              p.phone &&
              isValidPhoneNumber(p.phone)
          );

        allParticipants.push(...dbParticipants);
        console.log(
          "[Certificates] 📊 Database: " +
            dbParticipants.length +
            " participants"
        );

        // ADD THIS: Also check enrollees who might not have participant records
        const orphanedEnrollees = enrolleesArray
          .filter((enrollee) => {
            // Check if this enrollee has any participant record
            const hasParticipantRecord = participantsArray.some(
              (p) => p.enrollee_id === enrollee.id
            );
            return (
              !hasParticipantRecord && enrollee.name && enrollee.mobile_number
            );
          })
          .map((enrollee) => {
            // Find any event that might be relevant (you might want to adjust this logic)
            const relevantEvent =
              eventsArray.find(
                (event) => event.name && event.name.includes("AI Immersion")
              ) || eventsArray[0]; // Fallback to first event

            return {
              name: enrollee.name,
              phone: enrollee.mobile_number || enrollee.phone || "",
              email: enrollee.email || "",
              organisation: enrollee.organisation || "",
              event_name: relevantEvent ? relevantEvent.name : "Unknown Event",
              event_date: relevantEvent ? relevantEvent.start_date : "",
              source: "database_orphaned",
              priority: 2,
            };
          })
          .filter((p) => p.phone && isValidPhoneNumber(p.phone));

        allParticipants.push(...orphanedEnrollees);
        console.log(
          "[Certificates] 📊 Database: " +
            dbParticipants.length +
            " participants + " +
            orphanedEnrollees.length +
            " orphaned = " +
            (dbParticipants.length + orphanedEnrollees.length) +
            " total"
        );

        // Debug: Check if NOOR HASANAH is in the results
        if (orphanedEnrollees.length > 0) {
          const targetParticipant = orphanedEnrollees.find(
            (p) => p.phone === "60173282776" || p.phone === "+60173282776"
          );
          if (targetParticipant) {
            console.log(
              `[Certificates] �� Found NOOR HASANAH in database:`,
              targetParticipant
            );
          } else {
            console.log(
              `[Certificates] ❌ NOOR HASANAH NOT found in database results`
            );
            console.log(
              `[Certificates] 🔍 Available phone numbers:`,
              allDbParticipants.map((p) => p.phone)
            );
          }
        }
      }
    } catch (error) {
      console.log("[Certificates] ❌ Database fetch error:", error.message);
    }

    // 2. Fetch from CSV URL if configured
    if (process.env.CSV_URL) {
      try {
        console.log(
          "[Certificates] 🔍 Fetching CSV from:",
          process.env.CSV_URL
        );
        const csvResponse = await axios.get(process.env.CSV_URL);
        const csvData = csvResponse.data;

        console.log("[Certificates] 🔍 CSV response type:", typeof csvData);
        console.log(
          "[Certificates] 🔍 CSV response length:",
          csvData ? csvData.length : "null"
        );
        console.log(
          "[Certificates] 🔍 CSV first 200 chars:",
          csvData ? csvData.substring(0, 200) : "null"
        );

        if (csvData && typeof csvData === "string") {
          // Parse CSV string into array of objects
          const csvLines = csvData.trim().split("\n");
          const headers = csvLines[0]
            .split(",")
            .map((h) => h.replace(/"/g, "").trim());

          const csvParticipants = csvLines
            .slice(1) // Skip header row
            .filter((line) => line.trim()) // Remove empty lines
            .map((line) => {
              const values = line
                .split(",")
                .map((v) => v.replace(/"/g, "").trim());
              const row = {};
              headers.forEach((header, index) => {
                row[header] = values[index] || "";
              });

              return {
                name:
                  row["Full Name"] || row["Nama"] || row["Name"] || "Unknown",
                phone:
                  row["Phone"] ||
                  row["Mobile Number"] ||
                  row["Contact Number"] ||
                  "",
                email: row["Email"] || row["email"] || "",
                organisation:
                  row["Organisation"] ||
                  row["Company"] ||
                  row["organisation"] ||
                  "",
                event_name:
                  row["Program Date & Time"] || row["Event"] || "Unknown Event",
                event_date: row["Date"] || "",
                source: "csv",
                priority: 3,
              };
            });

          allParticipants.push(...csvParticipants);
          console.log(
            `[Certificates] 📊 CSV: ${csvParticipants.length} participants`
          );
        }
      } catch (error) {
        console.log("[Certificates] ❌ CSV fetch error:", error.message);
      }
    }

    // 3. Fetch from registration form responses
    try {
      const registrationFormId = "1f666a83-9825-4d26-af03-edc2c0aeb39e";
      const registrationUrl = `${
        process.env.BASE_URL || "https://bisnesgpt.jutateknologi.com"
      }/api/feedback-responses/form/${registrationFormId}`;

      const registrationResponse = await axios.get(registrationUrl);

      if (
        registrationResponse.data &&
        registrationResponse.data.success &&
        registrationResponse.data.feedbackResponses
      ) {
        const registrationParticipants =
          registrationResponse.data.feedbackResponses
            .filter(
              (response) =>
                response && response.phone_number && response.responses
            )
            .map((response) => {
              try {
                const responses =
                  typeof response.responses === "string"
                    ? JSON.parse(response.responses)
                    : response.responses;

                let name = "";
                let eventName = "";
                let organisation = "";
                let email = "";

                if (Array.isArray(responses)) {
                  responses.forEach((item) => {
                    if (item.question && item.answer) {
                      if (
                        item.question.includes("Full Name") ||
                        item.question.includes("Nama")
                      ) {
                        name = item.answer;
                      } else if (
                        item.question.includes("Programs To Register") ||
                        item.question.includes("Event")
                      ) {
                        eventName = item.answer;
                      } else if (
                        item.question.includes("Organisation") ||
                        item.question.includes("Company")
                      ) {
                        organisation = item.answer;
                      } else if (item.question.includes("Email")) {
                        email = item.answer;
                      }
                    }
                  });
                }

                return {
                  name: name || "Unknown",
                  phone: response.phone_number || "",
                  email: email || "",
                  organisation: organisation || "",
                  event_name: eventName || "Unknown Event",
                  event_date: response.submitted_at || "",
                  source: "registration_form",
                  priority: 1,
                };
              } catch (parseError) {
                return null;
              }
            })
            .filter(
              (p) =>
                p !== null &&
                p.name &&
                p.name !== "Unknown" &&
                p.phone &&
                isValidPhoneNumber(p.phone)
            );

        allParticipants.push(...registrationParticipants);
        console.log(
          `[Certificates] �� Registration form: ${registrationParticipants.length} participants`
        );
      }
    } catch (error) {
      console.log(
        "[Certificates] ❌ Registration form fetch error:",
        error.message
      );
    }

    // 4. Deduplicate participants
    console.log(
      `[Certificates] 🔄 Deduplicating ${allParticipants.length} total participants...`
    );

    const uniqueParticipants = [];
    const seenPhones = new Set();
    const seenNames = new Set();

    // Sort by priority (1 = registration form, 2 = database, 3 = CSV)
    allParticipants.sort((a, b) => a.priority - b.priority);

    allParticipants.forEach((participant) => {
      const phone = cleanPhoneNumber(participant.phone);
      const name = participant.name.toLowerCase().trim();

      if (!seenPhones.has(phone) && !seenNames.has(name)) {
        seenPhones.add(phone);
        seenNames.add(name);
        uniqueParticipants.push(participant);
      }
    });

    console.log(
      `[Certificates] 👥 Final unique participants: ${uniqueParticipants.length}`
    );

    // Log data sources used
    const sourceCounts = {};
    uniqueParticipants.forEach((p) => {
      sourceCounts[p.source] = (sourceCounts[p.source] || 0) + 1;
    });
    console.log(`[Certificates] 📊 Data sources:`, sourceCounts);

    return uniqueParticipants;
  } catch (error) {
    console.log(
      "[Certificates] ❌ Error in fetchParticipantData:",
      error.message
    );
    return [];
  }
}
// Helper function to validate phone numbers
// Helper function to validate phone numbers
function isValidPhoneNumber(phone) {
  if (!phone || typeof phone !== "string") return false;

  // Remove all non-digit characters
  const cleanPhone = phone.replace(/\D/g, "");

  // Check if it's a valid Malaysian phone number (10-12 digits starting with 60)
  if (
    cleanPhone.startsWith("60") &&
    cleanPhone.length >= 10 &&
    cleanPhone.length <= 12
  ) {
    return true;
  }

  // Check if it's a valid phone number without country code (9-10 digits)
  if (cleanPhone.length >= 9 && cleanPhone.length <= 10) {
    return true;
  }

  // Check if it's a valid phone number with +60 prefix (11-13 characters including +)
  if (phone.startsWith("+60") && phone.length >= 11 && phone.length <= 13) {
    return true;
  }

  return false;
}

// Helper function to clean phone numbers for comparison
// ... existing code ...

// Update the cleanPhoneNumber function to handle this case better
function cleanPhoneNumber(phone) {
  if (!phone) return "";

  // Remove all non-digit characters
  let cleaned = phone.toString().replace(/\D/g, "");

  // If it's 8-9 digits and doesn't start with 60, add 60 prefix
  if (cleaned.length >= 8 && cleaned.length <= 9 && !cleaned.startsWith("60")) {
    cleaned = "60" + cleaned;
  }

  // If it's 10-12 digits and starts with 60, keep as is
  if (
    cleaned.length >= 10 &&
    cleaned.length <= 12 &&
    cleaned.startsWith("60")
  ) {
    return cleaned;
  }

  // If it's 11-13 characters and starts with +60, remove + and keep
  if (
    phone.toString().startsWith("+60") &&
    cleaned.length >= 11 &&
    cleaned.length <= 13
  ) {
    return cleaned;
  }

  return cleaned;
}

// Update the findParticipantByPhone function to be more flexible
function findParticipantByPhone(participants, phoneNumber) {
  if (!participants || !phoneNumber) {
    console.log(
      "[Certificates] ❌ Invalid parameters for findParticipantByPhone"
    );
    return null;
  }

  const targetPhone = cleanPhoneNumber(phoneNumber);
  console.log(
    `[Certificates] 🔍 Searching for participant with phone: ${phoneNumber}`
  );
  console.log(`[Certificates] 🧹 Cleaned phone number: ${targetPhone}`);

  // Try exact match first
  let participant = participants.find((p) => {
    if (!p.phone) return false;
    const cleanedPhone = cleanPhoneNumber(p.phone);
    return cleanedPhone === targetPhone;
  });

  if (participant) {
    console.log(`[Certificates] ✅ Found exact match:`, participant);
    return participant;
  }

  // Try partial match (remove 60 prefix if present)
  if (targetPhone.startsWith("60") && targetPhone.length > 10) {
    const withoutPrefix = targetPhone.substring(2);
    participant = participants.find((p) => {
      if (!p.phone) return false;
      const cleanedPhone = cleanPhoneNumber(p.phone);
      return cleanedPhone === withoutPrefix || cleanedPhone === targetPhone;
    });

    if (participant) {
      console.log(
        `[Certificates] ✅ Found partial match (without 60 prefix):`,
        participant
      );
      return participant;
    }
  }

  // Try adding 60 prefix if not present
  if (
    !targetPhone.startsWith("60") &&
    targetPhone.length >= 8 &&
    targetPhone.length <= 9
  ) {
    const withPrefix = "60" + targetPhone;
    participant = participants.find((p) => {
      if (!p.phone) return false;
      const cleanedPhone = cleanPhoneNumber(p.phone);
      return cleanedPhone === withPrefix;
    });

    if (participant) {
      console.log(
        `[Certificates] ✅ Found match with added 60 prefix:`,
        participant
      );
      return participant;
    }
  }

  console.log(
    `[Certificates] ❌ No participant found for phone: ${phoneNumber}`
  );
  return null;
}

// ... existing code ...
function formatPhoneForWhatsApp(phoneNumber) {
  console.log(
    "[Certificates] 🔢 Formatting phone number for WhatsApp:",
    phoneNumber
  );

  // Remove all non-digits
  const cleanPhone = phoneNumber.replace(/\D/g, "");
  console.log("[Certificates] 🧹 Cleaned phone number:", cleanPhone);

  // Ensure it starts with 6 (Malaysia country code)
  let formattedPhone = cleanPhone;
  if (!formattedPhone.startsWith("6")) {
    formattedPhone = "6" + formattedPhone;
    console.log(
      "[Certificates] 🌍 Added Malaysia country code:",
      formattedPhone
    );
  } else {
    console.log(
      "[Certificates] ✅ Phone number already has Malaysia country code"
    );
  }

  // Format as WhatsApp chat ID
  const whatsappFormat = `${formattedPhone}@c.us`;
  console.log("[Certificates] 📱 WhatsApp format:", whatsappFormat);

  return whatsappFormat;
}

async function generateCertificate(
  participantName,
  programDate = "26 August 2025"
) {
  console.log("[Certificates] 🎨 Starting certificate generation...");
  console.log("[Certificates] 📝 Participant name:", participantName);
  console.log("[Certificates] 📅 Program date:", programDate);

  try {
    // Try to load the certificate template
    const templatePath = path.join(
      __dirname,
      "public",
      "certificates",
      "cert.pdf"
    );
    console.log("[Certificates] 🔍 Looking for template at:", templatePath);

    let pdfDoc;

    if (fs.existsSync(templatePath)) {
      // Load existing template
      console.log("[Certificates] ✅ Template found, loading existing PDF...");
      const existingPdfBytes = await fs.promises.readFile(templatePath);
      console.log(
        "[Certificates] 📏 Template file size:",
        existingPdfBytes.length,
        "bytes"
      );
      pdfDoc = await PDFDocument.load(existingPdfBytes);
      console.log(
        "[Certificates] ✅ Existing certificate template loaded successfully"
      );
    } else {
      // Create a new certificate from scratch
      console.log(
        "[Certificates] ⚠️ No template found, creating certificate from scratch..."
      );
      pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage([595.28, 841.89]); // A4 size
      console.log("[Certificates] ✅ New certificate page created (A4 size)");

      // Add basic certificate design
      const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

      // Title
      page.drawText("Certificate of Participation", {
        x: 150,
        y: 750,
        size: 24,
        font: helveticaBold,
        color: rgb(0, 0, 0),
      });

      // Subtitle
      page.drawText("FUTUREX.AI 2025", {
        x: 200,
        y: 720,
        size: 18,
        font: helveticaBold,
        color: rgb(0, 0, 0),
      });

      // Description
      page.drawText("This is to certify that", {
        x: 200,
        y: 650,
        size: 14,
        font: helvetica,
        color: rgb(0, 0, 0),
      });

      // Participant name (centered)
      const nameWidth = helveticaBold.widthOfTextAtSize(participantName, 18);
      const nameX = (595.28 - nameWidth) / 2;
      page.drawText(participantName, {
        x: nameX,
        y: 600,
        size: 18,
        font: helveticaBold,
        color: rgb(0, 0, 0),
      });

      // Event details
      page.drawText("has successfully participated in the", {
        x: 150,
        y: 550,
        size: 14,
        font: helvetica,
        color: rgb(0, 0, 0),
      });

      page.drawText(
        "AI Agent & Agentic AI Day 2025: Empowering Malaysia's Workforce with Artificial Intelligence Automation",
        {
          x: 120,
          y: 530,
          size: 14,
          font: helvetica,
          color: rgb(0, 0, 0),
        }
      );

      // Date
      page.drawText(`held on 26 August 2025`, {
        x: 200,
        y: 500,
        size: 14,
        font: helvetica,
        color: rgb(0, 0, 0),
      });

      // Venue
      page.drawText(
        "Rashid Theaterette, Ground Floor, Idea Tower 1, UPM-MTDC Technology Centre",
        {
          x: 100,
          y: 350,
          size: 12,
          font: helvetica,
          color: rgb(0, 0, 0),
        }
      );

      // Location
      page.drawText("Serdang Selangor", {
        x: 250,
        y: 430,
        size: 12,
        font: helvetica,
        color: rgb(0, 0, 0),
      });

      // Signature
      page.drawText("Co9P AI Chatbot Team", {
        x: 200,
        y: 350,
        size: 12,
        font: helvetica,
        color: rgb(0, 0, 0),
      });

      return await pdfDoc.save();
    }

    const [page] = pdfDoc.getPages();

    // Embed built-in fonts
    const helvetica = await pdfDoc.embedFont(StandardFonts.Helvetica);
    const helveticaBold = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

    // === Draw Participant Name (bold, centered) ===
    const pageSize = page.getSize();
    const nameFont = helveticaBold;
    const nameFontSize = 18;
    const nameWidth = nameFont.widthOfTextAtSize(participantName, nameFontSize);
    const contentX = 315; // left edge of content area
    const contentWidth = 500; // width of content area
    const nameX = contentX + (contentWidth - nameWidth) / 2;
    page.drawText(participantName, {
      x: nameX,
      y: 275,
      size: nameFontSize,
      font: nameFont,
      color: rgb(0, 0, 0),
    });

    // === Draw Event Details ===
    let subtitleY = 225;

    // Helper to split text into lines that fit within a given width
    function splitTextToLines(text, font, fontSize, maxWidth) {
      const words = text.split(" ");
      const lines = [];
      let currentLine = "";
      for (const word of words) {
        const testLine = currentLine ? currentLine + " " + word : word;
        const testWidth = font.widthOfTextAtSize(testLine, fontSize);
        if (testWidth > maxWidth && currentLine) {
          lines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) lines.push(currentLine);
      return lines;
    }

    const subtitleFont = helveticaBold;
    const subtitleFontSize = 14;
    const subtitleMaxWidth = 500; // Increased width for your layout

    const subtitleLineHeight = 18; // Adjust for spacing between lines
    let subtitleLines = splitTextToLines(
      "AI Agent & Agentic AI Day 2025: Empowering Malaysia's Workforce with Artificial Intelligence Automation",
      subtitleFont,
      subtitleFontSize,
      subtitleMaxWidth
    );
    if (subtitleLines.length > 3) {
      // Truncate to 3 lines and add ellipsis to the last line
      const firstTwo = subtitleLines.slice(0, 2);
      let lastLine = subtitleLines[2];
      // If there are more lines, append ellipsis to the last visible line
      for (let i = 3; i < subtitleLines.length; i++) {
        lastLine += " " + subtitleLines[i];
      }
      // Truncate lastLine to fit and add ellipsis
      while (
        subtitleFont.widthOfTextAtSize(lastLine + "...", subtitleFontSize) >
          subtitleMaxWidth &&
        lastLine.length > 0
      ) {
        lastLine = lastLine.slice(0, -1);
      }
      lastLine = lastLine.trim() + "...";
      subtitleLines = [...firstTwo, lastLine];
    }

    // Center each subtitle line within the content area (like participant name)
    const subtitleContentX = 315; // left edge of content area (same as participant name)
    const subtitleContentWidth = 500; // width of content area (same as participant name)
    for (const line of subtitleLines) {
      const lineWidth = subtitleFont.widthOfTextAtSize(line, subtitleFontSize);
      const lineX = subtitleContentX + (subtitleContentWidth - lineWidth) / 2;
      page.drawText(line, {
        x: lineX,
        y: subtitleY,
        size: subtitleFontSize,
        font: subtitleFont,
        color: rgb(0, 0, 0),
      });
      subtitleY -= subtitleLineHeight;
    }

    // Add extra space if subtitle is 2 or more lines
    if (subtitleLines.length < 2) {
      subtitleY -= 8; // You can adjust this value for more/less space
    }

    // Date (medium font)
    page.drawText("26 August 2025", {
      x: 520,
      y: subtitleY,
      size: 14,
      font: helveticaBold,
      color: rgb(0, 0, 0),
    });

    // Venue (small font)
    page.drawText(
      "Rashid Theaterette, Ground Floor, Idea Tower 1, UPM-MTDC Technology Centre",
      {
        x: 395,
        y: 172,
        size: 12,
        font: helvetica,
        color: rgb(0, 0, 0),
      }
    );

    // Location (small font)
    page.drawText("Serdang Selangor", {
      x: 520,
      y: 162,
      size: 12,
      font: helvetica,
      color: rgb(0, 0, 0),
    });

    // Save PDF and return as buffer
    console.log("[Certificates] 💾 Saving PDF document...");
    const pdfBytes = await pdfDoc.save();
    console.log("[Certificates] ✅ PDF document saved successfully");
    console.log("[Certificates] 📏 Final PDF size:", pdfBytes.length, "bytes");

    const buffer = Buffer.from(pdfBytes);
    console.log(
      "[Certificates] ✅ Certificate generation completed successfully"
    );
    return buffer;
  } catch (error) {
    console.error("[Certificates] ❌ Error generating certificate:", error);
    console.error("[Certificates] Error details:", {
      message: error.message,
      stack: error.stack,
      name: error.name,
    });
    throw new Error("Failed to generate certificate PDF");
  }
}

// ============================================
// LOG MANAGEMENT API ENDPOINTS
// ============================================

// Get all log files
app.get("/api/logs/files", async (req, res) => {
  try {
    const files = logManager.getLogFiles();
    res.json({ success: true, files });
  } catch (error) {
    console.error("Error fetching log files:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});
app.use("/api/feedback-forms", feedbackFormsRouter);

app.use("/api/events", eventsRouter);
app.use("/api/enrollees", enrolleesRouter);
app.use("/api/participants", participantsRouter);
app.use("/api/attendance-events", attendanceEventsRouter);
app.use("/api/attendance-records", attendanceRecordsRouter);
app.use("/api/feedback-responses", feedbackResponsesRouter);
app.use("/api/certificates", certificatesRouter);

// Lead Analytics Routes
const leadAnalyticsRouter = require("./routes/leadAnalytics");
app.use("/api/lead-analytics", leadAnalyticsRouter);

// Contact Sync Routes
app.use("/api/sync", contactSyncRouter);

// Server Manager Routes
app.use("/api/server-manager", serverManagerRouter);

// WhatsApp Embedded Signup & Cloud API routes
app.use("/api/whatsapp", whatsappApiRoutes);
app.use("/webhook", metaWebhookRoutes);

// Read specific log file
app.get("/api/logs/read/:filename", async (req, res) => {
  try {
    const { filename } = req.params;
    const { lines = 100, filter = "", type = "all" } = req.query;

    const options = {
      lines: parseInt(lines),
      filter,
      type,
    };

    const logData = logManager.readLogFile(filename, options);
    res.json({ success: true, data: logData });
  } catch (error) {
    console.error("Error reading log file:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get crash summary
app.get("/api/logs/crash-summary", async (req, res) => {
  try {
    const summary = logManager.getCrashSummary();
    res.json({ success: true, summary });
  } catch (error) {
    console.error("Error getting crash summary:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Search logs
app.post("/api/logs/search", async (req, res) => {
  try {
    const {
      searchTerm,
      fileTypes = ["console", "error", "crash"],
      caseSensitive = false,
    } = req.body;

    if (!searchTerm) {
      return res
        .status(400)
        .json({ success: false, error: "Search term is required" });
    }

    const results = logManager.searchLogs(searchTerm, {
      fileTypes,
      caseSensitive,
    });
    res.json({ success: true, results });
  } catch (error) {
    console.error("Error searching logs:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get log statistics
app.get("/api/logs/stats", async (req, res) => {
  try {
    const stats = logManager.getLogStats();
    res.json({ success: true, stats });
  } catch (error) {
    console.error("Error getting log stats:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Download log file
app.get("/api/logs/download/:filename", async (req, res) => {
  try {
    const { filename } = req.params;
    const filePath = path.join(__dirname, "logs", filename);

    if (!fs.existsSync(filePath)) {
      return res
        .status(404)
        .json({ success: false, error: "Log file not found" });
    }

    res.download(filePath, filename);
  } catch (error) {
    console.error("Error downloading log file:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Manually rotate logs
app.post("/api/logs/rotate", async (req, res) => {
  try {
    logger.rotateLogs();
    res.json({ success: true, message: "Logs rotated successfully" });
  } catch (error) {
    console.error("Error rotating logs:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Clean old logs
app.post("/api/logs/clean", async (req, res) => {
  try {
    logger.cleanOldLogs();
    res.json({ success: true, message: "Old logs cleaned successfully" });
  } catch (error) {
    console.error("Error cleaning old logs:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Log a custom event
app.post("/api/logs/event", async (req, res) => {
  try {
    const { type, message, data } = req.body;

    if (!type || !message) {
      return res
        .status(400)
        .json({ success: false, error: "Type and message are required" });
    }

    logger.logEvent(type, message, data);
    res.json({ success: true, message: "Event logged successfully" });
  } catch (error) {
    console.error("Error logging event:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get real-time logs (WebSocket endpoint would be better, but this works for polling)
app.get("/api/logs/tail/:filename", async (req, res) => {
  try {
    const { filename } = req.params;
    const { lines = 50 } = req.query;

    const logData = logManager.readLogFile(filename, {
      lines: parseInt(lines),
    });
    res.json({ success: true, data: logData });
  } catch (error) {
    console.error("Error tailing log file:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ============================================
// END LOG MANAGEMENT API ENDPOINTS
// ============================================

// ============================================
// AUTO-REPLY MANAGEMENT ENDPOINTS
// ============================================

// ... existing code at line 874 ...

// ============================================
// AUTO-REPLY MANAGEMENT ENDPOINTS - UPDATED
// ============================================
// Make botMap globally accessible for auto-reply script
global.botMap = botMap;
global.pool = pool;
global.safeRelease = safeRelease;
const autoReplyChecker = require("./auto-reply-script.js");

// ============================================
// 360DIALOG WHATSAPP OFFICIAL API ENDPOINTS
// ============================================

// Onboard a new 360dialog channel
app.post("/api/whatsapp/360dialog/onboard", async (req, res) => {
  try {
    const { companyId, phoneIndex, clientId, channelId } = req.body;

    if (!companyId || phoneIndex === undefined || !clientId || !channelId) {
      return res.status(400).json({
        success: false,
        error: "Missing required fields: companyId, phoneIndex, clientId, channelId"
      });
    }

    const result = await dialog360.onboard(companyId, phoneIndex, clientId, channelId);
    res.json(result);
  } catch (error) {
    console.error("[360dialog] Onboard error:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Webhook endpoint for 360dialog events
app.post("/webhook/360dialog", async (req, res) => {
  // Respond immediately to acknowledge receipt
  res.sendStatus(200);

  try {
    await dialog360.handleWebhook(req.body);
  } catch (error) {
    console.error("[360dialog] Webhook error:", error);
  }
});

// ============================================
// AUTO-REPLY MANAGEMENT ENDPOINTS
// ============================================

// Get auto-reply status and statistics
app.get("/api/auto-reply/status/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;

    const stats = autoReplyChecker.getStats(companyId);
    res.json({
      success: true,
      data: stats,
    });
  } catch (error) {
    console.error("Error getting auto-reply status:", error);
    res.status(500).json({
      success: false,
      error: "Failed to get auto-reply status",
    });
  }
});

// Manually trigger auto-reply check
app.post("/api/auto-reply/trigger/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const { hoursThreshold = 48 } = req.body;

    console.log(`Manual auto-reply trigger requested for company ${companyId}`);

    // Run the check
    const result = await autoReplyChecker.checkUnrepliedMessages(
      companyId,
      hoursThreshold
    );

    res.json({
      success: result.success,
      message: result.message,
      count: result.count || 0,
      total: result.total || 0,
    });
  } catch (error) {
    console.error("Error triggering auto-reply:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to trigger auto-reply check",
    });
  }
});

// Test auto-reply on specific phone number
app.post("/api/auto-reply/test/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const { phoneNumber, hoursThreshold = 24 } = req.body;

    if (!phoneNumber) {
      return res.status(400).json({
        success: false,
        error: "Phone number is required for testing",
      });
    }

    console.log(
      `Auto-reply test requested for company ${companyId}, phone: ${phoneNumber}`
    );

    // Run the test
    const result = await autoReplyChecker.testAutoReply(
      companyId,
      phoneNumber,
      hoursThreshold
    );

    res.json(result);
  } catch (error) {
    console.error("Error testing auto-reply:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to test auto-reply",
    });
  }
});

// Get unreplied messages (for debugging)
app.get("/api/auto-reply/unreplied/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const { hoursThreshold = 24 } = req.query;

    const result = await autoReplyChecker.getUnrepliedMessages(
      companyId,
      parseInt(hoursThreshold)
    );
    res.json(result);
  } catch (error) {
    console.error("Error getting unreplied messages:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to get unreplied messages",
    });
  }
});

// Get auto-reply settings
app.get("/api/auto-reply/settings/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;

    const settings = await getAutoReplySettings(companyId);

    res.json({
      success: true,
      settings: settings,
    });
  } catch (error) {
    console.error("Error getting auto-reply settings:", error);
    res.status(500).json({
      success: false,
      error: "Failed to get auto-reply settings",
    });
  }
});

// Update auto-reply settings
app.post("/api/auto-reply/settings/:companyId", async (req, res) => {
  const sqlClient = await getDatabaseConnection();
  if (!sqlClient) {
    return res.status(500).json({
      success: false,
      error: "Database connection failed",
    });
  }

  try {
    const { companyId } = req.params;
    const { enabled, autoReplyHours } = req.body;

    // Validate input
    if (typeof enabled !== "boolean") {
      return res.status(400).json({
        success: false,
        error: "enabled must be a boolean value",
      });
    }

    if (
      autoReplyHours &&
      (isNaN(parseInt(autoReplyHours)) || parseInt(autoReplyHours) < 1)
    ) {
      return res.status(400).json({
        success: false,
        error: "autoReplyHours must be a positive number",
      });
    }

    const settingsData = {
      enabled: enabled,
      autoReplyHours: autoReplyHours || "6",
    };

    // Check if setting exists
    const existingResult = await sqlClient.query(
      `SELECT id FROM settings 
       WHERE company_id = $1 AND setting_type = 'autoReply' AND setting_key = 'config'`,
      [companyId]
    );

    if (existingResult.rows.length > 0) {
      // Update existing setting
      await sqlClient.query(
        `UPDATE settings 
         SET setting_value = $1, updated_at = CURRENT_TIMESTAMP
         WHERE company_id = $2 AND setting_type = 'autoReply' AND setting_key = 'config'`,
        [JSON.stringify(settingsData), companyId]
      );
    } else {
      // Insert new setting
      await sqlClient.query(
        `INSERT INTO settings (company_id, setting_type, setting_key, setting_value, created_at, updated_at)
         VALUES ($1, 'autoReply', 'config', $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
        [companyId, JSON.stringify(settingsData)]
      );
    }

    console.log(
      `Auto-reply settings updated for company ${companyId}:`,
      settingsData
    );

    res.json({
      success: true,
      message: "Auto-reply settings saved successfully",
      settings: settingsData,
    });
  } catch (error) {
    console.error("Error saving auto-reply settings:", error);
    res.status(500).json({
      success: false,
      error: "Failed to save auto-reply settings",
    });
  } finally {
    sqlClient.release();
  }
});

// Manual sync messages and auto-reply trigger (bypasses auto-reply enabled check)
app.post("/api/manual-sync-auto-reply/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const { autoReplyHours = 6 } = req.body;

    console.log(
      `Manual sync and auto-reply trigger requested for company ${companyId}`
    );

    // Validate autoReplyHours
    const hoursThreshold = parseInt(autoReplyHours);
    if (isNaN(hoursThreshold) || hoursThreshold < 1) {
      return res.status(400).json({
        success: false,
        error: "autoReplyHours must be a positive number",
      });
    }

    // Check if bot exists
    const botData = botMap.get(companyId);
    if (!botData || !Array.isArray(botData)) {
      return res.status(404).json({
        success: false,
        error: `Bot ${companyId} not found or not initialized`,
      });
    }

    try {
      console.log(
        `[Manual] Processing all phones for bot ${companyId} with ${hoursThreshold} hours threshold`
      );

      // Use the existing function with forceEnabled=true and custom hours
      await syncMessagesAndHandleAutoReplies(
        companyId,
        botData.length,
        true,
        hoursThreshold
      );

      const response = {
        success: true,
        message: `Manual sync and auto-reply completed for company ${companyId}`,
        processedPhones: botData.length,
        autoReplyHours: hoursThreshold,
      };

      console.log(
        `[Manual] Completed manual trigger for company ${companyId}:`,
        response
      );
      res.json(response);
    } catch (error) {
      console.error(`[Manual] Error processing company ${companyId}:`, error);
      res.status(500).json({
        success: false,
        error: error.message || "Failed to process manual sync and auto-reply",
      });
    }
  } catch (error) {
    console.error("Error in manual sync auto-reply:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to execute manual sync and auto-reply",
    });
  }
});

const port = process.env.PORT;
server.listen(port, () => console.log(`Server is running on port ${port}`));

// Function to broadcast logs to WebSocket clients
function broadcastLog(logData) {
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN && client.isLogsViewer) {
      client.send(
        JSON.stringify({
          type: "log",
          data: logData,
          timestamp: new Date().toISOString(),
        })
      );
    }
  });
}

// Override console methods to capture logs
const originalConsoleLog = console.log;
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;

console.log = function (...args) {
  const logMessage = args
    .map((arg) => (typeof arg === "object" ? JSON.stringify(arg) : String(arg)))
    .join(" ");
  originalConsoleLog.apply(console, args);
  broadcastLog(logMessage);
};

console.error = function (...args) {
  const logMessage = args
    .map((arg) => (typeof arg === "object" ? JSON.stringify(arg) : String(arg)))
    .join(" ");
  originalConsoleError.apply(console, args);
  broadcastLog(`ERROR: ${logMessage}`);
};

console.warn = function (...args) {
  const logMessage = args
    .map((arg) => (typeof arg === "object" ? JSON.stringify(arg) : String(arg)))
    .join(" ");
  originalConsoleWarn.apply(console, args);
  broadcastLog(`WARN: ${logMessage}`);
};

// ============================================
// AUTOMATED LOG MANAGEMENT
// ============================================

// Schedule daily log rotation at midnight
const scheduleLogRotation = () => {
  const now = new Date();
  const midnight = new Date();
  midnight.setHours(24, 0, 0, 0); // Next midnight

  const msUntilMidnight = midnight.getTime() - now.getTime();

  setTimeout(() => {
    logger.rotateLogs();
    logger.cleanOldLogs();

    // Schedule next rotation in 24 hours
    setInterval(() => {
      logger.rotateLogs();
      logger.cleanOldLogs();
    }, 24 * 60 * 60 * 1000); // 24 hours
  }, msUntilMidnight);

  console.log(`Log rotation scheduled for ${midnight.toISOString()}`);
};

// Initialize log rotation scheduling
scheduleLogRotation();

// Monitor server health and log important events
const monitorServerHealth = () => {
  setInterval(() => {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();

    // Log if memory usage is high (over 500MB)
    if (memUsage.heapUsed > 500 * 1024 * 1024) {
      logger.logEvent("PERFORMANCE", "High memory usage detected", {
        memoryUsage: memUsage,
        timestamp: new Date().toISOString(),
      });
    }

    // Log server health every hour
    if (new Date().getMinutes() === 0) {
      logger.logEvent("HEALTH_CHECK", "Server health check", {
        memoryUsage: memUsage,
        cpuUsage: cpuUsage,
        uptime: process.uptime(),
        timestamp: new Date().toISOString(),
      });
    }
  }, 60000); // Check every minute
};

// Initialize server health monitoring
monitorServerHealth();

// ============================================
// END AUTOMATED LOG MANAGEMENT
// ============================================

// Function to save media locally
async function saveMediaLocally(base64Data, mimeType, filename) {
  const writeFileAsync = promisify(fs.writeFile);
  const buffer = Buffer.from(base64Data, "base64");
  const uniqueFilename = `${uuidv4()}_${filename}`;
  const filePath = path.join(MEDIA_DIR, uniqueFilename);
  const baseUrl = process.env.URL;

  await writeFileAsync(filePath, buffer);

  // Return the URL path to access this file
  return `${baseUrl}/media/${uniqueFilename}`;
}

app.post("/api/upload-media", upload.single("file"), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: "No file uploaded" });
  }
  const baseUrl = process.env.URL;
  const fileUrl = `${baseUrl}/media/${req.file.filename}`;
  res.json({ url: fileUrl });
});

// Handle WebSocket connections
wss.on("connection", (ws, req) => {
  // Parse URL to handle different WebSocket endpoints
  const urlParts = req.url.split("/");

  let email, companyId;

  // Handle different URL patterns:
  // /ws/chatgpt/email/companyId - ChatGPT endpoint
  // /ws/email/companyId - Legacy endpoint
  // /status, /logs, /ai-assistant-stream - Other endpoints
  if (req.url.startsWith("/ws/chatgpt/")) {
    email = urlParts[3]; // /ws/chatgpt/email/companyId
    companyId = urlParts[4];
  } else if (req.url.startsWith("/ws/") && urlParts.length >= 4) {
    email = urlParts[2]; // /ws/email/companyId
    companyId = urlParts[3];
  }

  // Set pathname for different connection types
  ws.pathname = req.url.startsWith("/status")
    ? "/status"
    : req.url.startsWith("/logs")
    ? "/logs"
    : req.url.startsWith("/ai-assistant-stream")
    ? "/ai-assistant-stream"
    : req.url.startsWith("/ws/chatgpt/")
    ? "/ws/chatgpt"
    : "/ws";
  ws.companyId = companyId;
  ws.email = email;
  ws.subscribedChatId = null;

  // Mark logs viewers
  if (ws.pathname === "/logs") {
    ws.isLogsViewer = true;
  }

  // If this is a status page connection, send current bot statuses
  if (ws.pathname === "/status") {
    // Send current statuses for all bots
    setTimeout(async () => {
      try {
        for (const [botName, botData] of botMap.entries()) {
          if (Array.isArray(botData)) {
            botData.forEach((phoneData, phoneIndex) => {
              if (phoneData && phoneData.status) {
                const statusMessage = {
                  type: "status_update",
                  botName,
                  status: phoneData.status,
                  phoneIndex,
                  qrCode: phoneData.qrCode || null,
                  timestamp: new Date().toISOString(),
                };

                if (ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify(statusMessage));
                }
              }
            });
          }
        }
      } catch (error) {
        console.error(
          "Error sending initial status to status page client:",
          error
        );
      }
    }, 100); // Small delay to ensure connection is fully established
  }

  // Handle messages from client
  ws.on("message", async (message) => {
    try {
      const data = JSON.parse(message);
      // Handle chat subscription
      if (data.type === "subscribe" && data.companyId) {
        ws.companyId = data.companyId;
        console.log(`WebSocket subscribed to company: ${data.companyId}`);
        ws.send(
          JSON.stringify({
            type: "subscribed",
            companyId: data.companyId,
          })
        );
        return;
      }
      if (data.type === "subscribe" && data.chatId) {
        ws.subscribedChatId = data.chatId;

        if (!chatSubscriptions.has(data.chatId)) {
          chatSubscriptions.set(data.chatId, new Set());
        }
        chatSubscriptions.get(data.chatId).add(ws);

        ws.send(JSON.stringify({ type: "subscribed", chatId: data.chatId }));
        return;
      }

      if (data.action === "fetch_chats") {
        // Start fetching chats
        const totalChats = await sqlDb.getRow(
          "SELECT COUNT(*) as count FROM contacts WHERE company_id = $1",
          [companyId]
        );

        ws.send(
          JSON.stringify({
            type: "progress",
            status: "processing",
            action: "fetching_chats",
            totalChats: totalChats.count,
          })
        );

        // Process chats in batches
        let processed = 0;
        const batchSize = 10;

        while (processed < totalChats.count) {
          const chats = await sqlDb.getRows(
            "SELECT * FROM contacts WHERE company_id = $1 LIMIT $2 OFFSET $3",
            [companyId, batchSize, processed]
          );

          processed += chats.length;

          ws.send(
            JSON.stringify({
              type: "progress",
              status: "processing",
              action: "processing_chats",
              fetchedChats: processed,
              totalChats: totalChats.count,
            })
          );

          // Add delay between batches
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }

        ws.send(
          JSON.stringify({
            type: "progress",
            status: "ready",
            action: "done_process",
          })
        );
      }

      // Handle logs WebSocket messages
      if (ws.pathname === "/logs") {
        if (data.type === "restart" && data.password) {
          // Verify password (you should use environment variable for this)
          const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "P@ssw0rd123";

          if (data.password === ADMIN_PASSWORD) {
            try {
              // Execute git pull first, then PM2 restart
              const { exec } = require("child_process");
              
              ws.send(
                JSON.stringify({
                  type: "restart",
                  success: true,
                  message: "🔄 Pulling latest code from git...",
                  stage: "git_pull"
                })
              );

              exec("git pull origin master", { cwd: __dirname }, (gitError, gitStdout, gitStderr) => {
                if (gitError) {
                  console.error("Git pull error:", gitError);
                  ws.send(
                    JSON.stringify({
                      type: "restart",
                      success: false,
                      message: `Git pull failed: ${gitError.message}\n${gitStderr}`,
                      stage: "git_pull_failed"
                    })
                  );
                  return;
                }
                
                console.log("Git pull successful:", gitStdout);
                ws.send(
                  JSON.stringify({
                    type: "restart",
                    success: true,
                    message: `✅ Git pull successful\n${gitStdout}\n\n🔄 Restarting PM2...`,
                    stage: "pm2_restart"
                  })
                );

                // Now restart PM2
                exec("pm2 restart all", (error, stdout, stderr) => {
                  if (error) {
                    console.error("PM2 restart error:", error);
                    ws.send(
                      JSON.stringify({
                        type: "restart",
                        success: false,
                        message: `PM2 restart failed: ${error.message}`,
                        stage: "pm2_failed"
                      })
                    );
                  } else {
                    console.log("PM2 restart successful:", stdout);
                    ws.send(
                      JSON.stringify({
                        type: "restart",
                        success: true,
                        message: "✅ Server restarted successfully!\n\n" + gitStdout + "\n" + stdout,
                        stage: "complete"
                      })
                    );
                  }
                });
              });
            } catch (error) {
              ws.send(
                JSON.stringify({
                  type: "restart",
                  success: false,
                  message: `Restart failed: ${error.message}`,
                  stage: "error"
                })
              );
            }
          } else {
            ws.send(
              JSON.stringify({
                type: "restart",
                success: false,
                message: "Invalid password",
              })
            );
          }
        }

        if (data.type === "deleteSessions" && data.password && data.sessions) {
          const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || "P@ssw0rd123";

          if (data.password === ADMIN_PASSWORD) {
            try {
              const fs = require("fs");
              const path = require("path");
              let deletedCount = 0;

              for (const session of data.sessions) {
                const sessionPath = path.join(
                  __dirname,
                  ".wwebjs_auth",
                  session
                );
                try {
                  if (fs.existsSync(sessionPath)) {
                    fs.rmSync(sessionPath, { recursive: true, force: true });
                    deletedCount++;
                  }
                } catch (err) {
                  console.error(`Error deleting session ${session}:`, err);
                }
              }

              ws.send(
                JSON.stringify({
                  type: "sessionsDeleted",
                  success: true,
                  message: `Successfully deleted ${deletedCount} session(s)`,
                })
              );
            } catch (error) {
              ws.send(
                JSON.stringify({
                  type: "sessionsDeleted",
                  success: false,
                  message: `Delete failed: ${error.message}`,
                })
              );
            }
          } else {
            ws.send(
              JSON.stringify({
                type: "sessionsDeleted",
                success: false,
                message: "Invalid password",
              })
            );
          }
        }
      }

      // Handle AI Assistant Streaming WebSocket messages
      if (ws.pathname === "/ai-assistant-stream") {
        if (data.type === "ai-brainstorm" && data.message && data.email) {
          console.log("🤖 AI Assistant Brainstorm WebSocket Request:", {
            userInput: data.message
              ? data.message.substring(0, 100) + "..."
              : "No message",
            email: data.email,
            messageLength: data.message ? data.message.length : 0,
          });

          // Process AI brainstorm request with streaming
          try {
            let threadID;
            const contactData = await getContactDataFromDatabaseByEmail(
              data.email
            );

            if (contactData?.thread_id) {
              threadID = contactData.thread_id;
              console.log("✅ Using existing thread ID:", threadID);
            } else {
              const thread = await createThread();
              threadID = thread.id;
              console.log("🆕 Created new thread ID:", threadID);
              await saveThreadIDPostgres(data.email, threadID);
              console.log(
                "💾 Saved new thread ID to database for email:",
                data.email
              );
            }

            // Add user message to thread
            console.log(
              "📝 Adding user message to thread (length:",
              data.message.length,
              ")"
            );
            await addMessage(threadID, data.message);
            console.log("✅ User message added to thread");

            // Create and run the assistant with streaming
            console.log(
              "🤖 Creating and running multi-layer agent assistant..."
            );

            const assistantResponse = await openai.beta.threads.runs.create(
              threadID,
              {
                assistant_id:
                  process.env.ASSISTANT_ID || "asst_QfkZ8GeCw0Rbc2zRW4B86FWD",
              }
            );
            console.log(
              "✅ Assistant run created with ID:",
              assistantResponse.id
            );

            // Stream the completion to WebSocket
            await waitForCompletionBrainstormStream(
              threadID,
              assistantResponse.id,
              data.email,
              ws
            );
          } catch (error) {
            console.error("💥 AI Assistant brainstorm WebSocket error:", error);
            ws.send(
              JSON.stringify({
                type: "error",
                success: false,
                error: error.code || "AI_ERROR",
                message:
                  error.message ||
                  "An error occurred while processing your AI request",
              })
            );
          }
        }
      }

      // Handle ChatGPT WebSocket messages
      if (ws.pathname === "/ws/chatgpt") {
        if (data.type === "ai-message" && data.message && data.email) {
          // Send IMMEDIATE acknowledgment - fastest possible response
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(
              JSON.stringify({
                type: "received",
                message: "📨 Message received!",
                status: "received",
                animation: "quickFlash",
                color: "#22c55e",
                icon: "📨",
                progress: 0,
                timestamp: new Date().toISOString(),
              })
            );
          }

          console.log("💬 ChatGPT WebSocket Request:", {
            userInput: data.message
              ? data.message.substring(0, 100) + "..."
              : "No message",
            email: data.email,
            companyId: data.companyId,
            messageLength: data.message ? data.message.length : 0,
          });

          try {
            let threadID;
            const contactData = await getContactDataFromDatabaseByEmail(
              data.email
            );

            if (contactData?.thread_id) {
              threadID = contactData.thread_id;
              console.log("✅ Using existing thread ID:", threadID);
            } else {
              const thread = await createThread();
              threadID = thread.id;
              console.log("🆕 Created new thread ID:", threadID);
              await saveThreadIDPostgres(data.email, threadID);
              console.log(
                "💾 Saved new thread ID to database for email:",
                data.email
              );
            }

            // Send preparing message
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(
                JSON.stringify({
                  type: "preparing",
                  message: "⚡ Preparing AI response...",
                  status: "preparing",
                  animation: "ripple",
                  color: "#f97316",
                  icon: "⚡",
                  progress: 3,
                  step: "setup",
                })
              );
            }

            // Add user message to thread
            console.log(
              "📝 Adding user message to thread (length:",
              data.message.length,
              ")"
            );
            await addMessage(threadID, data.message);
            console.log("✅ User message added to thread");

            // Create and run the assistant with streaming
            console.log("🤖 Creating and running ChatGPT assistant...");

            const assistantResponse = await openai.beta.threads.runs.create(
              threadID,
              {
                assistant_id:
                  process.env.ASSISTANT_ID || "asst_QfkZ8GeCw0Rbc2zRW4B86FWD",
              }
            );
            console.log(
              "✅ Assistant run created with ID:",
              assistantResponse.id
            );

            // Send immediate thinking indicator
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(
                JSON.stringify({
                  type: "thinking",
                  message: "🤖 AI is thinking...",
                  status: "generating",
                  animation: "fadeIn",
                  color: "#6366f1",
                  icon: "🤖",
                  progress: 5,
                  isInitial: true,
                })
              );
            }

            // Stream the completion to WebSocket
            await waitForCompletionBrainstormStream(
              threadID,
              assistantResponse.id,
              data.email,
              ws
            );
          } catch (error) {
            console.error("💥 ChatGPT WebSocket error:", error);
            ws.send(
              JSON.stringify({
                type: "error",
                success: false,
                error: error.code || "AI_ERROR",
                message:
                  error.message ||
                  "An error occurred while processing your ChatGPT request",
              })
            );
          }
        }
      }
    } catch (error) {
      console.error("WebSocket error:", error);
      ws.send(
        JSON.stringify({
          type: "error",
          message: "An error occurred while processing your request",
        })
      );
    }
  });

  ws.on("close", () => {
    // Remove ws from any chat subscriptions
    if (ws.subscribedChatId && chatSubscriptions.has(ws.subscribedChatId)) {
      chatSubscriptions.get(ws.subscribedChatId).delete(ws);
      if (chatSubscriptions.get(ws.subscribedChatId).size === 0) {
        chatSubscriptions.delete(ws.subscribedChatId);
      }
    }
    console.log(`WebSocket closed for ${email}`);
  });
});
// AI Assistant Brainstorm API - creates or retrieves thread and saves to database
app.post("/api/ai-assistant-brainstorm/", async (req, res) => {
  try {
    // Read from request body instead of query parameters
    const userInput = req.body.message;
    const email = req.body.email;

    // Log the request
    console.log("�� AI Assistant Brainstorm Request:", {
      userInput: userInput ? userInput.substring(0, 100) + "..." : "No message",
      email,
      messageLength: userInput ? userInput.length : 0,
    });

    // Validate required fields
    if (!userInput || !email) {
      return res.status(400).json({
        success: false,
        error: "MISSING_FIELDS",
        details: "Both message and email are required",
      });
    }

    let threadID;
    const contactData = await getContactDataFromDatabaseByEmail(email);

    if (contactData?.thread_id) {
      threadID = contactData.thread_id;
      console.log("✅ Using existing thread ID:", threadID);
    } else {
      const thread = await createThread();
      threadID = thread.id;
      console.log("�� Created new thread ID:", threadID);
      await saveThreadIDPostgres(email, threadID);
      console.log("💾 Saved new thread ID to database for email:", email);
    }

    // Add user message to thread
    console.log(
      "📝 Adding user message to thread (length:",
      userInput.length,
      ")"
    );
    await addMessage(threadID, userInput);
    console.log("✅ User message added to thread");

    // Create and run the assistant with tool definitions
    console.log("🤖 Creating and running multi-layer agent assistant...");

    const assistantResponse = await openai.beta.threads.runs.create(threadID, {
      assistant_id: process.env.ASSISTANT_ID || "asst_QfkZ8GeCw0Rbc2zRW4B86FWD",
    });
    console.log("✅ Assistant run created with ID:", assistantResponse.id);

    // Use the same pattern as handleMessagesFiraz.js
    const answer = await waitForCompletionBrainstorm(
      threadID,
      assistantResponse.id,
      email
    );

    // Save the interaction to the thread for future reference
    console.log("�� Saving interaction to thread...");
    await addMessageAssistant(
      threadID,
      `AI Creation Request: ${userInput}\nResponse: ${answer}`
    );
    console.log("✅ Interaction saved to thread");

    // Send response
    console.log("📤 Sending response to client...");
    res.json({
      success: true,
      data: {
        aiConfiguration: answer,
        analysis:
          answer
            .split("[ANALYSIS_START]")[1]
            ?.split("[ANALYSIS_END]")[0]
            ?.trim() || "AI configuration created successfully!",
        suggestions: [
          answer
            .split("[AI_CONFIG_START]")[1]
            ?.split("[AI_CONFIG_END]")[0]
            ?.trim() || answer,
        ],
        threadID: threadID,
        webSearchPerformed:
          answer.includes("web search") || answer.includes("search results"),
        toolsUsed: answer.includes("tool") || answer.includes("function"),
      },
    });
    console.log("✅ Response sent successfully");
  } catch (error) {
    console.error("💥 AI Assistant brainstorm error:", {
      name: error.name,
      message: error.message,
      code: error.code,
      stack: error.stack,
    });
    res.status(500).json({
      success: false,
      error: error.code,
      details: error.message,
    });
  }
});

// Wait for completion function (same pattern as handleMessagesFiraz.js)
async function waitForCompletionBrainstorm(threadId, runId, email, depth = 0) {
  const maxDepth = 5; // Maximum recursion depth
  const maxAttempts = 30;
  const pollingInterval = 2000; // 2 seconds

  console.log(
    `⏳ Waiting for completion (depth: ${depth}, runId: ${runId})...`
  );

  if (depth >= maxDepth) {
    console.error(`❌ Max recursion depth reached for runId: ${runId}`);
    return "I apologize, but I'm having trouble completing this task. Could you please try rephrasing your request?";
  }

  for (let attempts = 0; attempts < maxAttempts; attempts++) {
    try {
      const runObject = await openai.beta.threads.runs.retrieve(
        threadId,
        runId
      );
      console.log(
        `🔍 Run status: ${runObject.status} (attempt ${attempts + 1})`
      );

      if (runObject.status === "completed") {
        console.log("✅ Run completed successfully");
        const messagesList = await openai.beta.threads.messages.list(threadId);
        const latestMessage = messagesList.data[0].content[0].text.value;
        return latestMessage;
      } else if (runObject.status === "requires_action") {
        console.log("🛠️ Run requires action, handling tool calls...");
        const toolCalls =
          runObject.required_action.submit_tool_outputs.tool_calls;

        const toolOutputs = await handleToolCallsBrainstorm(toolCalls, email);

        // Submit tool outputs back to the assistant
        await openai.beta.threads.runs.submitToolOutputs(threadId, runId, {
          tool_outputs: toolOutputs,
        });
        console.log(
          "✅ Tool outputs submitted, restarting wait for completion..."
        );

        return await waitForCompletionBrainstorm(
          threadId,
          runId,
          email,
          depth + 1
        );
      } else if (
        ["failed", "cancelled", "expired"].includes(runObject.status)
      ) {
        console.error(`❌ Run ${runId} ended with status: ${runObject.status}`);
        return `I encountered an error (${runObject.status}). Please try your request again.`;
      }

      await new Promise((resolve) => setTimeout(resolve, pollingInterval));
    } catch (error) {
      console.error(
        `❌ Error in waitForCompletionBrainstorm (depth: ${depth}, runId: ${runId}): ${error}`
      );
      return "I'm sorry, but I encountered an error while processing your request. Please try again.";
    }
  }

  console.error(
    `⏰ Timeout: Assistant did not complete in time (depth: ${depth}, runId: ${runId})`
  );
  return "I'm sorry, but it's taking longer than expected to process your request. Please try again or rephrase your question.";
}

// WebSocket Streaming version of waitForCompletionBrainstorm
async function waitForCompletionBrainstormStream(
  threadId,
  runId,
  email,
  ws,
  depth = 0
) {
  const maxDepth = 5;
  const maxAttempts = 30;
  const pollingInterval = 2000; // 2 seconds
  let fullResponse = "";

  console.log(
    `⏳ Waiting for completion with streaming (depth: ${depth}, runId: ${runId})...`
  );

  // Send initial status update if WebSocket is available
  if (depth === 0 && ws && ws.readyState === WebSocket.OPEN) {
    ws.send(
      JSON.stringify({
        type: "status",
        message: "🚀 Processing your request...",
        status: "processing",
        animation: "slideIn",
        color: "#059669",
        icon: "🚀",
        progress: 10,
      })
    );
  }

  if (depth >= maxDepth) {
    console.error(`❌ Max recursion depth reached for runId: ${runId}`);
    const errorMessage =
      "I apologize, but I'm having trouble completing this task. Could you please try rephrasing your request?";
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(
        JSON.stringify({
          type: "error",
          message: errorMessage,
        })
      );
    }
    return errorMessage;
  }

  for (let attempts = 0; attempts < maxAttempts; attempts++) {
    try {
      const runObject = await openai.beta.threads.runs.retrieve(
        threadId,
        runId
      );

      console.log(
        `🔄 Run status (depth: ${depth}, attempt: ${attempts + 1}): ${
          runObject.status
        }`
      );

      // Send periodic thinking indicators during long processing
      if (runObject.status === "in_progress" || runObject.status === "queued") {
        if (
          ws &&
          ws.readyState === WebSocket.OPEN &&
          attempts > 0 &&
          attempts % 3 === 0
        ) {
          const thinkingStates = [
            {
              message: "🧠 Thinking...",
              animation: "pulse",
              color: "#3b82f6",
              icon: "🧠",
            },
            {
              message: "🔍 Analyzing your request...",
              animation: "spin",
              color: "#8b5cf6",
              icon: "🔍",
            },
            {
              message: "✨ Generating response...",
              animation: "bounce",
              color: "#10b981",
              icon: "✨",
            },
            {
              message: "⚡ Almost ready...",
              animation: "glow",
              color: "#f59e0b",
              icon: "⚡",
            },
          ];
          const stateIndex = Math.floor(attempts / 3) % thinkingStates.length;
          const currentState = thinkingStates[stateIndex];

          ws.send(
            JSON.stringify({
              type: "thinking",
              message: currentState.message,
              status: "processing",
              animation: currentState.animation,
              color: currentState.color,
              icon: currentState.icon,
              progress: Math.min(95, (attempts / maxAttempts) * 100),
              attempt: attempts + 1,
              maxAttempts: maxAttempts,
            })
          );
        }
      }

      if (runObject.status === "completed") {
        console.log("✅ Run completed, fetching messages...");
        const messages = await openai.beta.threads.messages.list(threadId);
        const assistantMessages = messages.data.filter(
          (message) => message.role === "assistant"
        );

        if (assistantMessages.length > 0) {
          const latestMessage = assistantMessages[0];
          if (
            latestMessage.content &&
            latestMessage.content[0] &&
            latestMessage.content[0].text
          ) {
            fullResponse = latestMessage.content[0].text.value;
            console.log("📝 Got response, streaming to client...");

            // Stream the response word by word
            const words = fullResponse.split(" ");
            let streamedText = "";

            for (let i = 0; i < words.length; i++) {
              if (ws.readyState !== WebSocket.OPEN) {
                console.log("WebSocket closed, stopping stream");
                break;
              }

              streamedText += (i > 0 ? " " : "") + words[i];

              ws.send(
                JSON.stringify({
                  type: "stream",
                  content: words[i],
                  fullContent: streamedText,
                  isComplete: i === words.length - 1,
                  wordIndex: i,
                  totalWords: words.length,
                })
              );

              // Add a small delay between words to simulate ChatGPT-like streaming
              await new Promise((resolve) => setTimeout(resolve, 50));
            }

            // Send completion message
            if (ws.readyState === WebSocket.OPEN) {
              ws.send(
                JSON.stringify({
                  type: "complete",
                  fullResponse: fullResponse,
                  analysis:
                    fullResponse
                      .split("[ANALYSIS_START]")[1]
                      ?.split("[ANALYSIS_END]")[0]
                      ?.trim() || "AI configuration created successfully!",
                  suggestions: [
                    fullResponse
                      .split("[AI_CONFIG_START]")[1]
                      ?.split("[AI_CONFIG_END]")[0]
                      ?.trim() || fullResponse,
                  ],
                  threadID: threadId,
                  webSearchPerformed:
                    fullResponse.includes("web search") ||
                    fullResponse.includes("search results"),
                  toolsUsed:
                    fullResponse.includes("tool") ||
                    fullResponse.includes("function"),
                })
              );
            }

            return fullResponse;
          }
        }

        const defaultResponse =
          "I apologize, but I couldn't generate a proper response. Please try again.";
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "error",
              message: defaultResponse,
            })
          );
        }
        return defaultResponse;
      } else if (runObject.status === "requires_action") {
        console.log("🛠️ Run requires action, handling tool calls...");
        const toolOutputs = await handleToolCallsBrainstorm(
          runObject.required_action.submit_tool_outputs.tool_calls,
          email
        );

        await openai.beta.threads.runs.submitToolOutputs(threadId, runId, {
          tool_outputs: toolOutputs,
        });

        console.log(
          "✅ Tool outputs submitted, restarting wait for completion..."
        );

        return await waitForCompletionBrainstormStream(
          threadId,
          runId,
          email,
          ws,
          depth + 1
        );
      } else if (
        ["failed", "cancelled", "expired"].includes(runObject.status)
      ) {
        console.error(`❌ Run ${runId} ended with status: ${runObject.status}`);
        const errorMessage = `I encountered an error (${runObject.status}). Please try your request again.`;
        if (ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: "error",
              message: errorMessage,
            })
          );
        }
        return errorMessage;
      }

      await new Promise((resolve) => setTimeout(resolve, pollingInterval));
    } catch (error) {
      console.error(
        `❌ Error in waitForCompletionBrainstormStream (depth: ${depth}, runId: ${runId}): ${error}`
      );
      const errorMessage =
        "I'm sorry, but I encountered an error while processing your request. Please try again.";
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(
          JSON.stringify({
            type: "error",
            message: errorMessage,
          })
        );
      }
      return errorMessage;
    }
  }

  console.error(
    `⏰ Timeout: Assistant did not complete in time (depth: ${depth}, runId: ${runId})`
  );
  const timeoutMessage =
    "I'm sorry, but it's taking longer than expected to process your request. Please try again or rephrase your question.";
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(
      JSON.stringify({
        type: "error",
        message: timeoutMessage,
      })
    );
  }
  return timeoutMessage;
}

// Handle tool calls function (same pattern as handleMessagesFiraz.js)
async function handleToolCallsBrainstorm(toolCalls, email) {
  console.log("🛠️ Handling tool calls...");
  console.log(`📋 Found ${toolCalls.length} tool calls to process`);

  const toolOutputs = [];

  for (const toolCall of toolCalls) {
    console.log(`🔧 Processing tool call: ${toolCall.function.name}`);
    console.log(`📝 Tool call arguments: ${toolCall.function.arguments}`);
    console.log(`🆔 Tool call ID: ${toolCall.id}`);

    switch (toolCall.function.name) {
      case "searchWeb":
        try {
          console.log("🌐 Processing searchWeb tool call...");
          const args = JSON.parse(toolCall.function.arguments);
          const searchResults = await searchWeb(args.query);
          console.log("✅ Web search completed successfully");

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: searchResults,
          });
          console.log("📤 Added search results to tool outputs");
        } catch (error) {
          console.error(
            "❌ Error in handleToolCallsBrainstorm for searchWeb:",
            error
          );
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break;

      case "search_web":
        try {
          console.log("�� Processing search_web tool call...");
          const args = JSON.parse(toolCall.function.arguments);
          const searchResults = await searchWeb(args.query);
          console.log("✅ Web search completed successfully");

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: searchResults,
          });
          console.log("📤 Added search results to tool outputs");
        } catch (error) {
          console.error(
            "❌ Error in handleToolCallsBrainstorm for search_web:",
            error
          );
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break; // Add this missing break statement

      default:
        console.log(`⚠️ Unknown tool function: ${toolCall.function.name}`);
        console.log(`�� Tool call details:`, JSON.stringify(toolCall, null, 2));
        toolOutputs.push({
          tool_call_id: toolCall.id,
          output: JSON.stringify({
            error: `Unknown tool function: ${toolCall.function.name}`,
          }),
        });
    }
  }

  console.log(`�� Total tool outputs prepared: ${toolOutputs.length}`);
  return toolOutputs;
}

// Enhanced searchWeb function with comprehensive logging
async function searchWeb(query) {
  console.log(`🔍 [searchWeb] Starting web search for query: "${query}"`);

  try {
    console.log(`�� [searchWeb] Making request to Serper API...`);
    console.log(
      `🔑 [searchWeb] Using API key: ${
        process.env.SERPER_API_KEY ? "Present" : "Missing"
      }`
    );

    const startTime = Date.now();
    const response = await axios.post(
      "https://google.serper.dev/search",
      {
        q: query,
      },
      {
        headers: {
          "X-API-KEY": process.env.SERPER_API_KEY,
          "Content-Type": "application/json",
        },
      }
    );
    const endTime = Date.now();

    console.log(
      `✅ [searchWeb] API request successful in ${endTime - startTime}ms`
    );
    console.log(`📊 [searchWeb] Response status: ${response.status}`);
    console.log(
      `📄 [searchWeb] Response data keys:`,
      Object.keys(response.data)
    );

    if (response.data.organic) {
      console.log(
        `🔍 [searchWeb] Found ${response.data.organic.length} organic results`
      );

      // Extract and format the search results
      const results = response.data.organic.slice(0, 3).map((result, index) => {
        console.log(`📝 [searchWeb] Processing result ${index + 1}:`, {
          title: result.title?.substring(0, 50) + "...",
          snippet: result.snippet?.substring(0, 100) + "...",
          link: result.link,
        });

        return {
          title: result.title,
          snippet: result.snippet,
          link: result.link,
        };
      });

      const jsonResults = JSON.stringify(results);
      console.log(`✅ [searchWeb] Search completed successfully`);
      console.log(
        `📊 [searchWeb] Final results length: ${jsonResults.length} characters`
      );
      console.log(`�� [searchWeb] Number of results: ${results.length}`);

      return jsonResults;
    } else {
      console.log(`⚠️ [searchWeb] No organic results found in response`);
      console.log(
        `📄 [searchWeb] Full response structure:`,
        JSON.stringify(response.data, null, 2)
      );
      return JSON.stringify({ error: "No search results found" });
    }
  } catch (error) {
    console.error("❌ [searchWeb] Error searching the web:", {
      name: error.name,
      message: error.message,
      code: error.code,
      response: error.response?.data,
      status: error.response?.status,
    });

    if (error.response) {
      console.error(`🚫 [searchWeb] API Error Response:`, {
        status: error.response.status,
        statusText: error.response.statusText,
        data: error.response.data,
      });
    }

    return JSON.stringify({
      error: "Failed to search the web",
      details: error.message,
      code: error.code,
    });
  }
}
// Prompt Brainstorm API - creates or retrieves thread and saves to database
app.post("/api/prompt-brainstorm/", async (req, res) => {
  try {
    const userInput = req.query.message;
    const email = req.query.email;
    const { currentPrompt } = req.body;

    // Log only relevant data
    console.log("Prompt Brainstorm Request:", {
      userInput,
      email,
      currentPrompt,
    });

    let threadID;
    const contactData = await getContactDataFromDatabaseByEmail(email);

    if (contactData?.thread_id) {
      threadID = contactData.thread_id;
      console.log("Using existing thread ID:", threadID);
    } else {
      const thread = await createThread();
      threadID = thread.id;
      console.log("Created new thread ID:", threadID);
      await saveThreadIDPostgres(email, threadID);
      console.log("Saved new thread ID to database for email:", email);
    }

    // Create the full prompt for the assistant
    const fullPrompt = `You are a prompt engineering expert. 
The user wants to modify or create a new AI assistant prompt.

Your task: Provide the EXACT text that should be added or created for their prompt. 
Be direct and specific.

Response format:
[CHANGES_START]
EXACT text to add or use as the new prompt. Copy-paste ready content.
[CHANGES_END]

[EXPLANATION_START]
Brief explanation of what this addition or new prompt does.
[EXPLANATION_END]

Rules:
- NO general suggestions or questions
- NO "consider this" or "think about that" language
- Provide ONLY the specific text to insert or replace
- If adding a new section, include the complete section with proper formatting
- If creating a new assistant, generate the full structured prompt including:

  1. *Conversation Flow* with stages. 
     - Each stage must be named clearly, e.g. “Stage 1: Greeting.
     - Provide ready-to-use *scripts* for each stage, not just instructions.
     - Always start your questions with a double straight line '||'
     - Use *bold* for important keywords (single * at start and end, e.g. *Invoke*)
     - Combine short sentences with longer sentences for variety
     - Always end acknowledgement or answers with '||' followed by a lowercase question
  2. *Conversational Style*:
     - Acknowledge responses first
     - Always start your questions with a double straight line '||'
     - Always start your questions with a double straight line '||'
     - Use *bold* for important keywords (single * at start and end, e.g. *Invoke*)
     - Combine short sentences with longer sentences for variety
     - Always end acknowledgement or answers with '||' followed by a lowercase question
  3. Language:
     - Always use the user's language
  4. *Calendar Management Rules*:
     - Never provide past dates
     - Only offer office hours (Mon–Fri, 9AM–6PM)
     - Verify availability using checkAvailableTimeSlots
     - Lock confirmed appointments using createCalendarEvent
  5. *Company Info Integration*: 
     - Auto-insert all company details provided by the user (overview, services, strengths, clients, testimonials, contact info, etc.)
     - Present company information in a structured way for pitching within the flow

Formatting rules:
- *After every double straight lines '||', start with lowercase letters (CRUCIAL)*
- *Bold Rules*: only one * at start and one * at end of each bold word
- Stages must have both a name and a ready script

${
  currentPrompt
    ? `Current Prompt:\n${currentPrompt}\n\nUser Request: ${userInput}\n\nCompany Info (from user): ${JSON.stringify(
        req.body.companyInfo || {},
        null,
        2
      )}\n\nProvide the EXACT text to add/change.`
    : `User Request: ${userInput}\n\nCompany Info (from user): ${JSON.stringify(
        req.body.companyInfo || {},
        null,
        2
      )}\n\nProvide the EXACT text for a NEW assistant prompt with named stages and scripts.`
}`;

    // Add user message to thread
    await addMessage(threadID, fullPrompt);

    // Create and run the assistant
    const assistantResponse = await openai.beta.threads.runs.create(threadID, {
      assistant_id: process.env.ASSISTANT_ID || "asst_QfkZ8GeCw0Rbc2zRW4B86FWD",
    });

    // Wait for the assistant to complete
    let runStatus;
    do {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      runStatus = await openai.beta.threads.runs.retrieve(
        threadID,
        assistantResponse.id
      );
    } while (runStatus.status !== "completed");

    // Retrieve the assistant's response
    const messages = await openai.beta.threads.messages.list(threadID);
    const answer = messages.data[0].content[0].text.value;

    // Save the interaction to the thread for future reference
    await addMessageAssistant(
      threadID,
      `Brainstorm Request: ${userInput}\nCurrent Prompt: ${
        currentPrompt || "None"
      }\nResponse: ${answer}`
    );

    // Send response
    res.json({
      success: true,
      data: {
        suggestions: answer,
        currentPrompt: currentPrompt || null,
        threadID: threadID, // Return thread ID for future use
      },
    });
  } catch (error) {
    console.error("Prompt brainstorm error:", {
      name: error.name,
      message: error.message,
      code: error.code,
    });
    res.status(500).json({
      success: false,
      error: error.code,
      details: error.message,
    });
  }
});

// Apply Changes AI - takes the brainstorming suggestions and applies them to create the modified prompt
app.post("/api/prompt-apply-changes/", async (req, res) => {
  try {
    const email = req.query.email;
    const { currentPrompt, changesToApply, brainstormContext } = req.body;

    // Log only relevant data
    console.log("Prompt Apply Changes Request:", {
      email,
      currentPrompt,
      changesToApply,
      brainstormContext,
    });

    let threadID;
    const contactData = await getContactDataFromDatabaseByEmail(email);

    if (contactData?.thread_id) {
      threadID = contactData.thread_id;
      console.log("Using existing thread ID:", threadID);
    } else {
      const thread = await createThread();
      threadID = thread.id;
      console.log("Created new thread ID:", threadID);
      await saveThreadIDPostgres(email, threadID);
      console.log("Saved new thread ID to database for email:", email);
    }

    // Create the full prompt for the assistant
    const fullPrompt = `As a prompt engineering expert, apply the specified changes to the current prompt. Your task is to implement the requested modifications precisely while maintaining the integrity of the original prompt.

Instructions:
- Return the COMPLETE prompt with all sections
- Apply ONLY the specific changes requested
- Keep all other sections exactly as they are, word for word
- Do not omit or summarize any sections
- Do not add [AI's primary function] style placeholders to unchanged sections
- Preserve all formatting, line breaks and structure

Your response must be structured in two clearly separated parts using these exact markers:
[ANALYSIS_START]
Briefly explain what specific changes you applied and why
[ANALYSIS_END]

[PROMPT_START]
${
  currentPrompt
    ? "The complete prompt with the applied changes:"
    : "Create a new prompt using this structure:"
}
${
  currentPrompt ||
  `#ROLE: [AI's primary function and identity]
#CONTEXT: [Business context and background]
#CAPABILITIES: [Specific tasks and functions]
#CONSTRAINTS: [Boundaries and limitations]
#COMMUNICATION STYLE: [Tone and interaction approach]
#WORKFLOW: [Process for handling requests]`
}
[PROMPT_END]

${
  currentPrompt
    ? `Current Prompt:\n${currentPrompt}\n\nChanges to Apply:\n${changesToApply}${
        brainstormContext
          ? `\n\nBrainstorming Context:\n${brainstormContext}`
          : ""
      }`
    : `Create a new prompt with these requirements:\n${changesToApply}${
        brainstormContext
          ? `\n\nBrainstorming Context:\n${brainstormContext}`
          : ""
      }`
}`;

    // Add user message to thread
    await addMessage(threadID, fullPrompt);

    // Create and run the assistant
    const assistantResponse = await openai.beta.threads.runs.create(threadID, {
      assistant_id: process.env.ASSISTANT_ID || "asst_1rBPyRoK6iW7UZftWqFIfI1u",
    });

    // Wait for the assistant to complete
    let runStatus;
    do {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      runStatus = await openai.beta.threads.runs.retrieve(
        threadID,
        assistantResponse.id
      );
    } while (runStatus.status !== "completed");

    // Retrieve the assistant's response
    const messages = await openai.beta.threads.messages.list(threadID);
    const answer = messages.data[0].content[0].text.value;

    // Parse the response to separate analysis and prompt
    const analysisMatch = answer.match(
      /\[ANALYSIS_START\]([\s\S]*?)\[ANALYSIS_END\]/
    );
    const promptMatch = answer.match(
      /\[PROMPT_START\]([\s\S]*?)\[PROMPT_END\]/
    );

    const analysis = analysisMatch ? analysisMatch[1].trim() : "";
    const updatedPrompt = promptMatch ? promptMatch[1].trim() : "";

    // Save the interaction to the thread for future reference
    await addMessageAssistant(
      threadID,
      `Apply Changes Request: ${changesToApply}\nCurrent Prompt: ${
        currentPrompt || "None"
      }\nBrainstorm Context: ${
        brainstormContext || "None"
      }\nResponse: ${answer}`
    );

    // Send structured response
    res.json({
      success: true,
      data: {
        analysis: analysis,
        updatedPrompt: updatedPrompt,
        originalPrompt: currentPrompt || null,
        threadID: threadID, // Return thread ID for future use
      },
    });
  } catch (error) {
    console.error("Prompt apply changes error:", {
      name: error.name,
      message: error.message,
      code: error.code,
    });
    res.status(500).json({
      success: false,
      error: error.code,
      details: error.message,
    });
  }
});

// ... existing code ...
app.get("/api/lalamove/quote", async (req, res) => {
  res.header("Access-Control-Allow-Origin", "https://storeguru.com.my");
  res.header(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, PATCH, DELETE, OPTIONS"
  );
  res.header(
    "Access-Control-Allow-Headers",
    "Content-Type, Authorization, Accept"
  );
  try {
    // Get parameters from request
    const {
      user_latitude,
      user_longitude,
      pickup_street,
      pickup_city,
      pickup_state,
      pickup_postcode,
      store_location,
      vehicle_type,
      manpower = "false", // New parameter, defaults to false
    } = req.query;

    // Map vehicle types to Lalamove service types
    const vehicleServiceMap = {
      van: "VAN",
      "1ton": "TRUCK330",
      "3ton": "TRUCK550",
      "5ton": "TRUCK550",
    };
    console.log(vehicle_type);
    // Validate vehicle type
    const serviceType = vehicleServiceMap[vehicle_type?.toLowerCase()];
    if (!serviceType) {
      console.log("Invalid vehicle type:", vehicle_type);
      throw new Error("Invalid vehicle type");
    }

    // Determine special requests based on services selected
    const specialRequests = [];

    // Add appropriate manpower service
    const isManpower = manpower === "true";
    if (isManpower) {
      if (serviceType === "TRUCK330" || serviceType === "TRUCK550") {
        // For trucks, manpower includes driver + 2 helpers
        specialRequests.push("DOOR_TO_DOOR_1DRIVER2HELPER");
        if (pickup_city.toLowerCase().includes("kuala lumpur")) {
          specialRequests.push("HOUSE_MOVING");
        }
      } else {
        // For vans, manpower includes driver + helper
        specialRequests.push("DOOR_TO_DOOR_1DRIVER1HELPER");
      }
    }

    // Add tailboard for all truck types
    if (serviceType === "TRUCK330" || serviceType === "TRUCK550") {
      specialRequests.push("TAILBOARD_VEHICLE");
    }

    // Validate required parameters
    if (!user_latitude || !user_longitude || !pickup_street) {
      console.log("Missing required parameters");
      throw new Error("Missing required parameters");
    }

    // Validate coordinate format
    const lat = parseFloat(user_latitude);
    const lng = parseFloat(user_longitude);
    if (isNaN(lat) || isNaN(lng)) {
      console.log("Invalid coordinates format");
      throw new Error("Invalid coordinates format");
    }

    // Store location coordinates mapping
    const storeCoordinates = {
      sentul: { lat: "3.173640", lng: "101.692897" },
      subang: { lat: "3.157191", lng: "101.544504" },
      nilai: { lat: "2.848007", lng: "101.805015" },
      gelang_patah: { lat: "1.371682", lng: "103.57636" },
      bayan_lepas: { lat: "5.315488", lng: "100.266468" },
      kuantan: { lat: "3.840118", lng: "103.289275" },
    };

    if (!storeCoordinates[store_location]) {
      console.log("Invalid store location:", store_location);
      throw new Error("Invalid store location");
    }
    const destinationCoords = storeCoordinates[store_location];

    // Lalamove API credentials
    const API_KEY = "pk_test_293d571c2c2d519583326617750761e8";
    const SECRET =
      "sk_test_On8eL9w6N7hJBweWocmozS/KBWr9FBOsuAJsDWG2xeINEzMTo55mst2h2qEQas4u";
    const LALAMOVE_BASE_URL = "https://rest.sandbox.lalamove.com";

    const time = new Date().getTime().toString();
    const method = "POST";
    const path = "/v3/quotations";

    const requestBody = {
      data: {
        serviceType: serviceType,
        specialRequests: specialRequests,
        language: "en_MY",
        stops: [
          {
            coordinates: {
              lat: lat.toString(),
              lng: lng.toString(),
            },
            address: `${pickup_street}, ${pickup_city}, ${pickup_state} ${pickup_postcode}, Malaysia`,
          },
          {
            coordinates: {
              lat: destinationCoords.lat,
              lng: destinationCoords.lng,
            },
            address: `${
              store_location.charAt(0).toUpperCase() + store_location.slice(1)
            } Storage Facility, Malaysia`,
          },
        ],
      },
    };

    console.log("Request Configuration:");
    console.log("- Vehicle Type:", vehicle_type);
    if (serviceType === "TRUCK330" || serviceType === "TRUCK550") {
      console.log(
        "- Manpower:",
        isManpower ? "Driver + 2 Helpers" : "Driver Only"
      );
    } else {
      console.log(
        "- Manpower:",
        isManpower ? "Driver + Helper" : "No Manpower"
      );
    }
    console.log("- Special Requests Applied:", specialRequests);
    console.log("\nRequest body:", JSON.stringify(requestBody, null, 2));

    const rawSignature = `${time}\r\n${method}\r\n${path}\r\n\r\n${JSON.stringify(
      requestBody
    )}`;
    const signature = CryptoJS.HmacSHA256(rawSignature, SECRET).toString();

    console.log("Making request to Lalamove API...");
    const response = await axios.post(
      `${LALAMOVE_BASE_URL}${path}`,
      requestBody,
      {
        headers: {
          "Content-Type": "application/json; charset=utf-8",
          Authorization: `hmac ${API_KEY}:${time}:${signature}`,
          Accept: "application/json",
          Market: "MY",
        },
      }
    );

    console.log("Lalamove API response:", response.data);

    res.json({
      success: true,
      data: {
        totalFee: {
          amount: response.data.data.priceBreakdown.total,
          currency: "MYR",
        },
      },
    });
  } catch (error) {
    console.error("Lalamove API Error:", error);
    if (error.response) {
      console.error("Error response data:", error.response.data);
    }
    res.json({
      success: true,
      data: {
        totalFee: {
          amount: "0.00",
          currency: "MYR",
        },
      },
    });
  }
});

app.get("/api/sessions", async (req, res) => {
  try {
    const authPath = path.join(__dirname, ".wwebjs_auth");
    const sessions = await fs.promises.readdir(authPath);
    const sessionNames = sessions
      .filter((name) => name.startsWith("session-"))
      .map((name) => name.replace("session-", ""));
    res.json(sessionNames);
  } catch (error) {
    console.error("Error reading sessions:", error);
    res.status(500).json({ error: "Failed to read sessions" });
  }
});

function broadcastProgress(botName, action, progress, phoneIndex) {
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN && client.companyId === botName) {
      client.send(
        JSON.stringify({
          type: "progress",
          botName,
          action,
          progress,
          phoneIndex,
        })
      );
    }
  });
}

const botStatusMap = new Map();
function broadcastAuthStatus(botName, status, qrCode = null, i = 0) {
  wss.clients.forEach((client) => {
    try {
      if (client.readyState === WebSocket.OPEN) {
        if (client.pathname === "/status") {
          const message = JSON.stringify({
            type: "status_update",
            botName,
            status,
            qrCode: status === "qr" ? qrCode : null,
            phoneIndex: i,
          });
          client.send(message);
        } else if (client.companyId === botName) {
          const message = JSON.stringify({
            type: "auth_status",
            botName,
            status,
            qrCode: status === "qr" ? qrCode : null,
            phoneIndex: i,
          });
          client.send(message);
        }
      }
    } catch (error) {
      console.error("Error sending to client:", error);
    }
  });
  botStatusMap.set(botName, status);
}

app.post("/api/daily-report/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const { enabled, time, groupId } = req.body;

  try {
    if (enabled) {
      if (!time || !groupId) {
        return res.status(400).json({
          success: false,
          error: "Time and groupId are required when enabling reports",
        });
      }

      const settingValue = {
        enabled: true,
        time,
        groupId,
        lastRun: null,
      };

      const checkQuery = `
        SELECT id FROM public.settings 
        WHERE company_id = $1 AND setting_type = 'reporting' AND setting_key = 'dailyReport'
      `;
      const checkResult = await sqlDb.query(checkQuery, [companyId]);

      if (checkResult.rows.length > 0) {
        const updateQuery = `
          UPDATE public.settings 
          SET setting_value = $1, updated_at = CURRENT_TIMESTAMP
          WHERE company_id = $2 AND setting_type = 'reporting' AND setting_key = 'dailyReport'
        `;
        await sqlDb.query(updateQuery, [
          JSON.stringify(settingValue),
          companyId,
        ]);
      } else {
        const insertQuery = `
          INSERT INTO public.settings (company_id, setting_type, setting_key, setting_value, created_at, updated_at)
          VALUES ($1, 'reporting', 'dailyReport', $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
        `;
        await sqlDb.query(insertQuery, [
          companyId,
          JSON.stringify(settingValue),
        ]);
      }

      if (dailyReportCrons.has(companyId)) {
        dailyReportCrons.get(companyId).stop();
      }

      const [hour, minute] = time.split(":");
      const cronJob = cron.schedule(
        `${minute} ${hour} * * *`,
        async () => {
          try {
            const botData = botMap.get(companyId);
            if (!botData || !botData[0]?.client) {
              console.error(
                `No WhatsApp client found for company ${companyId}`
              );
              return;
            }

            const count = await countTodayLeads(companyId);
            const message = `📊 Daily Lead Report\n\nNew Leads Today: ${count}\nDate: ${new Date().toLocaleDateString()}`;

            await botData[0].client.sendMessage(groupId, message);

            const updateLastRunQuery = `
            UPDATE public.settings 
            SET setting_value = jsonb_set(setting_value, '{lastRun}', to_jsonb($1::text), true),
                updated_at = CURRENT_TIMESTAMP
            WHERE company_id = $2 AND setting_type = 'reporting' AND setting_key = 'dailyReport'
          `;
            await sqlDb.query(updateLastRunQuery, [
              new Date().toISOString(),
              companyId,
            ]);
          } catch (error) {
            console.error(
              `Error sending daily report for company ${companyId}:`,
              error
            );
          }
        },
        {
          timezone: "Asia/Kuala_Lumpur",
        }
      );

      dailyReportCrons.set(companyId, cronJob);

      res.json({
        success: true,
        message: "Daily report enabled",
        nextRun: `${hour}:${minute}`,
      });
    } else {
      if (dailyReportCrons.has(companyId)) {
        dailyReportCrons.get(companyId).stop();
        dailyReportCrons.delete(companyId);
      }

      const settingValue = {
        enabled: false,
        time: null,
        groupId: null,
      };

      const updateQuery = `
        UPDATE public.settings 
        SET setting_value = $1, updated_at = CURRENT_TIMESTAMP
        WHERE company_id = $2 AND setting_type = 'reporting' AND setting_key = 'dailyReport'
      `;

      await sqlDb.query(updateQuery, [JSON.stringify(settingValue), companyId]);

      res.json({
        success: true,
        message: "Daily report disabled",
      });
    }
  } catch (error) {
    console.error("Error managing daily report:", error);
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

async function countTodayLeads(companyId) {
  try {
    const today = moment()
      .tz("Asia/Kuala_Lumpur")
      .startOf("day")
      .format("YYYY-MM-DD HH:mm:ss");

    const query = `
      SELECT COUNT(*) as count 
      FROM public.contacts 
      WHERE company_id = $1 AND created_at >= $2
    `;

    const result = await sqlDb.query(query, [companyId, today]);
    return parseInt(result.rows[0].count, 10);
  } catch (error) {
    console.error("Error counting leads:", error);
    return 0;
  }
}

app.post("/api/daily-report/:companyId/trigger", async (req, res) => {
  const { companyId } = req.params;
  const { date } = req.body; // Optional date parameter in YYYY-MM-DD format
  const sqlClient = await pool.connect();

  try {
    // Validate date format if provided
    if (date && !moment(date, "YYYY-MM-DD", true).isValid()) {
      return res.status(400).json({
        success: false,
        error:
          "Invalid date format. Please use YYYY-MM-DD format (e.g., 2025-10-15)",
      });
    }

    // Check if this company should be handled by this server instance
    const companyQuery = `
      SELECT api_url
      FROM public.companies
      WHERE company_id = $1
    `;

    const companyResult = await sqlClient.query(companyQuery, [companyId]);

    if (companyResult.rows.length === 0) {
      return res.status(400).json({
        success: false,
        error: "Company not found",
      });
    }

    const apiUrl = companyResult.rows[0].api_url;

    const settingsQuery = `
      SELECT setting_value
      FROM public.settings
      WHERE company_id = $1
      AND setting_type = 'reporting'
      AND setting_key = 'dailyReport'
    `;

    const settingsResult = await sqlClient.query(settingsQuery, [companyId]);

    if (settingsResult.rows.length === 0) {
      return res.status(400).json({
        success: false,
        error: "Daily reporting is not configured for this company",
      });
    }

    const settings = settingsResult.rows[0].setting_value;

    if (!settings || !settings.enabled) {
      return res.status(400).json({
        success: false,
        error: "Daily reporting is not enabled for this company",
      });
    }

    const botData = botMap.get(companyId);

    if (!botData || !botData[0]?.client) {
      return res.status(400).json({
        success: false,
        error: "WhatsApp client not found",
      });
    }

    // Use the same function as the scheduled report, with optional date
    await sendDailyContactReport(botData[0].client, companyId, date);

    // Update lastRun timestamp only if no date was specified (current day report)
    if (!date) {
      await sqlClient.query("BEGIN");
      const updateQuery = `
        UPDATE public.settings
        SET setting_value = jsonb_set(setting_value, '{lastRun}', to_jsonb($1::text))
        WHERE company_id = $2
        AND setting_type = 'reporting'
        AND setting_key = 'dailyReport'
      `;

      await sqlClient.query(updateQuery, [
        moment().tz("Asia/Kuala_Lumpur").toISOString(),
        companyId,
      ]);
      await sqlClient.query("COMMIT");
    }

    // Get the count for the response
    const { count } = await getContactsAddedToday(companyId, date);

    const reportDate =
      date || moment().tz("Asia/Kuala_Lumpur").format("YYYY-MM-DD");

    res.json({
      success: true,
      message: `Report triggered successfully for ${reportDate}`,
      date: reportDate,
      count,
    });
  } catch (error) {
    await sqlClient.query("ROLLBACK");
    console.error("Error triggering daily report:", error);
    res.status(500).json({
      success: false,
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
  }
});

// Manual trigger endpoint for weekly summary report
app.post("/api/weekly-report/:companyId/trigger", async (req, res) => {
  const { companyId } = req.params;

  try {
    console.log(`[Weekly Report] Manual trigger requested for ${companyId}`);

    // Get bot client
    const botData = botMap.get(companyId);
    if (!botData || !botData[0]?.client) {
      return res.status(404).json({
        success: false,
        error: "WhatsApp client not found for this company",
      });
    }

    // Send the weekly report
    const result = await sendWeeklySummaryReport(botData[0].client, companyId);

    res.json({
      success: true,
      message: `Weekly report triggered successfully for ${companyId}`,
      result,
    });
  } catch (error) {
    console.error(
      `[Weekly Report] Error in manual trigger for ${companyId}:`,
      error
    );
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

// Manual trigger endpoint for health report
app.post("/api/health-report/trigger", async (req, res) => {
  try {
    console.log("[Health Report] Manual trigger requested");

    // Send the health report
    await sendHealthReportToGroup();

    res.json({
      success: true,
      message: "Health report triggered and sent successfully",
    });
  } catch (error) {
    console.error("[Health Report] Error in manual trigger:", error);
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
});

app.get("/api/facebook-lead-webhook", (req, res) => {
  const VERIFY_TOKEN = "test"; // Use the token you entered in the Facebook dashboard

  const mode = req.query["hub.mode"];
  const token = req.query["hub.verify_token"];
  const challenge = req.query["hub.challenge"];

  console.log(
    `Webhook verification attempt: mode=${mode}, token=${token}, challenge=${challenge}`
  );

  if (mode && token) {
    if (mode === "subscribe" && token === VERIFY_TOKEN) {
      console.log("Webhook verified successfully");
      res.status(200).send(challenge);
    } else {
      console.log(
        `Webhook verification failed: expected token '${VERIFY_TOKEN}', got '${token}'`
      );
      res.sendStatus(403);
    }
  } else {
    console.log("Webhook verification failed: missing mode or token");
    res.sendStatus(404);
  }
});

// Facebook Lead Form Webhook Handler - POST
app.post("/api/facebook-lead-webhook", async (req, res) => {
  try {
    console.log(
      "Facebook Lead Webhook received:",
      JSON.stringify(req.body, null, 2)
    );

    const body = req.body;

    // Verify this is a page subscription
    if (body.object === "page") {
      // Process each entry
      for (const entry of body.entry) {
        const changes = entry.changes || [];

        for (const change of changes) {
          if (change.field === "leadgen") {
            const leadgenData = change.value;
            const leadId = leadgenData.leadgen_id;
            const formId = leadgenData.form_id;
            const pageId = leadgenData.page_id;
            const adgroupId = leadgenData.adgroup_id;
            const campaignId = leadgenData.campaign_id;

            console.log(
              `New lead received: Lead ID: ${leadId}, Form ID: ${formId}`
            );

            // Skip processing if this is test data from Facebook webhook testing
            if (leadId === "444444444444" || formId === "444444444444") {
              console.log("Skipping test webhook data");
              continue;
            }

            try {
              // Get lead details from Facebook API
              const leadDetails = await getLeadDetails(leadId);

              if (leadDetails && leadDetails.phone) {
                // Extract phone number and name
                const phoneNumber = leadDetails.phone;
                const name = leadDetails.name || "New Lead";

                console.log(
                  `Lead details parsed - Name: ${name}, Phone: ${phoneNumber}`
                );

                // Format phone for WhatsApp
                const formattedPhone = formatPhoneForWhatsApp(phoneNumber);
                console.log(`Formatted phone number = ${formattedPhone}`);

                // Get company mapping based on form ID or page ID
                const companyId = await getCompanyIdForLead(formId, pageId);
                console.log(
                  `Company ID found for form ${formId}/page ${pageId}: ${companyId}`
                );

                if (companyId) {
                  // Check if company ID is in UUID format, if not, try to find the actual UUID
                  const uuidRegex =
                    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
                  let actualCompanyId = companyId;

                  if (!uuidRegex.test(companyId)) {
                    console.log(
                      `Company ID ${companyId} is not UUID format, looking up actual company UUID...`
                    );

                    // Try to find the actual company UUID by looking up the company with this identifier
                    try {
                      const companyLookup = await pool.query(
                        "SELECT id FROM companies WHERE company_id = $1 OR name = $1 OR id::text = $1 LIMIT 1",
                        [companyId]
                      );

                      if (companyLookup.rows.length > 0) {
                        actualCompanyId = companyLookup.rows[0].id;
                        console.log(
                          `Found actual company UUID: ${actualCompanyId} for identifier: ${companyId}`
                        );
                      } else {
                        console.error(
                          `Could not find company UUID for identifier: ${companyId}`
                        );
                        throw new Error(
                          `Could not find company UUID for identifier: ${companyId}`
                        );
                      }
                    } catch (lookupError) {
                      console.error(
                        `Error looking up company UUID for ${companyId}:`,
                        lookupError
                      );
                      throw new Error(
                        `Error looking up company UUID for ${companyId}: ${lookupError.message}`
                      );
                    }
                  }

                  // Get company-specific welcome message (use UUID for database)
                  const welcomeMessage = await getWelcomeMessageForCompany(
                    actualCompanyId,
                    name
                  );

                  // Send message using existing v2/messages/text API (use original ID for WhatsApp bot)
                  const messageResponse = await axios.post(
                    `http://localhost:${port}/api/v2/messages/text/${companyId}/${encodeURIComponent(
                      formattedPhone
                    )}`,
                    {
                      message: welcomeMessage,
                      phoneIndex: 0,
                    }
                  );

                  console.log(
                    `Message sent to lead ${leadId} for company ${companyId} (UUID: ${actualCompanyId}):`,
                    messageResponse.status
                  );

                  // Store lead in database
                  await storeLeadInDatabase(
                    leadDetails,
                    formId,
                    pageId,
                    campaignId,
                    adgroupId,
                    companyId
                  );
                } else {
                  console.log(
                    `No company mapping found for form ${formId} or page ${pageId}`
                  );
                }
              } else {
                console.log(`No phone number found for lead ${leadId}`);
                if (leadDetails) {
                  console.log(
                    "Lead details received but no valid phone:",
                    JSON.stringify(leadDetails, null, 2)
                  );
                } else {
                  console.log("No lead details received from Facebook API");
                }
              }
            } catch (error) {
              console.error(`Error processing lead ${leadId}:`, error);
            }
          }
        }
      }

      res.status(200).send("EVENT_RECEIVED");
    } else {
      res.sendStatus(404);
    }
  } catch (error) {
    console.error("Facebook webhook error:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Helper function to get lead details from Facebook API
async function getLeadDetails(leadId) {
  try {
    const accessToken = process.env.FACEBOOK_ACCESS_TOKEN;

    if (!accessToken) {
      console.error("Facebook access token not found in environment variables");
      return null;
    }

    console.log(
      "Using Facebook access token:",
      accessToken.substring(0, 10) + "..."
    );

    const response = await axios.get(
      `https://graph.facebook.com/v18.0/${leadId}?fields=id,created_time,field_data&access_token=${accessToken}`
    );

    const leadData = response.data;
    console.log(
      "Raw lead data from Facebook:",
      JSON.stringify(leadData, null, 2)
    );

    const fieldData = leadData.field_data || [];
    console.log("Field data extracted:", JSON.stringify(fieldData, null, 2));

    // Extract common field names
    const phoneField = fieldData.find(
      (field) =>
        field.name &&
        (field.name.toLowerCase().includes("phone") ||
          field.name.toLowerCase().includes("mobile") ||
          field.name.toLowerCase().includes("contact"))
    );

    const nameField = fieldData.find(
      (field) =>
        field.name &&
        (field.name.toLowerCase().includes("name") ||
          field.name.toLowerCase().includes("full_name") ||
          field.name.toLowerCase().includes("first_name"))
    );

    const emailField = fieldData.find(
      (field) => field.name && field.name.toLowerCase().includes("email")
    );

    return {
      id: leadData.id,
      created_time: leadData.created_time,
      phone: phoneField && phoneField.values ? phoneField.values[0] : null,
      name: nameField && nameField.values ? nameField.values[0] : null,
      email: emailField && emailField.values ? emailField.values[0] : null,
      raw_data: fieldData,
    };
  } catch (error) {
    console.error("Error fetching lead details from Facebook:", error);

    // Check if it's a token error
    if (error.response && error.response.data && error.response.data.error) {
      const fbError = error.response.data.error;
      if (fbError.code === 190 || fbError.message.includes("access token")) {
        console.error(
          "Facebook access token is invalid or expired:",
          fbError.message
        );
        // You could implement token refresh logic here
      }
    }

    return null;
  }
}

// Facebook Access Token Validation Endpoint
app.get("/api/facebook-token-status", async (req, res) => {
  try {
    const accessToken = process.env.FACEBOOK_ACCESS_TOKEN;

    if (!accessToken) {
      return res.status(400).json({
        success: false,
        error: "Facebook access token not configured",
      });
    }

    // Test the token by making a simple API call
    const response = await axios.get(
      `https://graph.facebook.com/v18.0/me?access_token=${accessToken}`
    );

    res.json({
      success: true,
      message: "Facebook access token is valid",
      user: response.data,
    });
  } catch (error) {
    console.error("Facebook token validation error:", error);

    let errorMessage = "Unknown error";
    if (error.response && error.response.data && error.response.data.error) {
      const fbError = error.response.data.error;
      errorMessage = fbError.message;
    }

    res.status(400).json({
      success: false,
      error: errorMessage,
      details: error.response?.data,
    });
  }
});

// Facebook Form Mappings API Endpoints
app.get("/api/facebook-form-mappings", async (req, res) => {
  try {
    const { company_id } = req.query;

    if (!company_id) {
      return res.status(400).json({ error: "company_id is required" });
    }

    const query = `
      SELECT id, company_id, form_id, form_name, page_id, page_name, 
             welcome_message, is_active, created_at, updated_at
      FROM facebook_form_mappings 
      WHERE company_id = $1
      ORDER BY created_at DESC
    `;

    const result = await pool.query(query, [company_id]);
    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching Facebook form mappings:", error);
    res.status(500).json({ error: "Failed to fetch form mappings" });
  }
});

app.post("/api/facebook-form-mappings", async (req, res) => {
  try {
    const {
      company_id,
      form_id,
      form_name,
      page_id,
      page_name,
      welcome_message,
    } = req.body;

    const query = `
      INSERT INTO facebook_form_mappings 
      (company_id, form_id, form_name, page_id, page_name, welcome_message)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING *
    `;

    const result = await pool.query(query, [
      company_id,
      form_id,
      form_name,
      page_id,
      page_name,
      welcome_message,
    ]);

    res.json({
      success: true,
      mapping: result.rows[0],
    });
  } catch (error) {
    console.error("Error creating Facebook form mapping:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create form mapping",
    });
  }
});
app.put("/api/facebook-form-mappings/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { form_name, page_name, welcome_message, is_active, company_id } =
      req.body;

    if (!company_id) {
      return res.status(400).json({
        success: false,
        error: "company_id is required",
      });
    }

    const query = `
      UPDATE facebook_form_mappings 
      SET form_name = $1, page_name = $2, welcome_message = $3, is_active = $4
      WHERE id = $5 AND company_id = $6
      RETURNING *
    `;

    const result = await pool.query(query, [
      form_name,
      page_name,
      welcome_message,
      is_active,
      id,
      company_id,
    ]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: "Form mapping not found or access denied",
      });
    }

    res.json({
      success: true,
      mapping: result.rows[0],
    });
  } catch (error) {
    console.error("Error updating Facebook form mapping:", error);
    res.status(500).json({
      success: false,
      error: "Failed to update form mapping",
    });
  }
});

app.delete("/api/facebook-form-mappings/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { company_id } = req.query;

    if (!company_id) {
      return res.status(400).json({
        success: false,
        error: "company_id is required",
      });
    }

    const query = `DELETE FROM facebook_form_mappings WHERE id = $1 AND company_id = $2`;
    const result = await pool.query(query, [id, company_id]);

    if (result.rowCount === 0) {
      return res.status(404).json({
        success: false,
        error: "Form mapping not found or access denied",
      });
    }

    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting Facebook form mapping:", error);
    res.status(500).json({
      success: false,
      error: "Failed to delete form mapping",
    });
  }
});

// Facebook Leads API Endpoints
app.get("/api/facebook-leads", async (req, res) => {
  try {
    const { company_id } = req.query;

    if (!company_id) {
      return res.status(400).json({ error: "company_id is required" });
    }

    const query = `
      SELECT fl.*, fm.form_name, fm.page_name
      FROM facebook_leads fl
      LEFT JOIN facebook_form_mappings fm ON fl.form_id = fm.form_id AND fl.company_id = fm.company_id
      WHERE fl.company_id = $1
      ORDER BY fl.created_at DESC
      LIMIT 100
    `;

    const result = await pool.query(query, [company_id]);
    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching Facebook leads:", error);
    res.status(500).json({ error: "Failed to fetch leads" });
  }
});

// Facebook Lead Analytics API
app.get("/api/facebook-lead-analytics", async (req, res) => {
  try {
    const { company_id } = req.query;

    if (!company_id) {
      return res.status(400).json({ error: "company_id is required" });
    }

    const query = `
      SELECT 
        fl.company_id,
        COALESCE(fm.form_name, 'Unknown Form') as form_name,
        COALESCE(fm.page_name, 'Unknown Page') as page_name,
        COUNT(fl.id) as total_leads,
        COUNT(CASE WHEN fl.message_sent = true THEN 1 END) as messages_sent,
        COUNT(CASE WHEN DATE(fl.created_at) = CURRENT_DATE THEN 1 END) as leads_today,
        COUNT(CASE WHEN fl.created_at >= DATE_TRUNC('week', CURRENT_DATE) THEN 1 END) as leads_this_week,
        COUNT(CASE WHEN fl.created_at >= DATE_TRUNC('month', CURRENT_DATE) THEN 1 END) as leads_this_month,
        CASE 
          WHEN COUNT(fl.id) > 0 THEN 
            ROUND((COUNT(CASE WHEN fl.message_sent = true THEN 1 END)::DECIMAL / COUNT(fl.id)) * 100, 2)
          ELSE 0 
        END as message_success_rate
      FROM facebook_leads fl
      LEFT JOIN facebook_form_mappings fm ON fl.form_id = fm.form_id AND fl.company_id = fm.company_id
      WHERE fl.company_id = $1
      GROUP BY fl.company_id, COALESCE(fm.form_name, 'Unknown Form'), COALESCE(fm.page_name, 'Unknown Page')
      ORDER BY total_leads DESC
    `;

    const result = await pool.query(query, [company_id]);

    // If no leads found, return empty analytics with company info
    if (result.rows.length === 0) {
      const emptyAnalytics = {
        company_id: company_id,
        form_name: "No Data",
        page_name: "No Data",
        total_leads: 0,
        messages_sent: 0,
        leads_today: 0,
        leads_this_week: 0,
        leads_this_month: 0,
        message_success_rate: 0,
      };
      return res.json([emptyAnalytics]);
    }

    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching Facebook lead analytics:", error);
    res.status(500).json({ error: "Failed to fetch analytics" });
  }
});

// Helper function to get company ID based on form or page
async function getCompanyIdForLead(formId, pageId) {
  try {
    // First try to find by form ID
    let query = `
      SELECT company_id FROM facebook_form_mappings 
      WHERE form_id = $1 AND is_active = true
      LIMIT 1
    `;

    let result = await pool.query(query, [formId]);

    if (result.rows.length > 0) {
      return result.rows[0].company_id;
    }

    // Fallback to page ID
    query = `
      SELECT company_id FROM facebook_page_mappings 
      WHERE page_id = $1 AND is_active = true
      LIMIT 1
    `;

    result = await pool.query(query, [pageId]);

    if (result.rows.length > 0) {
      return result.rows[0].company_id;
    }

    // Default fallback - use first active company
    query = `SELECT id FROM companies WHERE is_active = true ORDER BY id LIMIT 1`;
    result = await pool.query(query);

    return result.rows.length > 0 ? result.rows[0].id : "1";
  } catch (error) {
    console.error("Error getting company ID for lead:", error);
    return "1"; // Default fallback
  }
}

// Helper function to get welcome message for company
async function getWelcomeMessageForCompany(companyId, leadName) {
  try {
    const query = `
      SELECT facebook_welcome_message FROM companies 
      WHERE id = $1
    `;

    const result = await pool.query(query, [companyId]);

    if (result.rows.length > 0 && result.rows[0].facebook_welcome_message) {
      // Replace placeholders with actual values
      return result.rows[0].facebook_welcome_message
        .replace(/\{name\}/g, leadName)
        .replace(/\{lead_name\}/g, leadName);
    }

    // Default message
    return `Hi ${leadName}! 👋\n\nThank you for your interest in our services. We've received your information and will get back to you shortly.\n\nA member of our team will contact you soon to discuss how we can help you.`;
  } catch (error) {
    console.error("Error getting welcome message:", error);
    // Return default message
    return `Hi ${leadName}! 👋\n\nThank you for your interest in our services. We've received your information and will get back to you shortly.`;
  }
}
async function processLead(
  leadData,
  formId,
  pageId,
  adId,
  adGroupId,
  companyId,
  welcomeMessage
) {
  try {
    // Extract phone number and name from field_data
    let phone = null;
    let name = null;
    let email = null;

    if (leadData.field_data) {
      for (const field of leadData.field_data) {
        if (field.name === "phone_number" || field.name === "phone") {
          phone = field.values[0];
        } else if (field.name === "full_name" || field.name === "name") {
          name = field.values[0];
        } else if (field.name === "email" || field.name === "email_address") {
          email = field.values[0];
        }
      }
    }

    if (!phone) {
      console.log(`No phone number found for lead ${leadData.id}`);
      return;
    }

    // Format phone number for WhatsApp
    const formattedPhone = formatPhoneForWhatsApp(phone);

    // Store lead in database
    const result = await pool.query(
      "INSERT INTO facebook_leads (facebook_lead_id, form_id, page_id, campaign_id, adgroup_id, company_id, phone, name, email, raw_data, message_sent, message_sent_at, message_status) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13) RETURNING *",
      [
        leadData.id,
        formId,
        pageId,
        adId,
        adGroupId,
        companyId,
        phone,
        name,
        email,
        JSON.stringify(leadData),
        false,
        null,
        "pending",
      ]
    );

    // Send WhatsApp message
    const message = welcomeMessage.replace("{{name}}", name || "there");

    try {
      const response = await axios.post(
        `http://localhost:8443/api/v2/messages/text/${companyId}/${formattedPhone}`,
        {
          message: message,
          phoneIndex: 0,
        }
      );

      // Update lead status
      await pool.query(
        "UPDATE facebook_leads SET message_sent = true, message_sent_at = NOW(), message_status = $1 WHERE id = $2",
        ["sent", result.rows[0].id]
      );

      console.log(`WhatsApp message sent successfully to ${formattedPhone}`);
    } catch (whatsappError) {
      console.error("Error sending WhatsApp message:", whatsappError);

      // Update lead status
      await pool.query(
        "UPDATE facebook_leads SET message_sent = false, message_status = $1 WHERE id = $2",
        ["failed", result.rows[0].id]
      );
    }
  } catch (error) {
    console.error("Error processing lead:", error);
  }
}
// Helper function to store lead in database
async function storeLeadInDatabase(
  leadDetails,
  formId,
  pageId,
  campaignId,
  adgroupId,
  companyId
) {
  try {
    console.log(
      `[DATABASE] Attempting to store lead ${leadDetails.id} for company ${companyId}`
    );
    console.log(`[DATABASE] Lead details:`, {
      id: leadDetails.id,
      phone: leadDetails.phone,
      name: leadDetails.name,
      email: leadDetails.email,
      formId,
      pageId,
      companyId,
    });

    const query = `
      INSERT INTO facebook_leads (
        facebook_lead_id, form_id, page_id, campaign_id, adgroup_id, company_id,
        phone, name, email, raw_data, message_status, created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW())
      ON CONFLICT (facebook_lead_id) DO UPDATE SET
        updated_at = NOW()
    `;

    const result = await pool.query(query, [
      leadDetails.id,
      formId,
      pageId,
      campaignId,
      adgroupId,
      companyId,
      leadDetails.phone,
      leadDetails.name,
      leadDetails.email,
      JSON.stringify(leadDetails.raw_data),
      "sent",
    ]);

    console.log(
      `✅ Lead ${leadDetails.id} stored in database for company ${companyId}`
    );
    console.log(`[DATABASE] Insert result:`, result.rows[0]);
  } catch (error) {
    console.error("❌ Error storing lead in database:", error);
    console.error("❌ Error details:", {
      message: error.message,
      code: error.code,
      detail: error.detail,
      constraint: error.constraint,
    });
  }
}

app.put("/api/update-user", async (req, res) => {
  try {
    const {
      contactId, // email of user to update
      name,
      phoneNumber,
      email,
      password,
      role,
      companyId,
      group,
      employeeId,
      notes,
      quotaLeads,
      invoiceNumber,
      imageUrl,
      viewEmployees,
      phoneAccess,
      weightages,
    } = req.body;

    if (!contactId) {
      return res.status(400).json({ error: "Contact ID (email) is required" });
    }

    // Start transaction
    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      // Update users table - only update if values are provided
      const userUpdateFields = [];
      const userUpdateValues = [];
      let paramIndex = 1;

      if (name) {
        userUpdateFields.push(`name = $${paramIndex++}`);
        userUpdateValues.push(name);
      }
      if (role) {
        userUpdateFields.push(`role = $${paramIndex++}`);
        userUpdateValues.push(role);
      }
      if (password) {
        userUpdateFields.push(`password = $${paramIndex++}`);
        userUpdateValues.push(password);
      }

      if (userUpdateFields.length > 0) {
        userUpdateFields.push(`last_updated = CURRENT_TIMESTAMP`);
        userUpdateValues.push(contactId, companyId);

        const userUpdateQuery = `
          UPDATE users 
          SET ${userUpdateFields.join(", ")}
          WHERE email = $${paramIndex++} AND company_id = $${paramIndex++}
        `;

        await client.query(userUpdateQuery, userUpdateValues);
      }

      // Update or insert into employees table
      const employeeCheckQuery = `
        SELECT id FROM employees WHERE email = $1 AND company_id = $2
      `;
      const employeeCheck = await client.query(employeeCheckQuery, [
        contactId,
        companyId,
      ]);

      if (employeeCheck.rows.length > 0) {
        // Update existing employee
        const empUpdateFields = [];
        const empUpdateValues = [];
        let empParamIndex = 1;

        if (name) {
          empUpdateFields.push(`name = $${empParamIndex++}`);
          empUpdateValues.push(name);
        }
        if (role) {
          empUpdateFields.push(`role = $${empParamIndex++}`);
          empUpdateValues.push(role);
        }
        if (phoneNumber) {
          empUpdateFields.push(`phone_number = $${empParamIndex++}`);
          empUpdateValues.push(phoneNumber);
        }
        if (employeeId !== undefined) {
          empUpdateFields.push(`employee_id = $${empParamIndex++}`);
          empUpdateValues.push(employeeId);
        }
        if (phoneAccess !== undefined) {
          empUpdateFields.push(`phone_access = $${empParamIndex++}`);
          empUpdateValues.push(JSON.stringify(phoneAccess));
        }
        if (weightages !== undefined) {
          empUpdateFields.push(`weightages = $${empParamIndex++}`);
          empUpdateValues.push(JSON.stringify(weightages));
        }
        if (imageUrl !== undefined) {
          empUpdateFields.push(`image_url = $${empParamIndex++}`);
          empUpdateValues.push(imageUrl);
        }
        if (notes !== undefined) {
          empUpdateFields.push(`notes = $${empParamIndex++}`);
          empUpdateValues.push(notes);
        }
        if (quotaLeads !== undefined) {
          empUpdateFields.push(`quota_leads = $${empParamIndex++}`);
          empUpdateValues.push(quotaLeads);
        }
        if (viewEmployees !== undefined) {
          empUpdateFields.push(`view_employees = $${empParamIndex++}`);
          empUpdateValues.push(JSON.stringify(viewEmployees));
        }
        if (invoiceNumber !== undefined) {
          empUpdateFields.push(`invoice_number = $${empParamIndex++}`);
          empUpdateValues.push(invoiceNumber);
        }
        if (group !== undefined) {
          empUpdateFields.push(`emp_group = $${empParamIndex++}`);
          empUpdateValues.push(group);
        }

        if (empUpdateFields.length > 0) {
          empUpdateFields.push(`last_updated = CURRENT_TIMESTAMP`);
          empUpdateValues.push(contactId, companyId);

          const employeeUpdateQuery = `
            UPDATE employees 
            SET ${empUpdateFields.join(", ")}
            WHERE email = $${empParamIndex++} AND company_id = $${empParamIndex++}
          `;

          await client.query(employeeUpdateQuery, empUpdateValues);
        }
      } else {
        // Insert new employee record if it doesn't exist
        const employeeInsertQuery = `
          INSERT INTO employees (
            company_id, name, email, role, phone_number, employee_id,
            phone_access, weightages, image_url, notes, quota_leads,
            view_employees, invoice_number, emp_group
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        `;

        await client.query(employeeInsertQuery, [
          companyId,
          name,
          contactId,
          role,
          phoneNumber,
          employeeId || null,
          JSON.stringify(phoneAccess || {}),
          JSON.stringify(weightages || {}),
          imageUrl || null,
          notes || null,
          quotaLeads || 0,
          JSON.stringify(viewEmployees || []),
          invoiceNumber || null,
          group || null,
        ]);
      }

      // Update Firebase Auth if password is provided
      if (password) {
        try {
          const user = await admin.auth().getUserByEmail(contactId);
          await admin.auth().updateUser(user.uid, {
            password: password,
            displayName: name,
          });
        } catch (authError) {
          console.error("Error updating Firebase Auth:", authError);
          // Don't fail the entire operation for auth errors
        }
      }

      await client.query("COMMIT");
      res.json({ message: "User updated successfully" });
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error updating user:", error);
    res.status(500).json({ error: "Failed to update user" });
  }
});

// Delete user endpoint
// Delete user endpoint
// Delete user endpoint
// Delete user endpoint
app.delete("/api/delete-user", async (req, res) => {
  console.log("Delete user request received:", {
    body: req.body,
    headers: req.headers,
  });

  try {
    const { email, companyId } = req.body;

    // Validate required fields
    if (!email) {
      console.log("Delete user error: Email is required");
      return res.status(400).json({ error: "Email is required" });
    }

    if (!companyId) {
      console.log("Delete user error: Company ID is required");
      return res.status(400).json({ error: "Company ID is required" });
    }

    console.log(
      `Attempting to delete user: ${email} from company: ${companyId}`
    );

    // Check database connection
    if (!pool) {
      console.error("Delete user error: Database pool not initialized");
      return res
        .status(500)
        .json({ error: "Database connection not available" });
    }

    // Start transaction
    let client;
    try {
      client = await pool.connect();
      console.log("Database connection acquired for delete user transaction");

      await client.query("BEGIN");
      console.log("Transaction started for delete user");

      // Check if user exists before deletion
      const userCheckResult = await client.query(
        "SELECT id, employee_id FROM employees WHERE email = $1 AND company_id = $2",
        [email, companyId]
      );

      if (userCheckResult.rows.length === 0) {
        console.log(
          `Delete user warning: User ${email} not found in employees table`
        );
        await client.query("ROLLBACK");
        return res.status(404).json({ error: "User not found" });
      }

      const employeeId = userCheckResult.rows[0].id;
      const employeeIdForConstraints =
        userCheckResult.rows[0].employee_id || email;

      console.log(
        `Found employee with ID: ${employeeId}, employee_id: ${employeeIdForConstraints}`
      );

      // Delete related records in the correct order to avoid foreign key violations

      // 1. Delete from assignments table first (if it exists)
      try {
        const deleteAssignmentsResult = await client.query(
          "DELETE FROM assignments WHERE employee_id = $1",
          [email] // Use email instead of employeeIdForConstraints
        );
        console.log(
          `Assignments deleted: ${deleteAssignmentsResult.rows.length} rows affected`
        );
      } catch (assignmentsError) {
        console.log(
          `No assignments table or no assignments to delete: ${assignmentsError.message}`
        );
      }

      // 2. Delete from other potential related tables (add more as needed)
      // You can add more DELETE statements here for other tables that reference employees

      // 3. Now delete from employees table
      const deleteEmployeeResult = await client.query(
        "DELETE FROM employees WHERE email = $1 AND company_id = $2 RETURNING id",
        [email, companyId]
      );
      console.log(
        `Employee deleted: ${deleteEmployeeResult.rows.length} rows affected`
      );

      // 4. Deactivate user in users table (soft delete)
      const updateUserResult = await client.query(
        "UPDATE users SET active = false, last_updated = CURRENT_TIMESTAMP WHERE email = $1 AND company_id = $2 RETURNING id",
        [email, companyId]
      );
      console.log(
        `User deactivated: ${updateUserResult.rows.length} rows affected`
      );

      await client.query("COMMIT");
      console.log("Delete user transaction committed successfully");

      res.json({
        success: true,
        message: "User deleted successfully",
        deletedEmployeeId: deleteEmployeeResult.rows[0]?.id,
        deactivatedUserId: updateUserResult.rows[0]?.id,
      });
    } catch (dbError) {
      console.error("Database error during delete user:", dbError);

      if (client) {
        try {
          await client.query("ROLLBACK");
          console.log("Delete user transaction rolled back due to error");
        } catch (rollbackError) {
          console.error("Error during rollback:", rollbackError);
        }
      }

      // Provide more specific error messages
      if (dbError.code === "23503") {
        return res.status(400).json({
          error:
            "Cannot delete user due to foreign key constraints. Please remove related data first.",
          details: dbError.detail,
          constraint: dbError.constraint,
        });
      } else if (dbError.code === "42P01") {
        return res.status(500).json({
          error: "Database table not found. Please check database schema.",
        });
      } else if (dbError.code === "08006") {
        return res.status(500).json({
          error: "Database connection lost. Please try again.",
        });
      } else {
        return res.status(500).json({
          error: "Database operation failed",
          details: dbError.message,
          code: dbError.code,
        });
      }
    } finally {
      if (client) {
        client.release();
        console.log("Database connection released");
      }
    }
  } catch (error) {
    console.error("Unexpected error in delete user endpoint:", error);
    res.status(500).json({
      error: "Internal server error",
      message: error.message,
    });
  }
});

async function createNeonAuthUser(email, name) {
  const response = await axios.post(
    "https://console.neon.tech/api/v2/projects/auth/user",
    {
      auth_provider: "stack",
      project_id: "calm-math-47167505", // or your project id string
      email,
      name,
    },
    {
      headers: {
        accept: "application/json",
        authorization: `Bearer ${process.env.NEON_API_KEY}`,
        "content-type": "application/json",
      },
    }
  );
  return response.data;
}

// ============================================
// ASSISTANT FILES MANAGEMENT ENDPOINTS
// ============================================

// Configure storage for file uploads with company-specific paths
const assistantFileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const { companyId } = req.body;
    const uploadPath = path.join(MEDIA_DIR, "files", companyId || "default");

    // Ensure directory exists
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }
    cb(null, uploadPath);
  },
  filename: (req, file, cb) => {
    const timestamp = Date.now();
    const ext = path.extname(file.originalname);
    const baseName = path.basename(file.originalname, ext);
    const uniqueName = `${timestamp}_${baseName}${ext}`;
    cb(null, uniqueName);
  },
});

const assistantFileUpload = multer({
  storage: assistantFileStorage,
  limits: {
    fileSize: 200 * 1024 * 1024, // 200MB file size limit
  },
});

// Enhanced file upload endpoint for assistant files
app.post(
  "/api/upload-file",
  assistantFileUpload.single("file"),
  async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: "No file uploaded" });
      }

      const { fileName, companyId } = req.body;

      if (!fileName || !companyId) {
        return res
          .status(400)
          .json({ error: "fileName and companyId are required" });
      }

      const baseUrl =
        process.env.BASE_URL || "https://bisnesgpt.jutateknologi.com";
      const fileUrl = `${baseUrl}/media/files/${companyId}/${req.file.filename}`;

      console.log(
        `Assistant file uploaded: ${req.file.originalname} -> ${req.file.filename} for company ${companyId}`
      );

      res.json({
        success: true,
        url: fileUrl,
        filename: req.file.filename,
        originalName: req.file.originalname,
        size: req.file.size,
      });
    } catch (error) {
      console.error("Error uploading assistant file:", error);
      res.status(500).json({
        success: false,
        error: "Failed to upload file",
      });
    }
  }
);

// Create assistant_files table if it doesn't exist
async function createAssistantFilesTable() {
  try {
    const client = await pool.connect();
    try {
      await client.query(`
        CREATE TABLE IF NOT EXISTS assistant_files (
          id SERIAL PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          url TEXT NOT NULL,
          vector_store_id VARCHAR(255),
          openai_file_id VARCHAR(255),
          company_id VARCHAR(50) NOT NULL,
          created_by VARCHAR(255),
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
          updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
      `);

      // Create index for faster lookups
      await client.query(`
        CREATE INDEX IF NOT EXISTS idx_assistant_files_company_id 
        ON assistant_files(company_id)
      `);

      console.log("Assistant files table created/verified successfully");
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error creating assistant_files table:", error);
  }
}

// Initialize the table on startup
createAssistantFilesTable();

// POST /api/assistant-files - Save file metadata after upload
app.post("/api/assistant-files", async (req, res) => {
  try {
    const { name, url, vectorStoreId, openAIFileId, companyId, createdBy } =
      req.body;

    if (!name || !url || !companyId) {
      return res.status(400).json({
        success: false,
        error: "name, url, and companyId are required",
      });
    }

    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      const insertQuery = `
        INSERT INTO assistant_files (
          name, url, vector_store_id, openai_file_id, company_id, created_by
        ) VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id
      `;

      const result = await client.query(insertQuery, [
        name,
        url,
        vectorStoreId || null,
        openAIFileId || null,
        companyId,
        createdBy || null,
      ]);

      await client.query("COMMIT");

      res.json({
        success: true,
        id: result.rows[0].id,
        message: "File metadata saved successfully",
      });
    } catch (error) {
      await safeRollback(client);
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error saving assistant file metadata:", error);
    res.status(500).json({
      success: false,
      error: "Failed to save file metadata",
    });
  }
});

// GET /api/assistant-files - Fetch all files for a company
app.get("/api/assistant-files", async (req, res) => {
  try {
    const { companyId } = req.query;

    if (!companyId) {
      return res.status(400).json({
        success: false,
        error: "companyId is required",
      });
    }

    const client = await pool.connect();
    try {
      const query = `
        SELECT id, name, url, vector_store_id as "vectorStoreId", 
               openai_file_id as "openAIFileId", created_by as "createdBy",
               created_at as "createdAt", updated_at as "updatedAt"
        FROM assistant_files 
        WHERE company_id = $1 
        ORDER BY created_at DESC
      `;

      const result = await client.query(query, [companyId]);

      res.json({
        success: true,
        files: result.rows,
      });
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error fetching assistant files:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch files",
    });
  }
});

// DELETE /api/assistant-files/:fileId - Delete file metadata and physical file
app.delete("/api/assistant-files/:fileId", async (req, res) => {
  try {
    const { fileId } = req.params;

    if (!fileId) {
      return res.status(400).json({
        success: false,
        error: "fileId is required",
      });
    }

    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      // Get file info before deletion
      const selectQuery =
        "SELECT url, company_id FROM assistant_files WHERE id = $1";
      const fileResult = await client.query(selectQuery, [fileId]);

      if (fileResult.rows.length === 0) {
        await client.query("ROLLBACK");
        return res.status(404).json({
          success: false,
          error: "File not found",
        });
      }

      const fileInfo = fileResult.rows[0];

      // Delete from database
      const deleteQuery = "DELETE FROM assistant_files WHERE id = $1";
      await client.query(deleteQuery, [fileId]);

      await client.query("COMMIT");

      // Attempt to delete physical file
      try {
        const urlParts = fileInfo.url.split("/");
        const filename = urlParts[urlParts.length - 1];
        const filePath = path.join(
          MEDIA_DIR,
          "files",
          fileInfo.company_id,
          filename
        );

        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          console.log(`Physical file deleted: ${filePath}`);
        }
      } catch (fsError) {
        console.error("Error deleting physical file:", fsError);
        // Don't fail the API call if file deletion fails
      }

      res.json({
        success: true,
        message: "File deleted successfully",
      });
    } catch (error) {
      await safeRollback(client);
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error deleting assistant file:", error);
    res.status(500).json({
      success: false,
      error: "Failed to delete file",
    });
  }
});

app.post("/api/channel/create/:companyID", async (req, res) => {
  const { companyID } = req.params;
  const phoneCount = 1;

  // Get additional data from request body
  const {
    name,
    companyName,
    phoneNumber,
    email,
    password,
    plan = "blaster", // Default plan
    country,
  } = req.body || {};

  try {
    // Check if company exists first
    let companyResult = await sqlDb.query(
      "SELECT * FROM companies WHERE company_id = $1",
      [companyID]
    );

    let company = companyResult.rows[0];
    let companyCreated = false;

    // If company doesn't exist, create it with the provided data
    if (!company) {
      console.log(`Company ${companyID} not found, creating new company...`);

      try {
        // Create company with the provided information including apiUrl
        await sqlDb.query(
          `INSERT INTO companies (
            company_id, 
            name, 
            email, 
            phone, 
            status, 
            enabled, 
            created_at, 
            updated_at,
            plan,
            company,
            api_url
          ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, $7, $8, $9)`,
          [
            companyID,
            name || `Company_${companyID}`, // Use provided name or default
            email || `company_${companyID}@example.com`, // Use provided email or default
            phoneNumber || "", // Use provided phone or empty
            "active",
            true,
            plan, // Store the selected plan
            companyName || `Company_${companyID}`, // Use provided company name or default
            process.env.URL, // Set the API URL
          ]
        );

        // Fetch the newly created company
        companyResult = await sqlDb.query(
          "SELECT * FROM companies WHERE company_id = $1",
          [companyID]
        );
        company = companyResult.rows[0];
        companyCreated = true;

        console.log(
          `Company ${companyID} created successfully with plan: ${plan} and apiUrl: ${process.env.URL}`
        );
      } catch (createError) {
        console.error("Error creating company:", createError);
        return res.status(500).json({
          success: false,
          error: "Failed to create company",
          details: createError.message,
        });
      }
    } else {
      // If company exists, update it with the new information if provided
      if (name || email || phoneNumber || plan || companyName) {
        const updateFields = [];
        const updateValues = [];
        let paramIndex = 1;

        if (name) {
          updateFields.push(`name = $${paramIndex++}`);
          updateValues.push(name);
        }
        if (email) {
          updateFields.push(`email = $${paramIndex++}`);
          updateValues.push(email);
        }
        if (phoneNumber) {
          updateFields.push(`phone = $${paramIndex++}`);
          updateValues.push(phoneNumber);
        }
        if (plan) {
          updateFields.push(`plan = $${paramIndex++}`);
          updateValues.push(plan);
        }
        if (companyName) {
          updateFields.push(`company = $${paramIndex++}`);
          updateValues.push(companyName);
        }

        // Always update apiUrl for existing companies too
        updateFields.push(`api_url = $${paramIndex++}`);
        updateValues.push(process.env.URL);

        if (updateFields.length > 0) {
          updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
          updateValues.push(companyID);

          await sqlDb.query(
            `UPDATE companies SET ${updateFields.join(
              ", "
            )} WHERE company_id = $${paramIndex}`,
            updateValues
          );

          // Fetch the updated company
          companyResult = await sqlDb.query(
            "SELECT * FROM companies WHERE company_id = $1",
            [companyID]
          );
          company = companyResult.rows[0];
        }
      }
    }

    // Create the assistant with proper error handling
    let assistantId;
    try {
      assistantId = await createAssistant(companyID);
    } catch (assistantError) {
      console.error("Failed to create assistant:", assistantError);
      // Continue without assistant - don't fail the entire request
      assistantId = null;
    }

    // Respond to the client immediately
    res.json({
      success: true,
      message: companyCreated
        ? "Company and channel created successfully. Bot initialization in progress."
        : "Channel created successfully. Bot initialization in progress.",
      companyId: companyID,
      company: company,
      botStatus: "initializing",
      assistantId: assistantId,
      companyCreated: companyCreated,
      plan: plan,
      apiUrl: process.env.URL,
    });

    // Now initialize the bot in the background
    initializeBot(companyID, phoneCount)
      .then(() => {
        console.log(`Bot initialized for company ${companyID}`);
      })
      .catch((error) => {
        console.error(
          `Error initializing bot for company ${companyID}:`,
          error
        );
        // Optionally: log to DB or notify admin
      });
  } catch (error) {
    console.error("Error creating channel and initializing new bot:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create channel and initialize new bot",
      details: error.message,
    });
  }
});
app.post(
  "/api/create-user/:email/:phoneNumber/:password/:role/:companyId",
  async (req, res) => {
    try {
      const decodedEmail = decodeURIComponent(req.params.email);
      if (!decodedEmail || !decodedEmail.includes("@")) {
        return res.status(400).json({ error: "Invalid email format" });
      }

      const userData = {
        email: decodedEmail,
        phoneNumber: req.params.phoneNumber,
        password: req.params.password,
        role: req.params.role,
        companyId: req.params.companyId, // Get companyId from params
      };
      const name = decodedEmail.split("@")[0];
      console.log("Creating user in Neon Auth:", userData, name);

      // Create user in Neon Auth
      const neonUser = await createNeonAuthUser(decodedEmail, name);

      // Generate a unique user ID
      const userId = uuidv4();

      // Create company in database if it doesn't exist
      const companyCheck = await sqlDb.query(
        "SELECT company_id FROM companies WHERE company_id = $1",
        [userData.companyId]
      );

      if (companyCheck.rows.length === 0) {
        // Create company if it doesn't exist
        await sqlDb.query(
          `INSERT INTO companies (company_id, name, email, phone, status, enabled, created_at) 
          VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)`,
          [
            userData.companyId,
            userData.email.split("@")[0],
            userData.email,
            userData.phoneNumber,
            "active",
            true,
          ]
        );
      }

      // Create user in database
      await sqlDb.query(
        `INSERT INTO users (user_id, company_id, email, phone, role, active, created_at, password, stopbot) 
         VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, $7, $8)`,
        [
          userId,
          userData.companyId,
          userData.email,
          0,
          userData.role,
          true,
          userData.password,
          false,
        ]
      );

      res.json({
        message: "User created successfully",
        userId,
        companyId: userData.companyId,
        neonUserId: neonUser.id,
        role: userData.role,
        email: userData.email,
      });
    } catch (error) {
      console.error("Error creating user:", error);
      res.status(500).json({
        error: error.code || "Failed to create user",
        details: error.message,
      });
    }
  }
);

// New API to add a user under an existing company
app.post(
  "/api/add-user/:companyId/:email/:phoneNumber/:password/:role",
  async (req, res) => {
    try {
      const { companyId, email, phoneNumber, password, role } = req.params;
      const decodedEmail = decodeURIComponent(email);

      // Get optional fields from request body
      const {
        name: providedName,
        employeeId,
        phoneAccess,
        weightages,
        company,
        imageUrl,
        notes,
        quotaLeads,
        viewEmployees,
        invoiceNumber,
        empGroup,
        profile,
        threadId,
      } = req.body || {};

      if (!decodedEmail || !decodedEmail.includes("@")) {
        return res.status(400).json({ error: "Invalid email format" });
      }

      // Check if company exists
      const companyResult = await sqlDb.query(
        "SELECT * FROM companies WHERE company_id = $1",
        [companyId]
      );
      if (companyResult.rows.length === 0) {
        return res.status(404).json({ error: "Company not found" });
      }

      // Create user in Neon Auth
      const name = providedName || decodedEmail.split("@")[0];
      const neonUser = await createNeonAuthUser(decodedEmail, name);

      // Generate unique IDs
      const userId = uuidv4();
      const finalEmployeeId = employeeId || uuidv4();

      // Insert into users table with flexible field handling
      const userFields = [
        "user_id",
        "company_id",
        "email",
        "phone",
        "role",
        "active",
        "created_at",
        "password",
      ];
      const userValues = [
        userId,
        companyId,
        decodedEmail,
        0,
        role,
        true,
        password,
      ];
      let userPlaceholders = "$1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, $7";
      let paramIndex = 8;

      // Add optional user fields
      if (providedName) {
        userFields.push("name");
        userValues.push(name);
        userPlaceholders += `, $${paramIndex++}`;
      }
      if (profile) {
        userFields.push("profile");
        userValues.push(JSON.stringify(profile));
        userPlaceholders += `, $${paramIndex++}`;
      }
      if (threadId) {
        userFields.push("thread_id");
        userValues.push(threadId);
        userPlaceholders += `, $${paramIndex++}`;
      }

      const userQuery = `
        INSERT INTO users (${userFields.join(", ")}) 
        VALUES (${userPlaceholders})
      `;

      await sqlDb.query(userQuery, userValues);

      // Insert into employees table with flexible field handling
      const empFields = [
        "employee_id",
        "company_id",
        "name",
        "email",
        "role",
        "active",
        "created_at",
      ];
      const empValues = [
        finalEmployeeId,
        companyId,
        name,
        decodedEmail,
        role,
        true,
      ];
      let empPlaceholders = "$1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP";
      paramIndex = 7;

      // Add optional employee fields
      if (phoneNumber) {
        empFields.push("phone_number");
        empValues.push(phoneNumber);
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (phoneAccess) {
        empFields.push("phone_access");
        empValues.push(JSON.stringify(phoneAccess));
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (weightages) {
        empFields.push("weightages");
        empValues.push(JSON.stringify(weightages));
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (company) {
        empFields.push("company");
        empValues.push(company);
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (imageUrl) {
        empFields.push("image_url");
        empValues.push(imageUrl);
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (notes) {
        empFields.push("notes");
        empValues.push(notes);
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (quotaLeads !== undefined) {
        empFields.push("quota_leads");
        empValues.push(quotaLeads);
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (viewEmployees) {
        empFields.push("view_employees");
        empValues.push(JSON.stringify(viewEmployees));
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (invoiceNumber) {
        empFields.push("invoice_number");
        empValues.push(invoiceNumber);
        empPlaceholders += `, $${paramIndex++}`;
      }
      if (empGroup) {
        empFields.push("emp_group");
        empValues.push(empGroup);
        empPlaceholders += `, $${paramIndex++}`;
      }

      const empQuery = `
        INSERT INTO employees (${empFields.join(", ")}) 
        VALUES (${empPlaceholders})
      `;

      await sqlDb.query(empQuery, empValues);

      res.json({
        message: "User added successfully",
        userId,
        employeeId: finalEmployeeId,
        companyId,
        neonUserId: neonUser.id,
        role,
        email: decodedEmail,
        name,
      });
    } catch (error) {
      console.error("Error adding user:", error);
      res.status(500).json({
        error: error.code || "Failed to add user",
        details: error.message,
      });
    }
  }
);

app.post("/api/import-csv/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const { csvUrl, tags } = req.body;

  if (!csvUrl) {
    return res.status(400).json({ error: "CSV URL is required" });
  }

  if (!Array.isArray(tags)) {
    return res.status(400).json({ error: "Tags must be an array" });
  }

  try {
    const tempFile = `temp_${Date.now()}.csv`;
    await downloadCSV(csvUrl, tempFile);
    await processCSV(tempFile, companyId, tags);
    fs.unlinkSync(tempFile); // Clean up temporary file
    res.json({ message: "CSV processed successfully" });
  } catch (error) {
    console.error("Error processing CSV:", error);
    res.status(500).json({ error: "Failed to process CSV" });
  }
});

async function downloadCSV(url, filename) {
  const response = await fetch(url);
  if (!response.ok)
    throw new Error(`Unexpected response ${response.statusText}`);
  await pipeline(response.body, fs.createWriteStream(filename));
}

// Update the processCSV function to accept tags
async function processCSV(filename, companyId, tags) {
  return new Promise((resolve, reject) => {
    fs.createReadStream(filename)
      .pipe(csv())
      .on("data", async (row) => {
        try {
          await processContact(row, companyId, tags);
        } catch (error) {
          console.error("Error processing row:", error);
        }
      })
      .on("end", () => {
        console.log("CSV file successfully processed");
        resolve();
      })
      .on("error", reject);
  });
}

async function processContact(row, companyId, tags) {
  const client = await pool.connect();

  try {
    await client.query("BEGIN");

    let name, phone;

    if (companyId === "0124") {
      name = row["Nama Penuh"] || row["Nama Syarikat/Organisasi"];
      phone = await formatPhoneNumber(
        row["No Telefon"] || row["No Telefon Organisasi"]
      );
    } else {
      name = row.Name;
      phone = await formatPhoneNumber(row.Phone);
    }

    if (!name) {
      name = phone;
    }

    let phoneWithPlus = phone.startsWith("+") ? phone : "+" + phone;
    const phoneWithoutPlus = phone.replace("+", "");
    const contactId = `${companyId}-${phoneWithoutPlus}`;

    if (phone) {
      // Check if contact exists
      const checkQuery =
        "SELECT id FROM contacts WHERE contact_id = $1 AND company_id = $2";
      const checkResult = await client.query(checkQuery, [
        contactId,
        companyId,
      ]);

      if (checkResult.rows.length > 0) {
        // Contact exists - update tags and possibly zakat data
        const updateData = {
          tags: [...tags],
          updated_at: new Date(),
        };

        if (companyId === "0124") {
          // For zakat data, we need to handle the JSONB array
          const zakatData = createZakatData(row);
          const updateZakatQuery = `
            UPDATE contacts 
            SET tags = tags || $1::jsonb, 
                custom_fields = COALESCE(custom_fields, '{}'::jsonb) || jsonb_build_object('zakatData', COALESCE(custom_fields->'zakatData', '[]'::jsonb) || $2::jsonb),
                updated_at = $3
            WHERE contact_id = $4 AND company_id = $5
          `;
          await client.query(updateZakatQuery, [
            JSON.stringify(tags),
            JSON.stringify([zakatData]),
            new Date(),
            contactId,
            companyId,
          ]);
        } else {
          // Regular update for non-zakat contacts
          const updateQuery = `
            UPDATE contacts 
            SET tags = tags || $1::jsonb, 
                updated_at = $2
            WHERE contact_id = $3 AND company_id = $4
          `;
          await client.query(updateQuery, [
            JSON.stringify(tags),
            new Date(),
            contactId,
            companyId,
          ]);
        }
      } else {
        // Contact doesn't exist - create new record
        const contactData = {
          contact_id: contactId,
          company_id: companyId,
          name: name,
          contact_name: name,
          phone: phoneWithPlus,
          email: null,
          thread_id: "",
          tags: JSON.stringify(tags),
          chat_id: `${phoneWithoutPlus}@c.us`,
          chat_data: JSON.stringify({
            contact_id: phoneWithoutPlus,
            id: `${phoneWithoutPlus}@c.us`,
            name: name,
            not_spam: true,
            tags: tags,
            timestamp: Date.now(),
            type: "contact",
            unreadCount: 0,
            last_message: null,
          }),
          unread_count: 0,
          not_spam: true,
          last_message: null,
          custom_fields: {},
        };

        if (companyId === "079") {
          contactData.branch = row["BRANCH NAME"] || "-";
          contactData.address1 = row["ADDRESS"] || "-";
          contactData.expiry_date = row["PERIOD OF COVER"] || "-";
          contactData.email = row["EMAIL"] || "-";
          contactData.vehicle_number = row["VEH. NO"] || "-";
          contactData.ic = row["IC/PASSPORT/BUSINESS REG. NO"] || "-";
        } else if (companyId === "0124") {
          contactData.address1 =
            `${row["Alamat Penuh (Jalan)"]} ${row["Alamat Penuh (Address Line 2)"]}`.trim();
          contactData.city = row["Alamat Penuh (Bandar)"] || null;
          contactData.state = row["Alamat Penuh (Negeri)"] || null;
          contactData.postcode = row["Alamat Penuh (Poskod)"] || null;
          contactData.email = row["Emel"] || null;
          contactData.ic = row["No. Kad Pengenalan ( tanpa '-' )"] || null;

          // Add zakat data to custom_fields
          contactData.custom_fields = JSON.stringify({
            zakatData: [createZakatData(row)],
          });
        }

        const insertQuery = `
          INSERT INTO contacts (
            contact_id, company_id, name, contact_name, phone, email, thread_id, 
            tags, chat_id, chat_data, unread_count, not_spam, last_message, 
            custom_fields, branch, address1, expiry_date, vehicle_number, ic,
            city, state, postcode, created_at, updated_at
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
            $15, $16, $17, $18, $19, $20, $21, $22, $23, $24
          )
        `;

        await client.query(insertQuery, [
          contactData.contact_id,
          contactData.company_id,
          contactData.name,
          contactData.contact_name,
          contactData.phone,
          contactData.email,
          contactData.thread_id,
          contactData.tags,
          contactData.chat_id,
          contactData.chat_data,
          contactData.unread_count,
          contactData.not_spam,
          contactData.last_message,
          contactData.custom_fields,
          contactData.branch,
          contactData.address1,
          contactData.expiry_date,
          contactData.vehicle_number,
          contactData.ic,
          contactData.city,
          contactData.state,
          contactData.postcode,
          new Date(),
          new Date(),
        ]);
      }
    } else {
      console.warn(`Skipping invalid phone number for ${name}`);
    }

    await client.query("COMMIT");
  } catch (error) {
    await safeRollback(client);
    console.error("Error processing contact:", error);
    throw error;
  } finally {
    await safeRelease(client);
  }
}

function createZakatData(row) {
  const sourceUrl = row["Source Url"] || "";
  const zakatData = {
    // Common fields for all types
    paymentStatus: row["Payment Status"] || "Processing",
    paymentDate: row["Payment Date"] || null,
    paymentAmount: row["Payment Amount"] || null,
    transactionId: row["Transaction Id"] || null,
    entryDate: row["Entry Date"] || null,
    dateUpdated: row["Date Updated"] || null,
    sourceUrl: sourceUrl,
    total: row["Total"] || null,
    productName: row["Product Name (Name)"] || null,
    productPrice:
      row["Product Name (Price)"]?.replace("&#82;&#77; ", "") || null,
    productQuantity: row["Product Name (Quantity)"] || null,
    consent: row["Consent (Consent)"] || null,
    consentText: row["Consent (Text)"] || null,
    consentDescription: row["Consent (Description)"] || null,
  };

  // Determine type and add specific fields
  if (sourceUrl.includes("zakat-simpanan")) {
    zakatData.type = "Simpanan";
    zakatData.totalSavings = row["Jumlah Wang Simpanan"];
    zakatData.zakatAmount = row["Jumlah Zakat Simpanan Yang Perlu Ditunaikan"];
  } else if (sourceUrl.includes("zakat-perniagaan")) {
    zakatData.type = row["Nama Syarikat/Organisasi"]
      ? "PerniagaanOrganisasi"
      : "PerniagaanIndividu";
    zakatData.businessProfit = row["Untung Bersih Perniagaan"];
    zakatData.zakatAmount =
      row["Jumlah Zakat Perniagaan Yang Perlu Ditunaikan"];
    if (zakatData.type === "PerniagaanOrganisasi") {
      zakatData.companyName = row["Nama Syarikat/Organisasi"];
      zakatData.ssmNumber = row["No. SSM"];
      zakatData.orgPhone = row["No Telefon Organisasi"];
      zakatData.officerName = row["Nama Pegawai Untuk Dihubungi"];
      zakatData.officerPhone = row["No. Telefon Pegawai"];
    }
  } else if (sourceUrl.includes("zakat-perak")) {
    zakatData.type = "Perak";
    zakatData.silverValue = row["Nilai Simpanan"];
    zakatData.zakatAmount = row["Jumlah Zakat Perak Yang Perlu Ditunaikan"];
  } else if (sourceUrl.includes("zakat-pendapatan")) {
    zakatData.type = "Pendapatan";
    zakatData.monthlyIncome = row["Pendapatan Bulanan"];
    zakatData.otherAnnualIncome = row["Lain-Lain Pendapatan Tahunan"];
    zakatData.monthlyZakat = row["Jumlah Zakat Bulanan"];
    zakatData.annualZakat = row["Jumlah Zakat Tahunan"];
    zakatData.paymentOption = row["Pilihan Bayaran"];
  } else if (sourceUrl.includes("zakat-pelaburan")) {
    zakatData.type = "Pelaburan";
    zakatData.investmentTotal = row["Modal Asal + Untung Bersih"];
    zakatData.zakatAmount = row["Jumlah Zakat Pelaburan Yang Perlu Ditunaikan"];
  } else if (sourceUrl.includes("zakat-padi")) {
    zakatData.type = "Padi";
    zakatData.year = row["Haul/Tahun"];
    zakatData.zakatAmount = row["Jumlah Zakat Padi Yang Hendak Ditunaikan"];
  } else if (sourceUrl.includes("zakat-kwsp")) {
    zakatData.type = "KWSP";
    zakatData.epfAmount = row["Jumlah Yang Dikeluarkan Daripada KWSP"];
    zakatData.zakatAmount = row["Jumlah Zakat KWSP Yang Perlu Ditunaikan"];
  } else if (sourceUrl.includes("zakat-fitrah")) {
    zakatData.type = "Fitrah";
    zakatData.riceType = row["Pilih Jenis Beras"];
    zakatData.dependents = row["Jumlah Tanggungan (orang)"];
    zakatData.zakatAmount = row["Zakat Fitrah Yang Perlu Ditunaikan"];
  } else if (sourceUrl.includes("zakat-emas")) {
    zakatData.type = "Emas";
    zakatData.goldValue = row["Nilai Semasa Emas Yang Dimiliki"];
    zakatData.zakatAmount = row["Jumlah Zakat Emas Yang Perlu Ditunaikan"];
  } else if (sourceUrl.includes("zakat-ternakan")) {
    zakatData.type = "Ternakan";
    zakatData.year = row["Haul/Tahun"];
    zakatData.zakatAmount = row["Jumlah Zakat Qadha Yang Hendak Ditunaikan"];
  } else if (sourceUrl.includes("qadha-zakat")) {
    zakatData.type = "Qadha";
    zakatData.year = row["Haul/Tahun"];
    zakatData.zakatAmount = row["Jumlah Zakat Qadha Yang Hendak Ditunaikan"];
  }

  return zakatData;
}

function formatPhoneNumber(phone) {
  if (!phone) return "";

  // Remove all non-numeric characters
  phone = phone.toString().replace(/\D/g, "");

  // Remove leading zeros
  phone = phone.replace(/^0+/, "");

  // Ensure the number starts with '6'
  if (!phone.startsWith("6")) {
    phone = "6" + phone;
  }

  // Validate phone number length (should be between 10-14 digits after adding '6')
  if (phone.length < 10 || phone.length > 14) {
    console.warn(`Invalid phone number length: ${phone}`);
    return "";
  }

  //console.log('Formatted phone:', phone);
  return phone;
}

function toPgTimestamp(firestoreTimestamp) {
  if (!firestoreTimestamp) return null;

  // If it's already a JS Date
  if (firestoreTimestamp instanceof Date) return firestoreTimestamp;

  // If it's a string, try to parse it
  if (typeof firestoreTimestamp === "string") {
    const date = new Date(firestoreTimestamp);
    if (!isNaN(date.getTime())) return date;
    return null;
  }

  // If it's a Firestore timestamp object
  if (
    typeof firestoreTimestamp === "object" &&
    typeof firestoreTimestamp.seconds === "number" &&
    typeof firestoreTimestamp.nanoseconds === "number"
  ) {
    return new Date(
      firestoreTimestamp.seconds * 1000 +
        firestoreTimestamp.nanoseconds / 1000000
    );
  }

  // If it's a number (milliseconds since epoch)
  if (typeof firestoreTimestamp === "number") {
    return new Date(firestoreTimestamp);
  }

  // Fallback
  return null;
}

app.post("/api/contacts/:contactId/mark-unread", async (req, res) => {
  try {
    const { contactId } = req.params;
    const { company_id, increment = 1 } = req.body;

    if (!company_id) {
      return res.status(400).json({
        success: false,
        error: "company_id is required",
      });
    }

    // Get current unread count
    const currentResult = await sqlDb.query(
      `SELECT unread_count FROM contacts WHERE contact_id = $1 AND company_id = $2`,
      [contactId, company_id]
    );

    if (currentResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: "Contact not found",
      });
    }

    const currentUnreadCount = currentResult.rows[0].unread_count || 0;
    const newUnreadCount = currentUnreadCount + increment;

    // Update unread count
    const result = await sqlDb.query(
      `UPDATE contacts 
       SET unread_count = $1, 
           last_updated = CURRENT_TIMESTAMP
       WHERE contact_id = $2 AND company_id = $3
       RETURNING contact_id, unread_count, last_updated`,
      [newUnreadCount, contactId, company_id]
    );

    res.json({
      success: true,
      contact_id: contactId,
      unread_count: newUnreadCount,
      previous_unread_count: currentUnreadCount,
      increment: increment,
      last_updated: result.rows[0].last_updated,
    });
  } catch (error) {
    console.error("Error marking contact as unread:", error);
    res.status(500).json({
      success: false,
      error: "Failed to mark contact as unread",
      message: error.message,
    });
  }
});

// Mark contact as read (reset unread count to 0)
app.post("/api/contacts/:contactId/mark-read", async (req, res) => {
  try {
    const { contactId } = req.params;
    const { company_id } = req.body;

    if (!company_id) {
      return res.status(400).json({
        success: false,
        error: "company_id is required",
      });
    }

    // Get current unread count
    const currentResult = await sqlDb.query(
      `SELECT unread_count FROM contacts WHERE contact_id = $1 AND company_id = $2`,
      [contactId, company_id]
    );

    if (currentResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        error: "Contact not found",
      });
    }

    const currentUnreadCount = currentResult.rows[0].unread_count || 0;

    // Reset unread count to 0
    const result = await sqlDb.query(
      `UPDATE contacts 
       SET unread_count = 0, 
           last_updated = CURRENT_TIMESTAMP
       WHERE contact_id = $1 AND company_id = $2
       RETURNING contact_id, unread_count, last_updated`,
      [contactId, company_id]
    );

    res.json({
      success: true,
      contact_id: contactId,
      unread_count: 0,
      previous_unread_count: currentUnreadCount,
      last_updated: result.rows[0].last_updated,
    });
  } catch (error) {
    console.error("Error marking contact as read:", error);
    res.status(500).json({
      success: false,
      error: "Failed to mark contact as read",
      message: error.message,
    });
  }
});

// POST endpoint to schedule a message
app.post("/api/schedule-message/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const scheduledMessage = req.body;
  const phoneIndex = scheduledMessage.phoneIndex || 0;

  console.log("Received scheduling request:", {
    companyId,
    messageFormat: scheduledMessage.message ? "single" : "sequence",
    hasAdditionalMessages: Boolean(scheduledMessage.messages?.length),
    infiniteLoop: Boolean(scheduledMessage.infiniteLoop),
    hasMedia: Boolean(
      scheduledMessage.mediaUrl || scheduledMessage.documentUrl
    ),
    hasCaption: Boolean(scheduledMessage.caption),
    multiple: Boolean(scheduledMessage.multiple),
    contactCount: Array.isArray(scheduledMessage.contactId)
      ? scheduledMessage.contactId.length
      : 1,
  });

  try {
    // Validate and normalize active hours if provided
    let activeHoursStart = null;
    let activeHoursEnd = null;

    if (scheduledMessage.activeHours) {
      const start = scheduledMessage.activeHours.start;
      const end = scheduledMessage.activeHours.end;

      // Validate active hours
      const validation = validateActiveHours(start, end);
      if (!validation.valid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      // Normalize time format (ensure HH:MM with leading zeros)
      activeHoursStart = normalizeTimeFormat(start);
      activeHoursEnd = normalizeTimeFormat(end);

      console.log("Active hours validated:", {
        start: activeHoursStart,
        end: activeHoursEnd
      });
    }

    const client = await pool.connect();

    try {
      await client.query("BEGIN");

      const messageId = uuidv4();
      const isMediaMessage = Boolean(
        scheduledMessage.mediaUrl || scheduledMessage.documentUrl
      );
      const messageCaption =
        scheduledMessage.caption || scheduledMessage.message || "";

      // Handle multiple vs single contact logic
      const isMultiple = Boolean(scheduledMessage.multiple);
      const contactIds = Array.isArray(scheduledMessage.contact_id)
        ? scheduledMessage.contact_id
        : [scheduledMessage.contact_id].filter(Boolean);

      console.log("Contact processing:", {
        isMultiple,
        contactIds,
        originalContactId: scheduledMessage.contact_id,
      });

      // Validation: ensure we have contacts
      if (!contactIds.length) {
        throw new Error("No valid contacts provided");
      }

      // For single contact, store in contact_id field
      // For multiple contacts, store in contact_ids field
      const singleContactId =
        !isMultiple && contactIds.length > 0 ? contactIds[0] : null;
      const multipleContactIds =
        isMultiple && contactIds.length > 0 ? contactIds : null;

      // Normalize and validate chatIds coming from the client
      let chatIds = [];
      const rawChatIds = scheduledMessage.chatIds || [];

      try {
        if (typeof rawChatIds === "string") {
          // Try to parse JSON string
          try {
            chatIds = JSON.parse(rawChatIds);
          } catch (e) {
            // Not JSON - treat as single value
            chatIds = [rawChatIds];
          }
        } else if (Array.isArray(rawChatIds)) {
          chatIds = rawChatIds;
        } else if (rawChatIds) {
          chatIds = [rawChatIds];
        } else {
          chatIds = [];
        }
      } catch (e) {
        console.warn(
          "Error normalizing chatIds, falling back to empty array:",
          e.message
        );
        chatIds = [];
      }

      // Basic validation: accept only typical WA chatId formats like '60123456789@c.us' or '12345@g.us'
      const validChatIdRegex = /^\+?\d+@(?:c\.us|g\.us)$/i;
      const invalidSamples = chatIds.filter(
        (id) => !validChatIdRegex.test(String(id))
      );
      if (invalidSamples.length > 0) {
        console.warn(
          "Scheduling request contains invalid chatIds (they will be removed):",
          invalidSamples.slice(0, 10)
        );
        // Remove invalid entries
        chatIds = chatIds.filter((id) => validChatIdRegex.test(String(id)));
      }

      // Calculate batching based on CONTACTS (not messages)
      const totalContacts = contactIds.length;
      const contactsPerBatch = scheduledMessage.batchQuantity || totalContacts;
      const numberOfBatches = Math.ceil(totalContacts / contactsPerBatch);

      console.log("Batch calculation:", {
        totalContacts,
        contactsPerBatch,
        numberOfBatches,
        isMultiple,
        contactIds,
      });

      // Validate that we have valid data to schedule
      if (!chatIds || chatIds.length === 0) {
        throw new Error("No valid chat IDs found to schedule messages for");
      }

      if (
        !scheduledMessage.message &&
        !scheduledMessage.mediaUrl &&
        !scheduledMessage.documentUrl
      ) {
        throw new Error(
          "No message content, media, or document provided to schedule"
        );
      }

      const mainMessageQuery = `
        INSERT INTO scheduled_messages (
          id, schedule_id, company_id, contact_id, contact_ids, multiple, message_content, media_url, 
          scheduled_time, status, created_at, chat_id, phone_index, is_media,
          document_url, file_name, caption, chat_ids, batch_quantity, repeat_interval,
          repeat_unit, message_delays, infinite_loop, min_delay, max_delay, activate_sleep,
          sleep_after_messages, sleep_duration, active_hours, from_me, messages, template_id,
          active_hours_start, active_hours_end
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, 
          $18, $19, $20, $21, $22, $23, $24, $25, $26, $27, $28, $29, $30, $31, $32, $33, $34)
      `;
      const scheduledTime = toPgTimestamp(scheduledMessage.scheduledTime);
      await client.query(mainMessageQuery, [
        messageId,
        messageId,
        companyId,
        singleContactId,
        multipleContactIds ? JSON.stringify(multipleContactIds) : null,
        isMultiple,
        scheduledMessage.message || null,
        scheduledMessage.mediaUrl || null,
        scheduledTime,
        "scheduled",
        new Date(),
        chatIds[0] || null,
        phoneIndex,
        isMediaMessage,
        scheduledMessage.documentUrl || null,
        scheduledMessage.fileName || null,
        messageCaption,
        JSON.stringify(chatIds),
        scheduledMessage.batchQuantity || null,
        scheduledMessage.repeatInterval || null,
        scheduledMessage.repeatUnit || null,
        scheduledMessage.messageDelays
          ? JSON.stringify(scheduledMessage.messageDelays)
          : null,
        scheduledMessage.infiniteLoop || false,
        scheduledMessage.minDelay || null,
        scheduledMessage.maxDelay || null,
        scheduledMessage.activateSleep || false,
        scheduledMessage.sleepAfterMessages || null,
        scheduledMessage.sleepDuration || null,
        scheduledMessage.activeHours
          ? JSON.stringify(scheduledMessage.activeHours)
          : null,
        true,
        scheduledMessage.messages
          ? JSON.stringify(scheduledMessage.messages)
          : null,
        scheduledMessage.template_id || null,
        activeHoursStart,
        activeHoursEnd,
      ]);

      const queue = getQueueForBot(companyId);

      // CLEANUP: Remove stale queued jobs that no longer have a corresponding DB row
      try {
        const queuedJobs = await queue.getJobs([
          "delayed",
          "waiting",
          "active",
        ]);
        for (const qjob of queuedJobs) {
          try {
            const queuedJobId = qjob.id;
            if (!queuedJobId) continue;

            const checkJob = await client.query(
              `SELECT id, status FROM scheduled_messages WHERE id = $1 AND company_id = $2 LIMIT 1`,
              [queuedJobId, companyId]
            );

            if (checkJob.rowCount === 0) {
              console.log(
                `Removing stale queued job ${queuedJobId} for company ${companyId} - no DB row found`
              );
              try {
                await qjob.remove();
                console.log(
                  `Removed stale job ${queuedJobId} from queue for company ${companyId}`
                );
              } catch (rmErr) {
                console.error(
                  `Failed to remove stale queued job ${queuedJobId} for company ${companyId}:`,
                  rmErr
                );
              }
            } else if (checkJob.rows[0].status !== "scheduled") {
              console.log(
                `Removing queued job ${queuedJobId} for company ${companyId} because DB status is '${checkJob.rows[0].status}'`
              );
              try {
                await qjob.remove();
                console.log(
                  `Removed queued job ${queuedJobId} due to status change for company ${companyId}`
                );
              } catch (rmErr) {
                console.error(
                  `Failed to remove queued job ${queuedJobId} for company ${companyId}:`,
                  rmErr
                );
              }
            }
          } catch (innerErr) {
            console.error(
              `Error checking queued job ${qjob.id} for company ${companyId}:`,
              innerErr
            );
          }
        }
      } catch (queueErr) {
        console.error(
          `Error while cleaning up queued jobs for company ${companyId}:`,
          queueErr
        );
      }
      const batches = [];

      // Create batches if there are multiple contacts requiring batching
      if (isMultiple && numberOfBatches > 1) {
        for (let batchIndex = 0; batchIndex < numberOfBatches; batchIndex++) {
          const startIndex = batchIndex * contactsPerBatch;
          const endIndex = Math.min(
            (batchIndex + 1) * contactsPerBatch,
            totalContacts
          );

          const batchDelay =
            batchIndex *
            (scheduledMessage.repeatInterval || 0) *
            getMillisecondsForUnit(scheduledMessage.repeatUnit || "minutes");
          const batchScheduledTime = new Date(
            toPgTimestamp(scheduledMessage.scheduledTime).getTime() + batchDelay
          );

          const batchId = uuidv4(); // generate a valid UUID for each batch

          // Get contact IDs for this batch
          const batchContactIds = contactIds.slice(startIndex, endIndex);
          const batchChatIds = chatIds.slice(startIndex, endIndex);

          // Validate batch data
          if (!batchChatIds || batchChatIds.length === 0) {
            console.warn(`Skipping batch ${batchIndex} - no valid chat IDs`);
            continue;
          }

          // Prepare messages for this batch
          const batchMessages = batchChatIds.map((chatId) => ({
            chatId: chatId,
            message: scheduledMessage.message || null,
            delay: scheduledMessage.messageDelays
              ? JSON.parse(scheduledMessage.messageDelays)[0] || 0
              : Math.floor(
                  Math.random() *
                    ((scheduledMessage.maxDelay || 5) -
                      (scheduledMessage.minDelay || 1) +
                      1) +
                    (scheduledMessage.minDelay || 1)
                ),
            mediaUrl: scheduledMessage.mediaUrl || "",
            documentUrl: scheduledMessage.documentUrl || "",
            fileName: scheduledMessage.fileName || "",
            caption: scheduledMessage.caption || "",
          }));

          const batchQuery = `
          INSERT INTO scheduled_messages (
            id, schedule_id, company_id, scheduled_time, status, created_at,
            batch_index, chat_ids, phone_index, from_me, message_content, media_url, document_url, file_name, caption,
            messages, min_delay, max_delay, infinite_loop, repeat_interval, repeat_unit, active_hours,
            multiple, contact_id, contact_ids, active_hours_start, active_hours_end
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27)
        `;
          await client.query(batchQuery, [
            batchId,
            messageId,
            companyId,
            batchScheduledTime,
            "scheduled",
            new Date(),
            batchIndex,
            JSON.stringify(batchChatIds),
            phoneIndex,
            true,
            scheduledMessage.message || null,
            scheduledMessage.mediaUrl || null,
            scheduledMessage.documentUrl || null,
            scheduledMessage.fileName || null,
            scheduledMessage.caption || null,
            JSON.stringify(batchMessages),
            scheduledMessage.minDelay || null,
            scheduledMessage.maxDelay || null,
            scheduledMessage.infiniteLoop || false,
            scheduledMessage.repeatInterval || null,
            scheduledMessage.repeatUnit || null,
            scheduledMessage.activeHours
              ? JSON.stringify(scheduledMessage.activeHours)
              : null,
            isMultiple, // Use the defined variable
            null, // For batches, contact_id is always null
            JSON.stringify(batchContactIds), // Store the batch contacts in contact_ids
            activeHoursStart,
            activeHoursEnd,
          ]);
          batches.push({ id: batchId, scheduledTime: batchScheduledTime });
        }
      }

      await client.query("COMMIT");

      // Add jobs to queue
      if (batches.length > 0) {
        // Add batch jobs only (not the main entry as per requirements)
        for (const batch of batches) {
          const delay = Math.max(batch.scheduledTime.getTime() - Date.now(), 0);
          await queue.add(
            "send-message-batch",
            {
              companyId,
              messageId,
              batchId: batch.id,
            },
            {
              removeOnComplete: false,
              removeOnFail: false,
              delay,
              jobId: batch.id,
            }
          );
        }
      } else {
        // Add single message job (no batching needed)
        const delay = Math.max(scheduledTime.getTime() - Date.now(), 0);
        await queue.add(
          "send-single-message",
          {
            companyId,
            messageId,
          },
          {
            removeOnComplete: false,
            removeOnFail: false,
            delay,
            jobId: messageId,
          }
        );
      }

      res.status(201).json({
        id: messageId,
        message: "Message scheduled successfully",
        batches: batches.length,
        success: true,
      });
    } catch (error) {
      await safeRollback(client);
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error scheduling message:", error);
    res.status(500).json({ error: "Failed to schedule message" });
  }
});

// PUT endpoint to update a scheduled message
app.put("/api/schedule-message/:companyId/:messageId", async (req, res) => {
  const { companyId, messageId } = req.params;
  const updatedMessage = req.body;
  const phoneIndex = updatedMessage.phoneIndex || 0;

  console.log("PUT /api/schedule-message/:companyId/:messageId called");
  console.log("Params:", { companyId, messageId });
  console.log("Updated message body:", updatedMessage);

  try {
    // Validate and normalize active hours if provided
    let activeHoursStart = null;
    let activeHoursEnd = null;

    if (updatedMessage.activeHours) {
      const start = updatedMessage.activeHours.start;
      const end = updatedMessage.activeHours.end;

      // Validate active hours
      const validation = validateActiveHours(start, end);
      if (!validation.valid) {
        return res.status(400).json({
          success: false,
          error: validation.error
        });
      }

      // Normalize time format (ensure HH:MM with leading zeros)
      activeHoursStart = normalizeTimeFormat(start);
      activeHoursEnd = normalizeTimeFormat(end);

      console.log("Active hours validated for update:", {
        start: activeHoursStart,
        end: activeHoursEnd
      });
    }

    const client = await getDatabaseConnection();

    if (!client) {
      console.error("Failed to get database connection - aborting update");
      return res
        .status(500)
        .json({ error: "Failed to update scheduled message" });
    }

    try {
      await client.query("BEGIN");

      // Get existing message to access its properties
      const existingMessageQuery =
        "SELECT * FROM scheduled_messages WHERE id = $1 AND company_id = $2";
      const existingMessageResult = await client.query(existingMessageQuery, [
        messageId,
        companyId,
      ]);

      if (existingMessageResult.rowCount === 0) {
        console.log("Scheduled message not found");
        return res.status(404).json({
          success: false,
          error: "Scheduled message not found",
        });
      }

      const existingMessage = existingMessageResult.rows[0];

      // Do not delete any records - we will update them all instead
      console.log("Updating all messages with schedule_id:", messageId);

      // We'll only update the content-related fields that can be changed in the frontend
      // Keeping the batch structure, recipients, and scheduling intact
      const updateQuery = `
        UPDATE scheduled_messages SET
          message_content = $1,
          media_url = $2,
          is_media = $3,
          document_url = $4,
          file_name = $5,
          caption = $6,
          status = $7,
          active_hours_start = $8,
          active_hours_end = $9
        WHERE (id::text = $10::text OR schedule_id::text = $10::text) AND company_id = $11
      `;

      const isMediaMessage = Boolean(
        updatedMessage.mediaUrl || updatedMessage.documentUrl
      );
      const messageCaption =
        updatedMessage.caption || updatedMessage.message || "";

      console.log(
        "Updating content for all scheduled message records with schedule_id:",
        messageId
      );
      await client.query(updateQuery, [
        updatedMessage.message || null,
        updatedMessage.mediaUrl || null,
        isMediaMessage,
        updatedMessage.documentUrl || null,
        updatedMessage.fileName || null,
        messageCaption,
        updatedMessage.status || "scheduled",
        activeHoursStart,
        activeHoursEnd,
        messageId,
        companyId,
      ]);

      // No need to modify the queue jobs or recreate batches
      // Just update the content of the existing messages
      // The existing job scheduling remains intact

      // If the status has changed to something other than "scheduled",
      // we should remove any pending jobs from the queue
      if (updatedMessage.status && updatedMessage.status !== "scheduled") {
        console.log(
          `Message status changed to ${updatedMessage.status}, removing jobs from queue if they exist`
        );

        // Get all batch IDs associated with this message
        const batchesQuery =
          "SELECT id FROM scheduled_messages WHERE (id::text = $1::text OR schedule_id::text = $1::text) AND company_id = $2";
        const batchesResult = await client.query(batchesQuery, [
          messageId,
          companyId,
        ]);
        const batchIds = batchesResult.rows.map((row) => row.id);

        // Remove jobs from queue
        const queue = getQueueForBot(companyId);
        for (const id of batchIds) {
          try {
            await queue.remove(id);
            console.log(`Removed job with ID ${id} from queue`);
          } catch (e) {
            // Job might not exist, which is fine
            console.log(
              `Job with ID ${id} not found in queue or already processed`
            );
          }
        }
      } else {
        console.log(
          "Message status remains 'scheduled', keeping existing jobs in the queue"
        );
      }

      await client.query("COMMIT");

      console.log("Scheduled message updated successfully:", messageId);
      res.json({
        id: messageId,
        message: "Message updated successfully",
        success: true,
      });
    } catch (error) {
      await safeRollback(client);
      console.error(
        "Error during scheduled message update transaction:",
        error
      );
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error updating scheduled message:", error);
    res.status(500).json({ error: "Failed to update scheduled message" });
  }
});

// DELETE endpoint to remove a scheduled message
app.delete("/api/schedule-message/:companyId/:messageId", async (req, res) => {
  const { companyId, messageId } = req.params;

  try {
    const client = await getDatabaseConnection();

    if (!client) {
      console.error("Failed to get database connection - aborting delete");
      return res
        .status(500)
        .json({ error: "Failed to delete scheduled message" });
    }

    try {
      await client.query("BEGIN");

      const checkQuery =
        "SELECT id FROM scheduled_messages WHERE schedule_id::text = $1::text AND company_id = $2";
      const checkResult = await client.query(checkQuery, [
        messageId,
        companyId,
      ]);

      if (checkResult.rowCount === 0) {
        return res.status(404).json({
          success: false,
          error: "Scheduled message not found",
        });
      }

      // First, get all batch IDs associated with this message for queue job removal
      const getBatchesQuery =
        "SELECT id FROM scheduled_messages WHERE (id::text = $1::text OR schedule_id::text = $1::text) AND company_id = $2";
      const batchesResult = await client.query(getBatchesQuery, [
        messageId,
        companyId,
      ]);

      const batchIds = batchesResult.rows.map((row) => row.id);

      // Delete the message records from database
      const deleteQuery =
        "DELETE FROM scheduled_messages WHERE (id::text = $1::text OR schedule_id::text = $1::text) AND company_id = $2";
      const deleteResult = await client.query(deleteQuery, [
        messageId,
        companyId,
      ]);

      // Get the queue and remove all related jobs
      const queue = getQueueForBot(companyId);

      // Remove main message job if it exists
      await queue.removeRepeatableByKey(messageId);
      try {
        await queue.remove(messageId);
      } catch (e) {
        // Job might not exist, which is fine
        console.log(
          `Job with ID ${messageId} not found in queue or already processed`
        );
      }

      // Remove all batch jobs if they exist
      for (const batchId of batchIds) {
        if (batchId !== messageId) {
          try {
            await queue.remove(batchId);
          } catch (e) {
            // Job might not exist, which is fine
            console.log(
              `Batch job with ID ${batchId} not found in queue or already processed`
            );
          }
        }
      }

      await client.query("COMMIT");

      res.json({
        id: messageId,
        message: "Message deleted successfully",
        success: true,
        batchesDeleted: deleteResult.rowCount - 1,
        jobsRemoved: batchIds.length,
      });
    } catch (error) {
      await safeRollback(client);
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error deleting scheduled message:", error);
    res.status(500).json({
      success: false,
      error: error.message || "Failed to delete scheduled message",
    });
  }
});

// DELETE endpoint to remove scheduled messages by template_id
app.delete(
  "/api/schedule-message/:companyId/template/:templateId/contact/:contactId",
  async (req, res) => {
    const { companyId, templateId, contactId } = req.params;

    try {
      const client = await getDatabaseConnection();

      if (!client) {
        console.error("Failed to get database connection - aborting delete");
        return res
          .status(500)
          .json({ error: "Failed to delete scheduled messages" });
      }

      try {
        await client.query("BEGIN");

        // Find all scheduled messages for this template and contact
        const findQuery = `
        SELECT id FROM scheduled_messages
        WHERE company_id = $1
          AND template_id = $2
          AND (
            contact_id = $3
            OR (contact_ids IS NOT NULL AND contact_ids::jsonb ? $3)
          )
      `;
        const findResult = await client.query(findQuery, [
          companyId,
          templateId,
          contactId,
        ]);
        const messageIds = findResult.rows.map((row) => row.id);

        if (messageIds.length === 0) {
          await client.query("ROLLBACK");
          return res.status(404).json({
            success: false,
            error: "No scheduled messages found for this template and contact",
          });
        }

        // Delete from database
        const deleteQuery = `
        DELETE FROM scheduled_messages
        WHERE company_id = $1
          AND template_id = $2
          AND (
            contact_id = $3
            OR (contact_ids IS NOT NULL AND contact_ids::jsonb ? $3)
          )
      `;
        const deleteResult = await client.query(deleteQuery, [
          companyId,
          templateId,
          contactId,
        ]);

        // Remove jobs from queue
        const queue = getQueueForBot(companyId);
        for (const id of messageIds) {
          try {
            await queue.remove(id);
          } catch (e) {
            // Job might not exist, which is fine
          }
        }

        await client.query("COMMIT");

        res.json({
          success: true,
          deletedCount: deleteResult.rowCount,
          jobsRemoved: messageIds.length,
          message: `Deleted ${deleteResult.rowCount} scheduled message(s) for template and contact`,
        });
      } catch (error) {
        await client.query("ROLLBACK");
        throw error;
      } finally {
        client.release();
      }
    } catch (error) {
      console.error(
        "Error deleting scheduled messages by template/contact:",
        error
      );
      res.status(500).json({
        success: false,
        error: error.message || "Failed to delete scheduled messages",
      });
    }
  }
);

app.post(
  "/api/schedule-message/:companyId/:messageId/stop",
  async (req, res) => {
    const { companyId, messageId } = req.params;

    try {
      const client = await getDatabaseConnection();

      if (!client) {
        console.error("Failed to get database connection - aborting stop");
        return res.status(500).json({ error: "Failed to stop message" });
      }

      try {
        await client.query("BEGIN");

        const updateQuery = `
        UPDATE scheduled_messages 
        SET 
          status = 'stopped',
          stopped_at = NOW()
        WHERE id = $1 AND company_id = $2
        RETURNING id
      `;

        const result = await client.query(updateQuery, [messageId, companyId]);

        if (result.rowCount === 0) {
          return res.status(404).json({
            success: false,
            error: "Scheduled message not found",
          });
        }

        const updateBatchesQuery = `
        UPDATE scheduled_messages 
        SET 
          status = 'stopped',
          stopped_at = NOW()
        WHERE schedule_id::text = $1::text 
          AND company_id = $2
          AND status = 'scheduled'
      `;

        await client.query(updateBatchesQuery, [messageId, companyId]);

        await client.query("COMMIT");

        const queue = getQueueForBot(companyId);
        const jobs = await queue.getJobs(["waiting", "delayed", "active"]);

        for (const job of jobs) {
          if (job.data.messageId === messageId) {
            try {
              await job.remove();
              console.log(`Removed job ${job.id} for message ${messageId}`);
            } catch (err) {
              console.error(`Failed to remove job ${job.id}:`, err);
            }
          }
        }

        res.json({
          success: true,
          message: "Message stopped successfully",
        });
      } catch (error) {
        await safeRollback(client);
        throw error;
      } finally {
        await safeRelease(client);
      }
    } catch (error) {
      console.error("Error stopping message:", error);
      res.status(500).json({
        success: false,
        error: "Failed to stop message",
        details: error.message,
      });
    }
  }
);

// New route for syncing contacts
app.post("/api/sync-contacts/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const { phoneIndex } = req.body;

  try {
    const botData = botMap.get(companyId);
    if (!botData) {
      return res
        .status(404)
        .json({ error: "WhatsApp client not found for this company" });
    }

    let syncPromises = [];

    if (botData.length === 1) {
      const client = botData[0].client;
      if (!client) {
        return res
          .status(404)
          .json({ error: "WhatsApp client not found for this company" });
      }
      syncPromises.push(syncContacts(client, companyId, 0));
    } else if (phoneIndex !== undefined) {
      if (phoneIndex < 0 || phoneIndex >= botData.length) {
        return res.status(400).json({ error: "Invalid phone index" });
      }
      const client = botData[phoneIndex].client;
      if (!client) {
        return res.status(404).json({
          error: `WhatsApp client not found for phone index ${phoneIndex}`,
        });
      }
      syncPromises.push(syncContacts(client, companyId, phoneIndex));
    } else {
      syncPromises = botData
        .map((data, index) => {
          if (data.client) {
            return syncContacts(data.client, companyId, index);
          }
        })
        .filter(Boolean);
    }

    if (syncPromises.length === 0) {
      return res
        .status(404)
        .json({ error: "No valid WhatsApp clients found for synchronization" });
    }

    // Start syncing process for all applicable clients
    syncPromises.forEach((promise, index) => {
      promise
        .then(() => {
          console.log(
            `Contact synchronization completed for company ${companyId}, phone ${index}`
          );
        })
        .catch((error) => {
          console.error(
            `Error during contact sync for company ${companyId}, phone ${index}:`,
            error
          );
        });
    });

    res.json({
      success: true,
      message: "Contact synchronization started",
      phonesToSync: syncPromises.length,
    });
  } catch (error) {
    console.error(`Error starting contact sync for ${companyId}:`, error);
    res.status(500).json({ error: "Failed to start contact synchronization" });
  }
});

// New route for syncing only contact names for all contacts
app.post("/api/sync-contact-names/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const { phoneIndex } = req.body;

  try {
    const botData = botMap.get(companyId);
    if (!botData) {
      return res
        .status(404)
        .json({ error: "WhatsApp client not found for this company" });
    }

    let syncPromises = [];

    if (botData.length === 1) {
      const client = botData[0].client;
      if (!client) {
        return res
          .status(404)
          .json({ error: "WhatsApp client not found for this company" });
      }
      syncPromises.push(syncContactNames(client, companyId, 0));
    } else if (phoneIndex !== undefined) {
      if (phoneIndex < 0 || phoneIndex >= botData.length) {
        return res.status(400).json({ error: "Invalid phone index" });
      }
      const client = botData[phoneIndex].client;
      if (!client) {
        return res.status(404).json({
          error: `WhatsApp client not found for phone index ${phoneIndex}`,
        });
      }
      syncPromises.push(syncContactNames(client, companyId, phoneIndex));
    } else {
      syncPromises = botData
        .map((data, index) => {
          if (data.client) {
            return syncContactNames(data.client, companyId, index);
          }
        })
        .filter(Boolean);
    }

    if (syncPromises.length === 0) {
      return res
        .status(404)
        .json({ error: "No valid WhatsApp clients found for synchronization" });
    }

    // Start syncing process for all applicable clients
    syncPromises.forEach((promise, index) => {
      promise
        .then(() => {
          console.log(
            `Contact names synchronization completed for company ${companyId}, phone ${index}`
          );
        })
        .catch((error) => {
          console.error(
            `Error during contact names sync for company ${companyId}, phone ${index}:`,
            error
          );
        });
    });

    res.json({
      success: true,
      message: "Contact names synchronization started",
      phonesToSync: syncPromises.length,
    });
  } catch (error) {
    console.error(`Error starting contact names sync for ${companyId}:`, error);
    res
      .status(500)
      .json({ error: "Failed to start contact names synchronization" });
  }
});

// New route for syncing single contact with messages
app.post("/api/sync-single-contact/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const { phoneIndex, contactPhone } = req.body;

  if (!contactPhone) {
    return res.status(400).json({ error: "Contact phone number is required" });
  }

  try {
    const botData = botMap.get(companyId);
    if (!botData) {
      return res
        .status(404)
        .json({ error: "WhatsApp client not found for this company" });
    }

    const selectedPhoneIndex = phoneIndex !== undefined ? phoneIndex : 0;

    if (selectedPhoneIndex < 0 || selectedPhoneIndex >= botData.length) {
      return res.status(400).json({ error: "Invalid phone index" });
    }

    const client = botData[selectedPhoneIndex].client;
    if (!client) {
      return res.status(404).json({
        error: `WhatsApp client not found for phone index ${selectedPhoneIndex}`,
      });
    }

    try {
      await syncSingleContact(
        client,
        companyId,
        contactPhone,
        selectedPhoneIndex
      );
      console.log(
        `Single contact synchronization completed for company ${companyId}, phone ${selectedPhoneIndex}, contact ${contactPhone}`
      );
      res.json({
        success: true,
        message: "Single contact synchronization finished",
        contactPhone,
        phoneIndex: selectedPhoneIndex,
      });
    } catch (error) {
      console.error(
        `Error during single contact sync for company ${companyId}, phone ${selectedPhoneIndex}, contact ${contactPhone}:`,
        error
      );
      res.status(500).json({
        error: "Failed to sync single contact",
        details: error.message,
      });
    }
  } catch (error) {
    console.error(
      `Error starting single contact sync for ${companyId}:`,
      error
    );
    res
      .status(500)
      .json({ error: "Failed to start single contact synchronization" });
  }
});

// New route for syncing single contact name only
app.post("/api/sync-single-contact-name/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const { phoneIndex, contactPhone } = req.body;

  if (!contactPhone) {
    return res.status(400).json({ error: "Contact phone number is required" });
  }

  try {
    const botData = botMap.get(companyId);
    if (!botData) {
      return res
        .status(404)
        .json({ error: "WhatsApp client not found for this company" });
    }

    const selectedPhoneIndex = phoneIndex !== undefined ? phoneIndex : 0;

    if (selectedPhoneIndex < 0 || selectedPhoneIndex >= botData.length) {
      return res.status(400).json({ error: "Invalid phone index" });
    }

    const client = botData[selectedPhoneIndex].client;
    if (!client) {
      return res.status(404).json({
        error: `WhatsApp client not found for phone index ${selectedPhoneIndex}`,
      });
    }

    try {
      await syncSingleContactName(
        client,
        companyId,
        contactPhone,
        selectedPhoneIndex
      );
      console.log(
        `Single contact name synchronization completed for company ${companyId}, phone ${selectedPhoneIndex}, contact ${contactPhone}`
      );
      res.json({
        success: true,
        message: "Single contact name synchronization finished",
        contactPhone,
        phoneIndex: selectedPhoneIndex,
      });
    } catch (error) {
      console.error(
        `Error during single contact name sync for company ${companyId}, phone ${selectedPhoneIndex}, contact ${contactPhone}:`,
        error
      );
      res.status(500).json({
        error: "Failed to sync single contact name",
        details: error.message,
      });
    }
  } catch (error) {
    console.error(
      `Error starting single contact name sync for ${companyId}:`,
      error
    );
    res
      .status(500)
      .json({ error: "Failed to start single contact name synchronization" });
  }
});

app.get("/api/search-messages/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const {
    query,
    contactId,
    dateFrom,
    dateTo,
    messageType,
    fromMe,
    page = 1,
    limit = 50,
  } = req.query;

  if (!query) {
    return res.status(400).json({ error: "Search query is required" });
  }

  // Build SQL WHERE conditions
  let whereClauses = ["company_id = $1", "content ILIKE $2"];
  let values = [companyId, `%${query}%`];
  let idx = 3;

  if (contactId) {
    whereClauses.push(`contact_id = $${idx++}`);
    values.push(contactId);
  }
  if (dateFrom) {
    whereClauses.push(`timestamp >= to_timestamp($${idx++})`);
    values.push(dateFrom);
  }
  if (dateTo) {
    whereClauses.push(`timestamp <= to_timestamp($${idx++})`);
    values.push(dateTo);
  }
  if (messageType) {
    whereClauses.push(`type = $${idx++}`);
    values.push(messageType);
  }
  if (fromMe !== undefined) {
    whereClauses.push(`from_me = $${idx++}`);
    values.push(fromMe === "true");
  }

  const offset = (page - 1) * limit;

  const whereSQL = whereClauses.length
    ? "WHERE " + whereClauses.join(" AND ")
    : "";

  try {
    // Get total count for pagination
    const countResult = await sqlDb.query(
      `SELECT COUNT(*) FROM messages ${whereSQL}`,
      values
    );
    const total = parseInt(countResult.rows[0].count, 10);

    // Get paginated results
    const resultsResult = await sqlDb.query(
      `
      SELECT * FROM messages
      ${whereSQL}
      ORDER BY timestamp DESC
      LIMIT $${idx++} OFFSET $${idx}
      `,
      [...values, limit, offset]
    );

    res.json({
      total,
      page: parseInt(page),
      totalPages: Math.ceil(total / limit),
      results: resultsResult.rows,
    });
  } catch (error) {
    console.error("Error searching messages:", error);
    res.status(500).json({ error: "Failed to search messages" });
  }
});

app.get("/api/stats/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const { employeeId } = req.query;
  const monthKey = getCurrentMonthKey();

  if (!employeeId) {
    return res.status(400).json({ error: "Employee ID is required" });
  }

  try {
    const employeeQuery = `
      SELECT id, name, role, weightages
      FROM employees 
      WHERE employee_id = $1 AND company_id = $2
    `;
    const employeeResult = await pool.query(employeeQuery, [
      employeeId,
      companyId,
    ]);

    if (employeeResult.rows.length === 0) {
      return res
        .status(400)
        .json({ error: "No employee found with the given ID" });
    }

    const employee = employeeResult.rows[0];

    const stats = {
      employeeName: employee.name,
      employeeRole: employee.role,
      conversationsAssigned: 0,
      outgoingMessagesSent: 0,
      averageResponseTime: 0,
      closedContacts: 0,
      currentMonthAssignments: 0,
      weightageUsed: employee.weightages || {},
      phoneAssignments: {},
      responseTimes: [],
      medianResponseTime: [],
    };

    const assignmentsQuery = `
      SELECT COUNT(*) as count
      FROM assignments
      WHERE employee_id = $1 
        AND company_id = $2
        AND month_key = $3
    `;
    const assignmentsResult = await pool.query(assignmentsQuery, [
      employeeId,
      companyId,
      monthKey,
    ]);
    stats.currentMonthAssignments =
      parseInt(assignmentsResult.rows[0].count) || 0;

    const assignedContactsQuery = `
      SELECT a.contact_id, c.tags
      FROM assignments a
      LEFT JOIN contacts c ON a.contact_id = c.contact_id AND a.company_id = c.company_id
      WHERE a.employee_id = $1 AND a.company_id = $2
    `;
    const assignedContactsResult = await pool.query(assignedContactsQuery, [
      employeeId,
      companyId,
    ]);
    stats.conversationsAssigned = assignedContactsResult.rows.length;

    if (assignedContactsResult.rows.length === 0) {
      return res.json(stats);
    }

    const closedContacts = assignedContactsResult.rows.filter((row) => {
      try {
        const tags = row.tags || [];
        return tags.includes("closed");
      } catch (e) {
        return false;
      }
    });
    stats.closedContacts = closedContacts.length;

    let totalResponseTime = 0;
    let responseCount = 0;
    let outgoingMessages = 0;

    for (const row of assignedContactsResult.rows) {
      const contactId = row.contact_id;

      const messagesQuery = `
        SELECT timestamp, from_me
        FROM messages
        WHERE company_id = $1 AND contact_id = $2
        ORDER BY timestamp ASC
      `;
      const messagesResult = await pool.query(messagesQuery, [
        companyId,
        contactId,
      ]);

      outgoingMessages += messagesResult.rows.filter(
        (msg) => msg.from_me
      ).length;

      let firstAgentMessageTime = null;
      let firstCustomerMessageTime = null;

      for (const message of messagesResult.rows) {
        const timestamp = new Date(message.timestamp).getTime();

        if (message.from_me) {
          if (!firstAgentMessageTime) {
            firstAgentMessageTime = timestamp;
          }
        } else if (!firstCustomerMessageTime) {
          firstCustomerMessageTime = timestamp;
        }

        if (firstAgentMessageTime && firstCustomerMessageTime) {
          const responseTime = Math.abs(
            firstAgentMessageTime - firstCustomerMessageTime
          );
          stats.responseTimes.push({
            contactId,
            responseTime,
            timestamp: message.timestamp,
          });
          totalResponseTime += responseTime;
          responseCount++;
          break;
        }
      }
    }

    stats.outgoingMessagesSent = outgoingMessages;

    if (responseCount > 0) {
      stats.averageResponseTime = Math.floor(totalResponseTime / responseCount);

      const sortedTimes = stats.responseTimes
        .map((rt) => rt.responseTime)
        .sort((a, b) => a - b);
      const mid = Math.floor(sortedTimes.length / 2);
      stats.medianResponseTime =
        sortedTimes.length % 2 !== 0
          ? sortedTimes[mid]
          : (sortedTimes[mid - 1] + sortedTimes[mid]) / 2;
    }

    const metricsQuery = `
      SELECT 
        phone_index,
        COUNT(*) as assignment_count
      FROM assignments
      WHERE employee_id = $1 
        AND company_id = $2
        AND month_key = $3
      GROUP BY phone_index
    `;
    const metricsResult = await pool.query(metricsQuery, [
      employeeId,
      companyId,
      monthKey,
    ]);

    metricsResult.rows.forEach((row) => {
      stats.phoneAssignments[`phone${row.phone_index}`] =
        parseInt(row.assignment_count) || 0;
    });

    res.json(stats);
  } catch (error) {
    console.error("Error fetching stats:", error);
    res.status(500).json({
      error: "Failed to fetch stats",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
});

// Helper function
function getCurrentMonthKey() {
  const date = new Date();
  const month = date.toLocaleString("default", { month: "short" });
  const year = date.getFullYear();
  return `${month}-${year}`;
}

// ... existing code ...

function mapFirestoreContactToNeon(contact, companyId) {
  // Fix timestamp handling for last_message
  if (contact.last_message && contact.last_message.timestamp) {
    const timestamp = contact.last_message.timestamp;
    let timestampMs;

    // Handle different timestamp formats
    if (typeof timestamp === "string") {
      // Try to parse as ISO string first
      const parsedDate = new Date(timestamp);
      if (!isNaN(parsedDate.getTime())) {
        timestampMs = parsedDate.getTime();
      } else {
        // If it's an invalid string, use current time
        timestampMs = Date.now();
      }
    } else if (typeof timestamp === "number") {
      // Check if it's seconds or milliseconds
      timestampMs = timestamp < 1000000000000 ? timestamp * 1000 : timestamp;
    } else {
      // Fallback to current time
      timestampMs = Date.now();
    }

    const messageDate = new Date(timestampMs);
    const now = new Date();

    // If timestamp is in the future or invalid, use current time
    if (messageDate > now || isNaN(messageDate.getTime())) {
      timestampMs = Date.now();
    }

    // Update the timestamp in the contact data
    contact.last_message.timestamp = timestampMs;
  }

  // Handle customFields properly
  let customFieldsJson = null;
  if (contact.customFields) {
    // If customFields is already an object, stringify it
    if (
      typeof contact.customFields === "object" &&
      contact.customFields !== null
    ) {
      customFieldsJson = JSON.stringify(contact.customFields);
    } else if (typeof contact.customFields === "string") {
      // If it's already a string, use it as is
      customFieldsJson = contact.customFields;
    }
  }

  // ... existing code ...
  return {
    contact_id: companyId + "-" + contact.phone.split("+")[1] || null,
    company_id: companyId,
    name: contact.name || contact.contactName || null,
    contact_name: contact.contactName || contact.name || null,
    phone: contact.phone || null,
    email: contact.email || null,
    phone_index: contact.phoneIndex || 0,
    chat_id: contact.chat_id || contact.id || null,
    tags: JSON.stringify(contact.tags || []),
    unread_count: contact.unreadCount || 0,
    last_message: contact.last_message
      ? JSON.stringify({
          ...contact.last_message,
          phone_index: contact.last_message.phoneIndex || 0,
          timestamp: contact.last_message.timestamp,
        })
      : null,
    profile_pic_url: contact.profilePicUrl || null,
    not_spam: contact.not_spam || false,
    pinned: contact.pinned || false,
    address1: contact.address1 || null,
    assigned_to: contact.assignedTo || null,
    business_id: contact.businessId || null,
    thread_id: contact.threadid || contact.thread_id || null,
    branch: contact.branch || null,
    expiry_date: contact.expiryDate || null,
    vehicle_number: contact.vehicleNumber || null,
    ic: contact.ic || null,
    lead_number: contact.leadNumber || null,
    custom_fields: customFieldsJson,
    created_at: new Date(),
    updated_at: new Date(),
  };
  // ... existing code ...
}
// ... existing code ...

function mapFirestoreMessageToNeon(msg, companyId, contactId) {
  // Fix timestamp handling for messages
  let messageTimestamp;

  if (msg.timestamp) {
    if (typeof msg.timestamp === "string") {
      // Try to parse as ISO string first
      const parsedDate = new Date(msg.timestamp);
      if (!isNaN(parsedDate.getTime())) {
        messageTimestamp = parsedDate;
      } else {
        // If it's an invalid string, use current time
        messageTimestamp = new Date();
      }
    } else if (typeof msg.timestamp === "number") {
      // Check if it's seconds or milliseconds
      const timestampMs =
        msg.timestamp < 1000000000000 ? msg.timestamp * 1000 : msg.timestamp;
      messageTimestamp = new Date(timestampMs);
    } else {
      // Fallback to current time
      messageTimestamp = new Date();
    }

    // Validate the timestamp
    if (isNaN(messageTimestamp.getTime()) || messageTimestamp > new Date()) {
      messageTimestamp = new Date();
    }
  } else {
    messageTimestamp = new Date();
  }

  // Handle different message types and extract content appropriately
  let content = "";
  let mediaUrl = null;
  let mediaData = null;
  let mediaMetadata = null;
  let messageType = msg.type || "text";

  // Handle image messages - check multiple possible structures
  if (msg.type === "image") {
    // Check if image data is in msg.image object
    if (msg.image) {
      content = msg.image.caption || "";
      mediaUrl = msg.image.data || null;
      mediaData = msg.image.data || null;
      mediaMetadata = {
        filename: msg.image.filename || "",
        height: msg.image.height || null,
        width: msg.image.width || null,
        mimetype: msg.image.mimetype || "image/jpeg",
        mediaKey: msg.image.mediaKey || null,
      };
    }
    // Check if image data is directly in msg
    else if (msg.data) {
      // console.log(`Found image data directly in msg.data`);
      content = msg.caption || "";
      mediaUrl = msg.data || null;
      mediaData = msg.data || null;
      mediaMetadata = {
        filename: msg.filename || "",
        height: msg.height || null,
        width: msg.width || null,
        mimetype: msg.mimetype || "image/jpeg",
        mediaKey: msg.mediaKey || null,
      };
    }
    // Check if image data is in msg.text (some structures have this)
    else if (msg.text && msg.text.data) {
      //console.log(`Found image data in msg.text.data`);
      content = msg.text.body || "";
      mediaUrl = msg.text.data || null;
      mediaData = msg.text.data || null;
      mediaMetadata = {
        filename: msg.text.filename || "",
        height: msg.text.height || null,
        width: msg.text.width || null,
        mimetype: msg.text.mimetype || "image/jpeg",
        mediaKey: msg.text.mediaKey || null,
      };
    }
    // If no image data found, treat as text with image type
    else {
      // console.log(`No image data found, treating as text with image type`);
      content = msg.text?.body || msg.body || "";
      messageType = "text"; // Change to text since no media data
    }
    messageType = "image";
  }
  // Handle document messages
  else if (msg.type === "document") {
    // console.log(`Processing document message: ${msg.id}`);

    if (msg.document) {
      // console.log(`Found document data in msg.document:`, msg.document);
      content = msg.document.caption || "";
      mediaUrl = msg.document.data || null;
      mediaData = msg.document.data || null;
      mediaMetadata = {
        filename: msg.document.filename || "",
        mimetype: msg.document.mimetype || "application/octet-stream",
        mediaKey: msg.document.mediaKey || null,
      };
    } else if (msg.data) {
      //console.log(`Found document data directly in msg.data`);
      content = msg.caption || "";
      mediaUrl = msg.data || null;
      mediaData = msg.data || null;
      mediaMetadata = {
        filename: msg.filename || "",
        mimetype: msg.mimetype || "application/octet-stream",
        mediaKey: msg.mediaKey || null,
      };
    } else {
      //console.log(`No document data found, treating as text with document type`);
      content = msg.text?.body || msg.body || "";
      messageType = "text"; // Change to text since no media data
    }
    messageType = "document";
  }
  // Handle video messages
  else if (msg.type === "video") {
    // console.log(`Processing video message: ${msg.id}`);

    if (msg.video) {
      //  console.log(`Found video data in msg.video:`, msg.video);
      content = msg.video.caption || "";
      mediaUrl = msg.video.data || null;
      mediaData = msg.video.data || null;
      mediaMetadata = {
        filename: msg.video.filename || "",
        height: msg.video.height || null,
        width: msg.video.width || null,
        mimetype: msg.video.mimetype || "video/mp4",
        mediaKey: msg.video.mediaKey || null,
      };
    } else if (msg.data) {
      // console.log(`Found video data directly in msg.data`);
      content = msg.caption || "";
      mediaUrl = msg.data || null;
      mediaData = msg.data || null;
      mediaMetadata = {
        filename: msg.filename || "",
        height: msg.height || null,
        width: msg.width || null,
        mimetype: msg.mimetype || "video/mp4",
        mediaKey: msg.mediaKey || null,
      };
    } else {
      // console.log(`No video data found, treating as text with video type`);
      content = msg.text?.body || msg.body || "";
      messageType = "text"; // Change to text since no media data
    }
    messageType = "video";
  }
  // Handle audio messages
  else if (msg.type === "audio") {
    // console.log(`Processing audio message: ${msg.id}`);

    if (msg.audio) {
      // console.log(`Found audio data in msg.audio:`, msg.audio);
      content = msg.audio.caption || "";
      mediaUrl = msg.audio.data || null;
      mediaData = msg.audio.data || null;
      mediaMetadata = {
        filename: msg.audio.filename || "",
        mimetype: msg.audio.mimetype || "audio/ogg",
        mediaKey: msg.audio.mediaKey || null,
      };
    } else if (msg.data) {
      // console.log(`Found audio data directly in msg.data`);
      content = msg.caption || "";
      mediaUrl = msg.data || null;
      mediaData = msg.data || null;
      mediaMetadata = {
        filename: msg.filename || "",
        mimetype: msg.mimetype || "audio/ogg",
        mediaKey: msg.mediaKey || null,
      };
    } else {
      // console.log(`No audio data found, treating as text with audio type`);
      content = msg.text?.body || msg.body || "";
      messageType = "text"; // Change to text since no media data
    }
    messageType = "audio";
  }
  // Handle text messages
  else {
    content = msg.text?.body || msg.body || "";
    messageType = "text";
  }

  return {
    message_id: msg.id || msg.message_id || null,
    company_id: companyId,
    contact_id: contactId,
    content: content,
    message_type: messageType,
    media_url: mediaUrl,
    media_data: mediaData,
    media_metadata: mediaMetadata ? JSON.stringify(mediaMetadata) : null,
    timestamp: messageTimestamp,
    direction: msg.from_me ? "outbound" : "inbound",
    status: msg.status || "delivered",
    from_me: msg.from_me || false,
    chat_id: msg.chat_id || null,
    author: msg.author || null,
    phone_index: msg.phoneIndex || 0,
    quoted_message: msg.quoted_message
      ? JSON.stringify(msg.quoted_message)
      : null,
    thread_id: msg.threadid || msg.thread_id || null,
    customer_phone: msg.customer_phone || null,
    created_at: new Date(),
    updated_at: new Date(),
  };
}

// ... existing code ...

// ... existing code ...
async function syncContactsFromFirebaseToNeon(companyId, phoneIndex = 0) {
  console.log(
    `=== Starting Firebase to Neon sync for company: ${companyId}, phone: ${phoneIndex} ===`
  );

  try {
    const contactsRef = db
      .collection("companies")
      .doc(companyId)
      .collection("contacts");
    const contactsSnapshot = await contactsRef.get();
    console.log(`Found ${contactsSnapshot.docs.length} contacts in Firestore`);

    let processedContacts = 0;
    let processedMessages = 0;
    let processedPrivateNotes = 0;
    let errors = [];

    // Process contacts in batches of 10 concurrently
    const batchSize = 10;
    const contactBatches = [];

    for (let i = 0; i < contactsSnapshot.docs.length; i += batchSize) {
      contactBatches.push(contactsSnapshot.docs.slice(i, i + batchSize));
    }

    for (let batchIndex = 0; batchIndex < contactBatches.length; batchIndex++) {
      const batch = contactBatches[batchIndex];
      console.log(
        `Processing batch ${batchIndex + 1}/${contactBatches.length} (${
          batch.length
        } contacts)`
      );

      // Process contacts in current batch concurrently
      const contactPromises = batch.map(async (doc) => {
        try {
          const contact = doc.data();
          let contactId = contact.contact_id || contact.id || doc.id;
          if (!contactId) {
            console.warn(
              `Skipping contact with missing contact_id. Firestore doc ID: ${doc.id}`
            );
            errors.push({ type: "missing_contact_id", docId: doc.id });
            return { processed: false };
          }

          const neonContact = mapFirestoreContactToNeon(contact, companyId);
          console.log(
            `---> Syncing contact: ${neonContact.contact_id} (Firestore doc ID: ${doc.id})`
          );

          if (!neonContact.contact_id || !neonContact.company_id) {
            console.warn(
              `Skipping contact with missing required fields. contact_id: ${neonContact.contact_id}, company_id: ${neonContact.company_id}`
            );
            errors.push({
              type: "missing_required_fields",
              contactId,
              neonContact,
            });
            return { processed: false };
          }

          // Upsert contact
          const contactFields = Object.keys(neonContact);
          const contactValues = Object.values(neonContact);
          const contactPlaceholders = contactFields.map((_, i) => `$${i + 1}`);
          const contactUpdateSet = contactFields
            .filter(
              (f) =>
                f !== "contact_id" &&
                f !== "company_id" &&
                f !== "created_at" &&
                f !== "updated_at"
            )
            .map((f) => `${f} = EXCLUDED.${f}`)
            .join(", ");

          const contactQuery = `
            INSERT INTO contacts (${contactFields.join(", ")})
            VALUES (${contactPlaceholders.join(", ")})
            ON CONFLICT (contact_id, company_id) DO UPDATE SET
            ${contactUpdateSet}${
            contactUpdateSet ? ", " : ""
          }updated_at = CURRENT_TIMESTAMP
          `;
          await sqlDb.query(contactQuery, contactValues);

          // Fetch and upsert messages for this contact
          const messagesRef = contactsRef.doc(doc.id).collection("messages");
          const messagesSnapshot = await messagesRef.get();

          // Limit to 50 messages max per contact
          const limitedMessages = messagesSnapshot.docs.slice(0, 50);

          if (limitedMessages.length > 0) {
            // Process messages in smaller batches of 10 concurrently
            const messageBatchSize = 10;
            const messageBatches = [];

            for (let j = 0; j < limitedMessages.length; j += messageBatchSize) {
              messageBatches.push(
                limitedMessages.slice(j, j + messageBatchSize)
              );
            }

            for (const messageBatch of messageBatches) {
              const messagePromises = messageBatch.map(async (msgDoc) => {
                try {
                  const msg = msgDoc.data();

                  // Handle private notes separately
                  if (msg.type === "privateNote") {
                    const neonNote = mapFirestorePrivateNoteToNeon(
                      msg,
                      companyId,
                      neonContact.contact_id
                    );

                    if (
                      !neonNote.id ||
                      !neonNote.company_id ||
                      !neonNote.contact_id
                    ) {
                      console.warn(
                        `  Skipping private note with missing required fields. id: ${neonNote.id}, company_id: ${neonNote.company_id}, contact_id: ${neonNote.contact_id}`
                      );
                      errors.push({
                        type: "missing_private_note_fields",
                        msgDocId: msgDoc.id,
                      });
                      return { processed: false };
                    }

                    // Upsert private note
                    const noteFields = Object.keys(neonNote);
                    const noteValues = Object.values(neonNote);
                    const notePlaceholders = noteFields.map(
                      (_, i) => `$${i + 1}`
                    );
                    const noteUpdateSet = noteFields
                      .filter(
                        (f) =>
                          f !== "id" &&
                          f !== "company_id" &&
                          f !== "created_at" &&
                          f !== "updated_at"
                      )
                      .map((f) => `${f} = EXCLUDED.${f}`)
                      .join(", ");

                    const noteQuery = `
                      INSERT INTO private_notes (${noteFields.join(", ")})
                      VALUES (${notePlaceholders.join(", ")})
                      ON CONFLICT (id) DO UPDATE SET
                      ${noteUpdateSet}${
                      noteUpdateSet ? ", " : ""
                    }updated_at = CURRENT_TIMESTAMP
                    `;
                    await sqlDb.query(noteQuery, noteValues);

                    // Also insert as a message for compatibility
                    const neonMsg = mapFirestoreMessageToNeon(
                      msg,
                      companyId,
                      neonContact.contact_id
                    );
                    const msgFields = Object.keys(neonMsg).filter(
                      (f) => f !== "updated_at"
                    );
                    const msgValues = msgFields.map((f) => neonMsg[f]);
                    const msgPlaceholders = msgFields.map(
                      (_, i) => `$${i + 1}`
                    );
                    const msgUpdateSet = msgFields
                      .filter(
                        (f) =>
                          f !== "message_id" &&
                          f !== "company_id" &&
                          f !== "created_at"
                      )
                      .map((f) => `${f} = EXCLUDED.${f}`)
                      .join(", ");

                    const msgQuery = `
                      INSERT INTO messages (${msgFields.join(", ")})
                      VALUES (${msgPlaceholders.join(", ")})
                      ON CONFLICT (message_id, company_id) DO UPDATE SET
                      ${msgUpdateSet}
                    `;
                    await sqlDb.query(msgQuery, msgValues);

                    return { processed: true, type: "private_note" };
                  } else {
                    // Handle regular messages
                    const neonMsg = mapFirestoreMessageToNeon(
                      msg,
                      companyId,
                      neonContact.contact_id
                    );

                    if (
                      !neonMsg.message_id ||
                      !neonMsg.company_id ||
                      !neonMsg.contact_id
                    ) {
                      console.warn(
                        `  Skipping message with missing required fields. message_id: ${neonMsg.message_id}, company_id: ${neonMsg.company_id}, contact_id: ${neonMsg.contact_id}`
                      );
                      errors.push({
                        type: "missing_message_fields",
                        msgDocId: msgDoc.id,
                      });
                      return { processed: false };
                    }

                    // Remove updated_at from both fields and values for messages
                    const msgFields = Object.keys(neonMsg).filter(
                      (f) => f !== "updated_at"
                    );
                    const msgValues = msgFields.map((f) => neonMsg[f]);
                    const msgPlaceholders = msgFields.map(
                      (_, i) => `$${i + 1}`
                    );
                    const msgUpdateSet = msgFields
                      .filter(
                        (f) =>
                          f !== "message_id" &&
                          f !== "company_id" &&
                          f !== "created_at"
                      )
                      .map((f) => `${f} = EXCLUDED.${f}`)
                      .join(", ");

                    const msgQuery = `
                      INSERT INTO messages (${msgFields.join(", ")})
                      VALUES (${msgPlaceholders.join(", ")})
                      ON CONFLICT (message_id, company_id) DO UPDATE SET
                      ${msgUpdateSet}
                    `;
                    await sqlDb.query(msgQuery, msgValues);
                    return { processed: true, type: "message" };
                  }
                } catch (msgError) {
                  console.error(
                    `  Error processing message ${msgDoc.id}: ${msgError.message}`
                  );
                  errors.push({
                    type: "message_error",
                    msgDocId: msgDoc.id,
                    error: msgError.message,
                  });
                  return { processed: false };
                }
              });

              // Wait for current message batch to complete
              const messageResults = await Promise.all(messagePromises);
              processedMessages += messageResults.filter(
                (r) => r.processed && r.type === "message"
              ).length;
              processedPrivateNotes += messageResults.filter(
                (r) => r.processed && r.type === "private_note"
              ).length;

              // Small delay between message batches
              await new Promise((resolve) => setTimeout(resolve, 100));
            }
          }

          return { processed: true };
        } catch (contactError) {
          console.error(
            `Error processing contact ${doc.id}: ${contactError.message}`
          );
          errors.push({
            type: "contact_error",
            docId: doc.id,
            error: contactError.message,
          });
          return { processed: false };
        }
      });

      // Wait for current contact batch to complete
      const contactResults = await Promise.all(contactPromises);
      processedContacts += contactResults.filter((r) => r.processed).length;

      // Small delay between contact batches
      await new Promise((resolve) => setTimeout(resolve, 200));
    }

    console.log(`=== Sync Summary ===`);
    console.log(
      `Processed: ${processedContacts} contacts, ${processedMessages} messages, ${processedPrivateNotes} private notes`
    );
    if (errors.length > 0) {
      console.warn(
        `Encountered ${errors.length} errors. See above for details.`
      );
    } else {
      console.log(`No errors encountered.`);
    }

    return {
      success: true,
      processedContacts,
      processedMessages,
      processedPrivateNotes,
      errors,
    };
  } catch (error) {
    console.error(`Fatal sync error: ${error.message}`);
    throw error;
  }
}
// ... existing code ...

// ... existing code ...

// ... existing code ...
app.post("/api/sync-firebase-to-neon/:companyId", async (req, res) => {
  const { companyId } = req.params;
  try {
    await syncContactsFromFirebaseToNeon(companyId);
    res.json({
      success: true,
      message: "Contacts and messages synced from Firebase to Neon.",
    });
  } catch (error) {
    console.error("Sync error:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});
async function getProfilePicUrl(contact) {
  if (!contact.getProfilePicUrl) {
    return "";
  }

  try {
    return (await contact.getProfilePicUrl()) || "";
  } catch (error) {
    console.error(
      `Error getting profile picture URL for ${contact.id.user}:`,
      error
    );
    return "";
  }
}
async function syncContacts(client, companyId, phoneIndex = 0) {
  try {
    const chats = await client.getChats();
    console.log(
      `Found ${chats.length} chats for company ${companyId}, phone ${phoneIndex}. Processing all chats.`
    );

    for (const chat of chats) {
      try {
        const contact = await chat.getContact();
        const contactPhone = contact.id.user;
        const contactID = `${companyId}-${contactPhone}`;

        const profilePicUrl = await getProfilePicUrl(contact);

        // Upsert contact
        const contactQuery = `
          INSERT INTO public.contacts (
            contact_id, company_id, name, phone, tags, unread_count, created_at, last_updated, 
            chat_data, company, chat_id, last_message, profile_pic_url
          ) VALUES ($1, $2, $3, $4, '[]'::jsonb, $5, NOW(), NOW(), $6, $7, $8, '{}'::jsonb, $9)
          ON CONFLICT (contact_id, company_id) DO UPDATE SET
            last_updated = NOW(),
            profile_pic_url = EXCLUDED.profile_pic_url,
            unread_count = EXCLUDED.unread_count,
            last_message = EXCLUDED.last_message,
            chat_data = EXCLUDED.chat_data;
        `;
        await sqlDb.query(contactQuery, [
          contactID,
          companyId,
          contact.name || contact.pushname || contact.shortName || contactPhone,
          contactPhone,
          chat.unreadCount,
          JSON.stringify(chat),
          contact.name,
          chat.id._serialized,
          profilePicUrl,
        ]);

        // Fetch and insert messages using the same method as addMessageToPostgres
        const messages = await chat.fetchMessages({ limit: 200 });
        let lastMessage = null;

        for (const msg of messages) {
          try {
            // Use the same comprehensive message saving as addMessageToPostgres
            const basicInfo = await extractBasicMessageInfo(msg);
            const messageData = await prepareMessageData(
              msg,
              companyId,
              phoneIndex
            );

            // Get message body (with audio transcription if applicable)
            let messageBody = messageData.text?.body || "";
            if (msg.hasMedia && (msg.type === "audio" || msg.type === "ptt")) {
              console.log("Voice message detected during sync");
              try {
                const media = await msg.downloadMedia();
                const transcription = await transcribeAudio(media.data);
                if (
                  transcription &&
                  transcription !==
                    "Audio transcription failed. Please try again."
                ) {
                  messageBody += transcription;
                } else {
                  messageBody += "Audio message";
                }
              } catch (error) {
                console.error("Error transcribing audio during sync:", error);
                messageBody += "Audio message";
              }
            }

            // Prepare media data
            let mediaUrl = null;
            let mediaData = null;
            let mediaMetadata = {};

            if (msg.hasMedia) {
              if (msg.type === "video") {
                mediaUrl = messageData.video?.link || null;
              } else if (msg.type !== "audio" && msg.type !== "ptt") {
                const mediaTypeData = messageData[msg.type];
                if (mediaTypeData) {
                  mediaData = mediaTypeData.data || null;
                  mediaUrl = mediaTypeData.link || null;
                  mediaMetadata = {
                    mimetype: mediaTypeData.mimetype,
                    filename: mediaTypeData.filename || "",
                    caption: mediaTypeData.caption || "",
                    thumbnail: mediaTypeData.thumbnail || null,
                    mediaKey: mediaTypeData.media_key || null,
                    ...(msg.type === "image" && {
                      width: mediaTypeData.width,
                      height: mediaTypeData.height,
                    }),
                    ...(msg.type === "document" && {
                      pageCount: mediaTypeData.page_count,
                      fileSize: mediaTypeData.file_size,
                    }),
                  };
                }
              } else if (msg.type === "audio" || msg.type === "ptt") {
                mediaData = messageData.audio?.data || null;
              }
            }

            // Prepare quoted message
            const quotedMessage = messageData.text?.context || null;

            // Determine author
            let author = null;
            if (msg.from.includes("@g.us") && basicInfo.author) {
              const authorData = await getContactDataFromDatabaseByPhone(
                basicInfo.author,
                companyId
              );
              author = authorData ? authorData.contactName : basicInfo.author;
            }

            const messageQuery = `
              INSERT INTO public.messages (
                message_id, company_id, contact_id, content, message_type,
                media_url, media_data, media_metadata, timestamp, direction,
                status, from_me, chat_id, author, phone_index, quoted_message,
                thread_id, customer_phone
              ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
              ON CONFLICT (message_id, company_id) DO NOTHING;
            `;

            await sqlDb.query(messageQuery, [
              basicInfo.idSerialized,
              companyId,
              contactID,
              messageBody,
              basicInfo.type,
              mediaUrl,
              mediaData,
              Object.keys(mediaMetadata).length > 0
                ? JSON.stringify(mediaMetadata)
                : null,
              new Date(basicInfo.timestamp * 1000),
              msg.fromMe ? "outbound" : "inbound",
              "delivered",
              msg.fromMe || false,
              msg.from,
              author || contactID,
              phoneIndex,
              quotedMessage ? JSON.stringify(quotedMessage) : null,
              msg.to,
              contactPhone,
            ]);

            // Keep track of the most recent message for last_message
            if (!lastMessage || basicInfo.timestamp > lastMessage.timestamp) {
              lastMessage = {
                chat_id: basicInfo.chatId,
                from: basicInfo.from,
                from_me: basicInfo.fromMe,
                id: basicInfo.idSerialized,
                phoneIndex: phoneIndex,
                source: basicInfo.deviceType,
                status: "delivered",
                text: { body: messageBody },
                timestamp: basicInfo.timestamp,
                type: basicInfo.type,
              };
            }
          } catch (error) {
            console.error(
              `Error processing message ${msg.id._serialized} during sync:`,
              error
            );
          }
        }

        // Update contact with the actual last message
        if (lastMessage) {
          const updateContactQuery = `
            UPDATE public.contacts SET
              last_message = $1,
              last_updated = NOW()
            WHERE contact_id = $2 AND company_id = $3;
          `;
          await sqlDb.query(updateContactQuery, [
            JSON.stringify(lastMessage),
            contactID,
            companyId,
          ]);
        }
      } catch (error) {
        console.error(`Error processing chat ${chat.id._serialized}:`, error);
      }
    }

    console.log(
      `Finished syncing contacts for company ${companyId}, phone ${phoneIndex}`
    );
  } catch (error) {
    console.error(
      `Error syncing contacts for company ${companyId}, phone ${phoneIndex}:`,
      error
    );
  }
}

async function syncContactNames(client, companyId, phoneIndex = 0) {
  try {
    const chats = await client.getChats();
    console.log(
      `Found ${chats.length} chats for company ${companyId}, phone ${phoneIndex}. Syncing contact names only.`
    );

    for (const chat of chats) {
      try {
        const contact = await chat.getContact();
        const contactPhone = contact.id.user;
        const contactID = `${companyId}-${contactPhone}`;

        const profilePicUrl = await getProfilePicUrl(contact);

        const potentialName =
          contact.name || contact.pushname || contact.shortName || contactPhone;

        // Function to check if a string is just a phone number
        function isJustPhoneNumber(str) {
          if (!str) return false;
          const cleanStr = str.replace(/[\s\-\(\)\+]/g, "");
          return /^[\+]?\d+$/.test(cleanStr);
        }

        // Function to check if name contains both text and numbers (mixed content)
        function hasMixedContent(str) {
          if (!str) return false;
          const hasLetters = /[a-zA-Z]/.test(str);
          const hasNumbers = /\d/.test(str);
          return hasLetters && hasNumbers;
        }

        let shouldSaveName = false;
        let nameToSave = potentialName;

        if (isJustPhoneNumber(potentialName)) {
          console.log(
            `Skipping name sync for ${contactID} - name is just a phone number: ${potentialName}`
          );
          shouldSaveName = false;
        } else if (hasMixedContent(potentialName)) {
          shouldSaveName = true;
        } else if (potentialName !== contactPhone) {
          shouldSaveName = true;
        }

        if (shouldSaveName) {
          const contactQuery = `
            UPDATE public.contacts SET
              name = $1,
              last_updated = NOW(),
              profile_pic_url = $2
            WHERE contact_id = $3 AND company_id = $4;
          `;

          const result = await sqlDb.query(contactQuery, [
            nameToSave,
            profilePicUrl,
            contactID,
            companyId,
          ]);

          if (result.rowCount === 0) {
            console.log(
              `Contact ${contactID} not found in database, skipping name sync`
            );
          } else {
            console.log(`Updated name for ${contactID}: ${nameToSave}`);
          }
        } else {
          const profileQuery = `
            UPDATE public.contacts SET
              last_updated = NOW(),
              profile_pic_url = $1
            WHERE contact_id = $2 AND company_id = $3;
          `;

          await sqlDb.query(profileQuery, [
            profilePicUrl,
            contactID,
            companyId,
          ]);
        }
      } catch (error) {
        console.error(
          `Error processing contact name for chat ${chat.id._serialized}:`,
          error
        );
      }
    }

    console.log(
      `Finished syncing contact names for company ${companyId}, phone ${phoneIndex}`
    );
  } catch (error) {
    console.error(
      `Error syncing contact names for company ${companyId}, phone ${phoneIndex}:`,
      error
    );
  }
}

async function syncSingleContact(
  client,
  companyId,
  contactPhone,
  phoneIndex = 0
) {
  try {
    console.log(
      `Syncing single contact ${contactPhone} for company ${companyId}, phone ${phoneIndex}`
    );

    const phoneWithPlus = contactPhone.startsWith("+")
      ? contactPhone
      : `+${contactPhone}`;
    const phoneWithoutPlus = contactPhone.startsWith("+")
      ? contactPhone.slice(1)
      : contactPhone;

    // Check if contact is a group by querying the contacts table
    let isGroup = false;
    try {
      const contactQuery = `
        SELECT is_group FROM public.contacts 
        WHERE phone = $1 AND company_id = $2
        LIMIT 1
      `;
      const contactResult = await sqlDb.query(contactQuery, [
        phoneWithPlus,
        companyId,
      ]);

      if (contactResult.rows.length > 0) {
        isGroup = contactResult.rows[0].is_group || false;
      }
    } catch (error) {
      console.error(
        `Error checking if contact is group for ${phoneWithPlus}:`,
        error
      );
      // Default to false if query fails
      isGroup = false;
    }

    // Set chatId based on whether contact is a group or not
    const chatId = isGroup
      ? `${phoneWithoutPlus}@g.us`
      : `${phoneWithoutPlus}@c.us`;

    try {
      const sync = await client.syncHistory(chatId);
      if (sync) {
        console.log("Synced Chat ID history");
      } else {
        console.log("Sync Failed");
      }
      const chat = await client.getChatById(chatId);
      const contact = await chat.getContact();
      const contactID = `${companyId}-${phoneWithoutPlus}`;

      const profilePicUrl = await getProfilePicUrl(contact);

      // Upsert contact
      const contactQuery = `
        INSERT INTO public.contacts (
          contact_id, company_id, name, phone, tags, unread_count, created_at, last_updated, 
          chat_data, company, chat_id, last_message, profile_pic_url
        ) VALUES ($1, $2, $3, $4, '[]'::jsonb, $5, NOW(), NOW(), $6, $7, $8, '{}'::jsonb, $9)
        ON CONFLICT (contact_id, company_id) DO UPDATE SET
          last_updated = NOW(),
          profile_pic_url = EXCLUDED.profile_pic_url,
          unread_count = EXCLUDED.unread_count,
          chat_data = EXCLUDED.chat_data,
          chat_id = EXCLUDED.chat_id,
          last_message = EXCLUDED.last_message;
      `;
      await sqlDb.query(contactQuery, [
        contactID,
        companyId,
        contact.name || contact.pushname || contact.shortName || contactPhone,
        phoneWithPlus,
        chat.unreadCount,
        JSON.stringify(chat),
        contact.name,
        chat.id._serialized,
        profilePicUrl,
      ]);

      // Fetch and insert messages using the same method as addMessageToPostgres
      const messages = await chat.fetchMessages({ limit: 200 }); // Fetch more messages for single contact
      let lastMessage = null;

      const totalMessages = messages.length;
      console.log(
        `Found ${totalMessages} messages for contact ${contactPhone} in company ${companyId}, phone ${phoneIndex}`
      );
      let processedMessages = 0;
      let lastProgress = 0;

      for (const msg of messages) {
        try {
          // Use the same comprehensive message saving as addMessageToPostgres
          const basicInfo = await extractBasicMessageInfo(msg);
          const messageData = await prepareMessageData(
            msg,
            companyId,
            phoneIndex
          );

          // Get message body (with audio transcription if applicable)
          let messageBody = messageData.text?.body || "";
          if (msg.hasMedia && (msg.type === "audio" || msg.type === "ptt")) {
            // Voice message detected during single contact sync
            try {
              const media = await msg.downloadMedia();
              const transcription = await transcribeAudio(media.data);
              if (
                transcription &&
                transcription !==
                  "Audio transcription failed. Please try again."
              ) {
                messageBody += transcription;
              } else {
                messageBody += "Audio message";
              }
            } catch (error) {
              messageBody += "Audio message";
            }
          }

          // Prepare media data
          let mediaUrl = null;
          let mediaData = null;
          let mediaMetadata = {};

          if (msg.hasMedia) {
            if (msg.type === "video") {
              mediaUrl = messageData.video?.link || null;
            } else if (msg.type !== "audio" && msg.type !== "ptt") {
              const mediaTypeData = messageData[msg.type];
              if (mediaTypeData) {
                mediaData = mediaTypeData.data || null;
                mediaUrl = mediaTypeData.link || null;
                mediaMetadata = {
                  mimetype: mediaTypeData.mimetype,
                  filename: mediaTypeData.filename || "",
                  caption: mediaTypeData.caption || "",
                  thumbnail: mediaTypeData.thumbnail || null,
                  mediaKey: mediaTypeData.media_key || null,
                  ...(msg.type === "image" && {
                    width: mediaTypeData.width,
                    height: mediaTypeData.height,
                  }),
                  ...(msg.type === "document" && {
                    pageCount: mediaTypeData.page_count,
                    fileSize: mediaTypeData.file_size,
                  }),
                };
              }
            } else if (msg.type === "audio" || msg.type === "ptt") {
              mediaData = messageData.audio?.data || null;
            }
          }

          // Prepare quoted message
          const quotedMessage = messageData.text?.context || null;

          // Determine author
          let author = null;
          if (msg.from.includes("@g.us") && basicInfo.author) {
            const authorData = await getContactDataFromDatabaseByPhone(
              basicInfo.author,
              companyId
            );
            author = authorData ? authorData.contactName : basicInfo.author;
          }

          const messageQuery = `
            INSERT INTO public.messages (
              message_id, company_id, contact_id, content, message_type,
              media_url, media_data, media_metadata, timestamp, direction,
              status, from_me, chat_id, author, phone_index, quoted_message,
              thread_id, customer_phone
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
            ON CONFLICT (message_id, company_id) DO NOTHING;
          `;

          await sqlDb.query(messageQuery, [
            basicInfo.idSerialized,
            companyId,
            contactID,
            messageBody,
            basicInfo.type,
            mediaUrl,
            mediaData,
            Object.keys(mediaMetadata).length > 0
              ? JSON.stringify(mediaMetadata)
              : null,
            new Date(basicInfo.timestamp * 1000),
            msg.fromMe ? "outbound" : "inbound",
            "delivered",
            msg.fromMe || false,
            msg.from,
            author || contactID,
            phoneIndex,
            quotedMessage ? JSON.stringify(quotedMessage) : null,
            msg.to,
            contactPhone,
          ]);

          // Keep track of the most recent message for last_message
          if (!lastMessage || basicInfo.timestamp > lastMessage.timestamp) {
            lastMessage = {
              chat_id: basicInfo.chatId,
              from: basicInfo.from,
              from_me: basicInfo.fromMe,
              id: basicInfo.idSerialized,
              phoneIndex: phoneIndex,
              source: basicInfo.deviceType,
              status: "delivered",
              text: { body: messageBody },
              timestamp: basicInfo.timestamp,
              type: basicInfo.type,
            };
          }
        } catch (error) {
          // Error processing message
        }

        processedMessages++;
        // Calculate progress in 10% steps
        const progress = Math.floor((processedMessages / totalMessages) * 100);
        if (progress >= lastProgress + 10 || progress === 100) {
          console.log(
            `Sync progress for ${contactPhone}: ${progress}% (${processedMessages}/${totalMessages})`
          );
          lastProgress = progress;
        }
      }

      // Update contact with the actual last message
      if (lastMessage) {
        const updateContactQuery = `
          UPDATE public.contacts SET
            last_message = $1,
            last_updated = NOW()
          WHERE contact_id = $2 AND company_id = $3;
        `;
        await sqlDb.query(updateContactQuery, [
          JSON.stringify(lastMessage),
          contactID,
          companyId,
        ]);
      }

      console.log(
        `Successfully synced contact ${contactPhone} with ${messages.length} messages for company ${companyId}, phone ${phoneIndex}`
      );
    } catch (error) {
      console.error(`Error processing single contact ${contactPhone}:`, error);
      throw error;
    }
  } catch (error) {
    console.error(
      `Error syncing single contact for company ${companyId}, phone ${phoneIndex}, contact ${contactPhone}:`,
      error
    );
    throw error;
  }
}

async function syncSingleContactName(
  client,
  companyId,
  contactPhone,
  phoneIndex = 0
) {
  try {
    console.log(
      `Syncing single contact name ${contactPhone} for company ${companyId}, phone ${phoneIndex}`
    );

    // Format the contact ID to match WhatsApp format
    const phoneWithPlus = contactPhone.startsWith("+")
      ? contactPhone
      : `+${contactPhone}`;
    const phoneWithoutPlus = contactPhone.startsWith("+")
      ? contactPhone.slice(1)
      : contactPhone;
    const chatId = `${phoneWithoutPlus}@c.us`;

    try {
      const chat = await client.getChatById(chatId);
      const contact = await chat.getContact();
      const contactID = `${companyId}-${phoneWithoutPlus}`;

      const profilePicUrl = await getProfilePicUrl(contact);
      const potentialName =
        contact.name || contact.pushname || contact.shortName || phoneWithPlus;

      // Helper: is just a phone number
      function isJustPhoneNumber(str) {
        if (!str) return false;
        const cleanStr = str.replace(/[\s\-\(\)\+]/g, "");
        return /^[\+]?\d+$/.test(cleanStr);
      }
      // Helper: has mixed content (letters and numbers)
      function hasMixedContent(str) {
        if (!str) return false;
        const hasLetters = /[a-zA-Z]/.test(str);
        const hasNumbers = /\d/.test(str);
        return hasLetters && hasNumbers;
      }

      let shouldSaveName = false;
      let nameToSave = potentialName;

      if (isJustPhoneNumber(potentialName)) {
        console.log(
          `Skipping name sync for ${contactID} - name is just a phone number: ${potentialName}`
        );
        shouldSaveName = false;
      } else if (hasMixedContent(potentialName)) {
        shouldSaveName = true;
      } else if (potentialName !== phoneWithPlus) {
        shouldSaveName = true;
      }

      if (shouldSaveName) {
        const contactQuery = `
          UPDATE public.contacts SET
            name = $1,
            last_updated = NOW(),
            profile_pic_url = $2
          WHERE contact_id = $3 AND company_id = $4;
        `;
        const result = await sqlDb.query(contactQuery, [
          nameToSave,
          profilePicUrl,
          contactID,
          companyId,
        ]);
        if (result.rowCount === 0) {
          console.log(
            `Contact ${contactID} not found in database, cannot sync name`
          );
          throw new Error(`Contact ${contactPhone} not found in database`);
        }
        console.log(
          `Successfully synced contact name for ${contactPhone} in company ${companyId}, phone ${phoneIndex}: ${nameToSave}`
        );
      } else {
        // Only update profile picture and last_updated
        const profileQuery = `
          UPDATE public.contacts SET
            last_updated = NOW(),
            profile_pic_url = $1
          WHERE contact_id = $2 AND company_id = $3;
        `;
        await sqlDb.query(profileQuery, [profilePicUrl, contactID, companyId]);
        console.log(
          `Updated profile picture only for ${contactPhone} in company ${companyId}, phone ${phoneIndex}`
        );
      }
    } catch (error) {
      console.error(
        `Error processing single contact name ${contactPhone}:`,
        error
      );
      throw error;
    }
  } catch (error) {
    console.error(
      `Error syncing single contact name for company ${companyId}, phone ${phoneIndex}, contact ${contactPhone}:`,
      error
    );
    throw error;
  }
}

async function syncMessagesAndHandleAutoReplies(
  botName,
  phoneCount,
  forceEnabled = false,
  customHours = null
) {
  console.log(
    `=== Starting syncMessagesAndHandleAutoReplies for bot ${botName} ${
      forceEnabled ? "(Manual trigger)" : ""
    } ===`
  );

  try {
    // Get auto-reply settings for this bot
    const autoReplySettings = await getAutoReplySettings(botName);

    // If forceEnabled is true, override the enabled setting
    if (forceEnabled) {
      autoReplySettings.enabled = true;
      if (customHours) {
        autoReplySettings.autoReplyHours = customHours.toString();
      }
      console.log(
        `[AutoReply] Manual trigger - forcing auto-reply enabled for bot ${botName}`
      );
    } else if (!autoReplySettings || !autoReplySettings.enabled) {
      console.log(
        `[AutoReply] Auto-reply is disabled for bot ${botName}, skipping auto-reply processing`
      );
      return;
    }

    // Process each phone index for this bot
    for (let phoneIndex = 0; phoneIndex < phoneCount; phoneIndex++) {
      const botData = botMap.get(botName);
      if (!botData || !Array.isArray(botData) || !botData[phoneIndex]) {
        console.log(
          `[AutoReply] Bot ${botName} phone ${phoneIndex} not found in botMap`
        );
        continue;
      }

      const client = botData[phoneIndex].client;
      if (!client) {
        console.log(
          `[AutoReply] Client not found for bot ${botName} phone ${phoneIndex}`
        );
        continue;
      }

      console.log(
        `[AutoReply] Processing phone index ${phoneIndex} for bot ${botName}`
      );
      await syncMessagesForBot(client, botName, phoneIndex, autoReplySettings);
    }

    console.log(
      `=== Completed syncMessagesAndHandleAutoReplies for bot ${botName} ===`
    );
  } catch (error) {
    console.error(
      `[AutoReply] Error in syncMessagesAndHandleAutoReplies for bot ${botName}:`,
      error
    );
  }
}

// Function to get auto-reply settings from database
async function getAutoReplySettings(companyId) {
  const sqlClient = await getDatabaseConnection();
  if (!sqlClient) {
    return null;
  }

  try {
    const result = await sqlClient.query(
      `SELECT setting_value FROM settings 
       WHERE company_id = $1 AND setting_type = 'autoReply' AND setting_key = 'config'`,
      [companyId]
    );

    if (result.rows.length === 0) {
      return { enabled: false, autoReplyHours: "6" };
    }

    const settings = result.rows[0].setting_value;
    return {
      enabled: settings.enabled || false,
      autoReplyHours: settings.autoReplyHours || "6",
    };
  } catch (error) {
    console.error("[AutoReply] Error fetching auto-reply settings:", error);
    return { enabled: false, autoReplyHours: "6" };
  } finally {
    sqlClient.release();
  }
}

// Function to sync messages for a specific bot
async function syncMessagesForBot(
  client,
  botName,
  phoneIndex,
  autoReplySettings
) {
  try {
    console.log(
      `[AutoReply] Syncing messages for bot ${botName}, phone ${phoneIndex}`
    );

    // Get all chats from WhatsApp
    const chats = await client.getChats();
    console.log(
      `[AutoReply] Found ${chats.length} chats for bot ${botName} phone ${phoneIndex}`
    );

    let processedCount = 0;
    const batchSize = 10; // Process chats in batches to avoid overwhelming

    for (let i = 0; i < chats.length; i += batchSize) {
      const chatBatch = chats.slice(i, i + batchSize);

      await Promise.all(
        chatBatch.map(async (chat) => {
          try {
            // Skip status updates and broadcast lists
            if (
              chat.id._serialized === "status@broadcast" ||
              chat.isBroadcast
            ) {
              return;
            }

            const contact = await chat.getContact();
            const phoneNumber = "+" + contact.id.user;

            // Skip if phone number is invalid
            if (
              !phoneNumber ||
              phoneNumber === "+status" ||
              phoneNumber === "+0"
            ) {
              return;
            }

            await syncContactMessages(
              client,
              chat,
              contact,
              botName,
              phoneIndex,
              autoReplySettings
            );
            processedCount++;

            if (processedCount % 50 === 0) {
              console.log(
                `[AutoReply] Processed ${processedCount}/${chats.length} chats for bot ${botName} phone ${phoneIndex}`
              );
            }
          } catch (contactError) {
            console.error(
              `[AutoReply] Error processing contact ${chat.id._serialized}:`,
              contactError.message
            );
          }
        })
      );

      // Small delay between batches
      await new Promise((resolve) => setTimeout(resolve, 100));
    }

    console.log(
      `[AutoReply] Completed syncing ${processedCount} chats for bot ${botName} phone ${phoneIndex}`
    );
  } catch (error) {
    console.error(
      `[AutoReply] Error syncing messages for bot ${botName} phone ${phoneIndex}:`,
      error
    );
  }
}

// Function to sync messages for a specific contact and handle auto-reply
async function syncContactMessages(
  client,
  chat,
  contact,
  botName,
  phoneIndex,
  autoReplySettings
) {
  try {
    const phoneNumber = "+" + contact.id.user;
    const contactName =
      contact.name || contact.pushname || contact.verifiedName || phoneNumber;

    // Fetch latest 5 messages from WhatsApp
    const messages = await chat.fetchMessages({ limit: 5 });

    if (!messages || messages.length === 0) {
      return;
    }

    // Sort messages by timestamp (oldest first)
    const sortedMessages = messages.sort((a, b) => a.timestamp - b.timestamp);

    // Check if contact needs auto-reply
    if (autoReplySettings.enabled) {
      await checkAndProcessAutoReply(
        client,
        chat,
        contact,
        botName,
        phoneIndex,
        autoReplySettings,
        sortedMessages
      );
    }
  } catch (error) {
    console.error(
      `[AutoReply] Error syncing contact messages for ${contact.id.user}:`,
      error
    );
  }
}

// Function to check if contact needs auto-reply and process through message handler
async function checkAndProcessAutoReply(
  client,
  chat,
  contact,
  botName,
  phoneIndex,
  autoReplySettings,
  messages
) {
  try {
    const phoneNumber = "+" + contact.id.user;
    const contactName =
      contact.name || contact.pushname || contact.verifiedName || phoneNumber;

    // Check if contact has been replied to within the time limit
    const hasBeenReplied = await checkIfContactHasBeenReplied(
      messages,
      botName,
      phoneNumber,
      autoReplySettings.autoReplyHours
    );

    if (hasBeenReplied) {
      // Still need to check for unsaved messages and save them
      const messagesSavedStatus = await checkMessagesInDatabase(
        messages,
        botName,
        phoneNumber
      );

      for (let i = 0; i < messages.length; i++) {
        const message = messages[i];
        const isAlreadySaved = messagesSavedStatus[i];

        // If message is fromMe and not saved, save it directly
        if (message.fromMe && !isAlreadySaved) {
          await saveFromMeMessageDirectly(
            message,
            botName,
            phoneNumber,
            phoneIndex
          );
        }
      }

      return;
    }

    // Get which messages are already saved in database
    const messagesSavedStatus = await checkMessagesInDatabase(
      messages,
      botName,
      phoneNumber
    );

    // Check if all messages are already saved
    const allMessagesSaved = messagesSavedStatus.every(
      (saved) => saved === true
    );

    if (allMessagesSaved) {
      return;
    }

    // Calculate time-based cutoffs
    const autoReplyHours = parseInt(autoReplySettings.autoReplyHours) || 6;
    const cutoffTime = Date.now() - autoReplyHours * 60 * 60 * 1000;

    // Separate messages into categories for processing
    const messagesToProcess = []; // Recent customer messages for processing
    const messagesToSave = []; // Older messages to save directly

    for (let i = 0; i < messages.length; i++) {
      const message = messages[i];
      const isAlreadySaved = messagesSavedStatus[i];
      const messageTime = message.timestamp * 1000;
      const isRecent = messageTime > cutoffTime;

      if (!isAlreadySaved) {
        if (message.fromMe) {
          // Always save fromMe messages directly
          await saveFromMeMessageDirectly(
            message,
            botName,
            phoneNumber,
            phoneIndex
          );
        } else {
          // Customer messages: check if recent or old
          if (isRecent) {
            // Recent customer messages - send to message handler for processing
            messagesToProcess.push(message);
          } else {
            // Old customer messages - save directly without processing
            messagesToSave.push(message);
          }
        }
      }
    }

    // Check if there's nothing to process or save
    if (messagesToProcess.length === 0 && messagesToSave.length === 0) {
      return;
    }

    // First, save old customer messages directly (like messages 1,2 in your example)
    if (messagesToSave.length > 0) {
      for (const message of messagesToSave) {
        await saveCustomerMessageDirectly(
          message,
          botName,
          phoneNumber,
          phoneIndex
        );
      }
    }

    // Then, process recent customer messages through handler (like messages 4,5 in your example)
    if (messagesToProcess.length > 0) {
      for (const message of messagesToProcess) {
        // Add delay before sending to message handler (5-10 seconds)
        const delay = Math.floor(Math.random() * 5000) + 5000; // 5-10 seconds

        setTimeout(async () => {
          try {
            await handleNewMessagesTemplateWweb(
              client,
              message,
              botName,
              phoneIndex
            );
          } catch (error) {
            console.error(
              `[AutoReply] Error processing message ${message.id._serialized}:`,
              error
            );
          }
        }, delay);
      }

      // Only log auto-reply action if we actually processed messages
      await recordAutoReplySent(botName, phoneNumber);
    }
  } catch (error) {
    console.error(
      `[AutoReply] Error in checkAndProcessAutoReply for ${contact.id.user}:`,
      error
    );
  }
}

// Function to check if contact has been replied to
async function checkIfContactHasBeenReplied(
  messages,
  botName,
  phoneNumber,
  autoReplyHours
) {
  try {
    const autoReplyHoursInt = parseInt(autoReplyHours) || 6;
    const cutoffTime = Date.now() - autoReplyHoursInt * 60 * 60 * 1000;

    // Find the latest customer message (not fromMe) within the time limit
    let latestCustomerMessage = null;
    let latestCustomerMessageIndex = -1;

    for (let i = messages.length - 1; i >= 0; i--) {
      const msg = messages[i];
      const messageTime = msg.timestamp * 1000;

      if (!msg.fromMe && messageTime > cutoffTime) {
        latestCustomerMessage = msg;
        latestCustomerMessageIndex = i;
        break;
      }
    }

    if (!latestCustomerMessage) {
      return true; // No recent customer messages, so no need to reply
    }

    // Check if there's any message from us AFTER the latest customer message
    for (let i = latestCustomerMessageIndex + 1; i < messages.length; i++) {
      const msg = messages[i];
      if (msg.fromMe) {
        return true;
      }
    }

    // Also check database for any messages from us to this contact AFTER the latest customer message timestamp
    const sqlClient = await getDatabaseConnection();
    if (!sqlClient) {
      return false;
    }

    try {
      const latestCustomerTimestamp = new Date(
        latestCustomerMessage.timestamp * 1000
      );

      const result = await sqlClient.query(
        `SELECT COUNT(*) as count FROM messages 
         WHERE company_id = $1 AND contact_id = $2 AND from_me = true 
         AND timestamp > $3`,
        [
          botName,
          botName + "-" + phoneNumber.substring(1),
          latestCustomerTimestamp,
        ]
      );

      const messageCount = parseInt(result.rows[0].count);
      if (messageCount > 0) {
        return true;
      }

      return false;
    } finally {
      sqlClient.release();
    }
  } catch (error) {
    console.error(
      "[AutoReply] Error checking if contact has been replied:",
      error
    );
    return false;
  }
}

// Function to check if messages are already saved in database
async function checkMessagesInDatabase(messages, botName, phoneNumber) {
  const sqlClient = await getDatabaseConnection();
  if (!sqlClient) {
    return messages.map(() => false); // Assume none are saved if can't connect
  }

  try {
    const messageIds = messages.map((msg) => msg.id._serialized);
    const placeholders = messageIds
      .map((_, index) => `$${index + 3}`)
      .join(",");

    const result = await sqlClient.query(
      `SELECT message_id FROM messages 
       WHERE company_id = $1 AND contact_id = $2 AND message_id IN (${placeholders})`,
      [botName, botName + "-" + phoneNumber.substring(1), ...messageIds]
    );

    const savedMessageIds = new Set(result.rows.map((row) => row.message_id));

    // Return array indicating which messages are already saved
    return messages.map((msg) => savedMessageIds.has(msg.id._serialized));
  } catch (error) {
    console.error("[AutoReply] Error checking messages in database:", error);
    return messages.map(() => false); // Assume none are saved on error
  } finally {
    sqlClient.release();
  }
}

// Function to save fromMe messages directly (similar to setupMessageCreateHandler)
async function saveFromMeMessageDirectly(
  message,
  botName,
  phoneNumber,
  phoneIndex
) {
  try {
    const contactName = phoneNumber; // We might not have contact name here

    // Save the message directly to database without processing
    await addMessageToPostgres(
      message,
      botName,
      phoneNumber,
      contactName,
      phoneIndex,
      "Auto-Sync"
    );
  } catch (error) {
    console.error(
      `[AutoReply] Error saving fromMe message directly: ${message.id._serialized}`,
      error
    );
  }
}

// Function to save customer messages directly (without processing through message handler)
async function saveCustomerMessageDirectly(
  message,
  botName,
  phoneNumber,
  phoneIndex
) {
  try {
    const contactName = phoneNumber; // We might not have contact name here

    // Save the message directly to database without processing
    await addMessageToPostgres(
      message,
      botName,
      phoneNumber,
      contactName,
      phoneIndex,
      "Auto-Sync"
    );
  } catch (error) {
    console.error(
      `[AutoReply] Error saving customer message directly: ${message.id._serialized}`,
      error
    );
  }
}

// Function to record that auto-reply was sent
async function recordAutoReplySent(botName, phoneNumber) {
  const sqlClient = await getDatabaseConnection();
  if (!sqlClient) {
    return;
  }

  try {
    await sqlClient.query(
      `INSERT INTO auto_reply_log (company_id, phone, created_at) 
       VALUES ($1, $2, NOW()) 
       ON CONFLICT (company_id, phone) 
       DO UPDATE SET created_at = NOW()`,
      [botName, phoneNumber]
    );
  } catch (error) {
    console.error("Error recording auto-reply sent:", error);
  } finally {
    sqlClient.release();
  }
}

function getMillisecondsForUnit(unit) {
  switch (unit) {
    case "minutes":
      return 60 * 1000;
    case "hours":
      return 60 * 60 * 1000;
    case "days":
      return 24 * 60 * 60 * 1000;
    default:
      return 0;
  }
}

// ======================
// ACTIVE HOURS VALIDATION HELPERS
// ======================

/**
 * Validates time format (HH:MM in 24-hour format)
 * @param {string} time - Time string to validate
 * @returns {boolean} - True if valid format
 */
function validateTimeFormat(time) {
  const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
  return timeRegex.test(time);
}

/**
 * Validates active hours constraints
 * @param {string} start - Start time in HH:MM format
 * @param {string} end - End time in HH:MM format
 * @returns {object} - { valid: boolean, error: string }
 */
function validateActiveHours(start, end) {
  // Check if both are provided
  if ((start && !end) || (!start && end)) {
    return {
      valid: false,
      error: "Both start and end times must be provided for active hours"
    };
  }

  // If neither provided, that's valid (no active hours restriction)
  if (!start && !end) {
    return { valid: true };
  }

  // Validate format
  if (!validateTimeFormat(start)) {
    return {
      valid: false,
      error: "Invalid start time format. Use HH:MM (24-hour format, e.g., 09:00)"
    };
  }

  if (!validateTimeFormat(end)) {
    return {
      valid: false,
      error: "Invalid end time format. Use HH:MM (24-hour format, e.g., 17:00)"
    };
  }

  // Check if start is before end (for same-day ranges only)
  if (start >= end) {
    return {
      valid: false,
      error: "Start time must be before end time. Overnight ranges are not supported."
    };
  }

  return { valid: true };
}

/**
 * Checks if current time is within active hours
 * @param {object} message - Message object with active_hours_start and active_hours_end
 * @returns {boolean} - True if within active hours or no active hours set
 */
function isWithinActiveHours(message) {
  // If no active hours set, always return true (backwards compatible)
  if (!message.active_hours_start || !message.active_hours_end) {
    return true;
  }

  const now = new Date();
  const currentTime = now.toTimeString().slice(0, 5); // "HH:MM" format

  const startTime = message.active_hours_start;
  const endTime = message.active_hours_end;

  // Compare times as strings (works for HH:MM format)
  return currentTime >= startTime && currentTime <= endTime;
}

/**
 * Normalizes time format to HH:MM (ensures 2 digits for hours)
 * @param {string} time - Time string
 * @returns {string} - Normalized time string
 */
function normalizeTimeFormat(time) {
  if (!time) return null;
  
  const parts = time.split(':');
  if (parts.length !== 2) return null;
  
  const hours = parts[0].padStart(2, '0');
  const minutes = parts[1].padStart(2, '0');
  
  return `${hours}:${minutes}`;
}

// Store queues and workers
const botQueues = new Map();
const botWorkers = new Map();
const processingChatIds = new Map();

setInterval(() => {
  const now = Date.now();
  for (const [chatId, timestamp] of processingChatIds.entries()) {
    if (now - timestamp > 300000) {
      console.log(
        `Releasing stale chatId reservation: ${chatId} (processing for ${
          (now - timestamp) / 1000
        }s)`
      );
      processingChatIds.delete(chatId);
    }
  }
}, 600000);

// Function to get or create a bot's queue
const getQueueForBot = (botId) => {
  if (!botQueues.has(botId)) {
    const { queue, worker } = createQueueAndWorker(botId);
    botQueues.set(botId, queue);
    botWorkers.set(botId, worker);
  }
  return botQueues.get(botId);
};

// ======================
// ENHANCED DATABASE CONNECTION MANAGEMENT
// ======================

// Enhanced sendScheduledMessage function with better connection management
// Enhanced JSON parsing with better error handling
const safeJsonParse = (data, defaultValue = null, context = "") => {
  if (!data) {
    console.log(
      `[JSON Parse] No data provided for ${context}, using default:`,
      defaultValue
    );
    return defaultValue;
  }

  // If it's already an array or object, return it
  if (Array.isArray(data) || (typeof data === "object" && data !== null)) {
    console.log(`[JSON Parse] Data is already parsed for ${context}:`, data);
    return data;
  }

  // If it's a string, try to parse it
  if (typeof data === "string") {
    try {
      // Check if it looks like JSON
      const trimmed = data.trim();
      if (
        (trimmed.startsWith("[") && trimmed.endsWith("]")) ||
        (trimmed.startsWith("{") && trimmed.endsWith("}"))
      ) {
        const parsed = JSON.parse(trimmed);
        console.log(
          `[JSON Parse] Successfully parsed JSON for ${context}:`,
          parsed
        );
        return parsed;
      } else {
        // It's not JSON, treat as single value
        console.log(
          `[JSON Parse] Data is not JSON for ${context}, treating as single value:`,
          data
        );
        return [data];
      }
    } catch (error) {
      console.error(`[JSON Parse] Error parsing JSON for ${context}:`, {
        error: error.message,
        data: data,
        position: error.message.match(/position (\d+)/)?.[1] || "unknown",
        context: context,
      });

      // If it's a string that's not JSON, treat it as a single value
      if (typeof data === "string") {
        console.log(
          `[JSON Parse] Treating non-JSON string as single value for ${context}:`,
          data
        );
        return [data];
      }

      return defaultValue;
    }
  }

  // For other types, return as is
  console.log(
    `[JSON Parse] Data is not string for ${context}, returning as is:`,
    data
  );
  return data;
};
// ======================
// CLEANUP OLD PROBLEMATIC JOBS
// ======================

// Function to clean up old jobs with JSON parsing errors

// Function to clean up specific bot's jobs
async function cleanupBotJobs(botId) {
  console.log(`Cleaning up jobs for bot ${botId}...`);

  try {
    const queue = botQueues.get(botId);
    if (!queue) {
      console.log(`Bot ${botId} - No queue found`);
      return;
    }

    // Get all jobs
    const waitingJobs = await queue.getJobs(["waiting"]);
    const delayedJobs = await queue.getJobs(["delayed"]);
    const activeJobs = await queue.getJobs(["active"]);
    const failedJobs = await queue.getJobs(["failed"]);

    const allJobs = [
      ...waitingJobs,
      ...delayedJobs,
      ...activeJobs,
      ...failedJobs,
    ];

    console.log(`Bot ${botId} - Found ${allJobs.length} jobs to check`);

    let removedCount = 0;

    for (const job of allJobs) {
      try {
        // Remove all jobs for this bot (since they're likely problematic)
        await job.remove();
        removedCount++;
        console.log(`Bot ${botId} - Removed job ${job.id}`);
      } catch (error) {
        console.error(
          `Bot ${botId} - Error removing job ${job.id}:`,
          error.message
        );
      }
    }

    console.log(
      `Bot ${botId} - Cleanup completed, removed ${removedCount} jobs`
    );
  } catch (error) {
    console.error(`Bot ${botId} - Error during cleanup:`, error.message);
  }
}

// Add cleanup endpoints

app.post("/api/cleanup-jobs/:botId", async (req, res) => {
  try {
    const { botId } = req.params;
    await cleanupBotJobs(botId);
    res.json({
      success: true,
      message: `Job cleanup completed for bot ${botId}`,
    });
  } catch (error) {
    console.error("Error during bot job cleanup:", error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Enhanced sendScheduledMessage function with better JSON parsing
async function sendScheduledMessage(message) {
  const companyId = message.company_id;
  let client = null;
  const startTime = Date.now();

  // FIXED: Declare messages variable at function scope
  let messages = [];
  let totalMessagesSent = 0;
  let totalMessagesSkipped = 0;
  let totalErrors = 0;
  let dayCount = 1;

  try {
    console.log(
      `\n=== [Company ${companyId}] Starting sendScheduledMessage ===`
    );
    console.log(`[Company ${companyId}] Message ID: ${message.id}`);
    console.log(`[Company ${companyId}] Schedule ID: ${message.schedule_id}`);
    console.log(`[Company ${companyId}] Status: ${message.status}`);
    console.log(`[Company ${companyId}] Phone Index: ${message.phone_index}`);

    // Get database connection with timeout
    client = await getDatabaseConnection(10000);
    console.log(`[Company ${companyId}] Database connection established`);

    // Validate phone_index
    if (message.phone_index === null || message.phone_index === undefined) {
      console.log(
        `[Company ${companyId}] Phone index is null/undefined, defaulting to 0`
      );
      message.phone_index = 0;
    }
    message.phone_index = parseInt(message.phone_index);
    if (isNaN(message.phone_index)) {
      console.log(`[Company ${companyId}] Phone index is NaN, defaulting to 0`);
      message.phone_index = 0;
    }

    const botData = botMap.get(companyId);
    console.log(
      `[Company ${companyId}] Available phone indices:`,
      botData ? botData.map((_, i) => i) : []
    );
    console.log(`[Company ${companyId}] Client status:`, {
      phoneIndex: message.phone_index,
      hasClient: Boolean(botData?.[message.phone_index]?.client),
      clientInfo: botData?.[message.phone_index]?.client
        ? "Client exists"
        : null,
      totalBots: botData ? botData.length : 0,
    });

    if (!botData?.[message.phone_index]?.client) {
      const error = new Error(
        `No active WhatsApp client found for phone index: ${message.phone_index}`
      );
      console.error(`[Company ${companyId}] Client not found:`, {
        phoneIndex: message.phone_index,
        availableIndices: botData ? botData.map((_, i) => i) : [],
        botDataExists: Boolean(botData),
        botDataLength: botData ? botData.length : 0,
      });
      throw error;
    }

    // Log client info
    const whatsappClient = botData[message.phone_index].client;
    console.log(`[Company ${companyId}] WhatsApp client info:`, {
      hasInfo: Boolean(whatsappClient.info),
      info: whatsappClient.info
        ? {
            wid: whatsappClient.info.wid?._serialized,
            platform: whatsappClient.info.platform,
            pushname: whatsappClient.info.pushname,
          }
        : null,
      isReady: Boolean(whatsappClient.info),
    });

    if (message) {
      console.log(`\n=== [Company ${companyId}] Processing V2 Message ===`);

      let chatIds = [];

      // Parse chat_ids with safe JSON parsing
      console.log(`[Company ${companyId}] Parsing chat_ids:`, message.chat_ids);
      chatIds = safeJsonParse(
        message.chat_ids,
        [],
        `chat_ids for company ${companyId}`
      );

      if (Array.isArray(chatIds)) {
        console.log(
          `[Company ${companyId}] chat_ids parsed as array with ${chatIds.length} items`
        );
      } else {
        console.log(
          `[Company ${companyId}] chat_ids parsed as single value:`,
          chatIds
        );
        chatIds = [chatIds];
      }

      // Parse messages array with safe JSON parsing
      console.log(
        `[Company ${companyId}] Parsing messages field:`,
        message.messages
      );
      messages = safeJsonParse(
        message.messages,
        [],
        `messages for company ${companyId}`
      );

      if (Array.isArray(messages)) {
        console.log(
          `[Company ${companyId}] messages parsed as array with ${messages.length} items`
        );
      } else {
        console.log(
          `[Company ${companyId}] messages parsed as single value:`,
          messages
        );
        messages = [messages];
      }

      // If no messages array, create from individual message fields
      if (!messages || messages.length === 0) {
        console.log(
          `[Company ${companyId}] Creating messages from individual fields`
        );
        messages = chatIds.map((chatId) => {
          const delay =
            message.min_delay && message.max_delay
              ? Math.floor(
                  Math.random() * (message.max_delay - message.min_delay + 1) +
                    message.min_delay
                )
              : 0;

          const messageObj = {
            chatId: chatId,
            message: message.message_content,
            delay: delay,
            mediaUrl: message.media_url || "",
            documentUrl: message.document_url || "",
            fileName: message.file_name || "",
            caption: message.caption || "",
          };

          console.log(`[Company ${companyId}] Created message for ${chatId}:`, {
            messageLength: messageObj.message?.length,
            delay: messageObj.delay,
            hasMedia: Boolean(messageObj.mediaUrl || messageObj.documentUrl),
          });

          return messageObj;
        });
      }

      console.log(`[Company ${companyId}] Final batch details:`, {
        messageId: message.id,
        infiniteLoop: message.infinite_loop,
        activeHours: message.active_hours
          ? safeJsonParse(
              message.active_hours,
              null,
              `active_hours for company ${companyId}`
            )
          : null,
        totalMessages: messages.length,
        messages: messages.map((m, index) => ({
          index: index,
          chatId: m.chatId,
          messageLength: m.message?.length,
          delay: m.delay,
          hasMedia: Boolean(m.mediaUrl || m.documentUrl),
          mediaUrl: m.mediaUrl || null,
          documentUrl: m.documentUrl || null,
        })),
      });

      // Check if we have any messages to process
      if (!messages || messages.length === 0) {
        console.log(
          `[Company ${companyId}] No messages to process - marking as completed`
        );
        return {
          success: true,
          statistics: {
            totalTime: Date.now() - startTime,
            totalMessages: 0,
            totalSent: 0,
            totalSkipped: 0,
            totalErrors: 0,
            dayCount: 1,
          },
        };
      }

      const processMessage = (messageText, contact) => {
        if (!messageText) {
          console.log(`[Company ${companyId}] No message text to process`);
          return "";
        }

        console.log(
          `[Company ${companyId}] Processing message with placeholders:`,
          {
            originalLength: messageText.length,
            hasContact: Boolean(contact),
            contactName: contact?.name || null,
            contactPhone: contact?.phone || null,
          }
        );

        let processedMessage = messageText;
        const placeholders = {
          contactName: contact?.name || "",
          firstName: contact?.first_name || "",
          lastName: contact?.last_name || "",
          email: contact?.email || "",
          phone: contact?.phone || "",
          vehicleNumber: contact?.vehicle_number || "",
          branch: contact?.branch || "",
          expiryDate: contact?.expiry_date || "",
          ic: contact?.ic || "",
        };

        // Log available placeholders
        console.log(
          `[Company ${companyId}] Available placeholders:`,
          placeholders
        );

        Object.entries(placeholders).forEach(([key, value]) => {
          const placeholder = `@{${key}}`;
          const originalMessage = processedMessage;
          processedMessage = processedMessage.replace(
            new RegExp(placeholder, "g"),
            value
          );
          if (originalMessage !== processedMessage) {
            console.log(
              `[Company ${companyId}] Replaced ${placeholder} with: ${value}`
            );
          }
        });

        if (contact?.custom_fields) {
          console.log(`[Company ${companyId}] Processing custom fields`);
          const customFields = safeJsonParse(
            contact.custom_fields,
            {},
            `custom_fields for contact ${contact.contact_id}`
          );

          console.log(`[Company ${companyId}] Custom fields:`, customFields);

          Object.entries(customFields).forEach(([key, value]) => {
            const customPlaceholder = `@{${key}}`;
            const stringValue =
              value !== null && value !== undefined ? String(value) : "";
            const originalMessage = processedMessage;
            processedMessage = processedMessage.replace(
              new RegExp(customPlaceholder, "g"),
              stringValue
            );
            if (originalMessage !== processedMessage) {
              console.log(
                `[Company ${companyId}] Replaced ${customPlaceholder} with: ${stringValue}`
              );
            }
          });
        }

        console.log(`[Company ${companyId}] Message processing complete:`, {
          originalLength: messageText.length,
          processedLength: processedMessage.length,
          hasChanges: messageText !== processedMessage,
        });

        return processedMessage;
      };

      const isWithinActiveHoursLocal = () => {
        // Check using the new active_hours_start and active_hours_end columns
        if (!message.active_hours_start || !message.active_hours_end) {
          console.log(
            `[Company ${companyId}] No active hours set (using columns), always active`
          );
          return true;
        }

        try {
          const now = new Date();
          const currentTime = now.toTimeString().slice(0, 5); // "HH:MM" format

          const startTime = message.active_hours_start;
          const endTime = message.active_hours_end;

          const isActive = currentTime >= startTime && currentTime <= endTime;

          console.log(`[Company ${companyId}] Active hours check (using columns):`, {
            currentTime: currentTime,
            startTime: startTime,
            endTime: endTime,
            isActive: isActive,
          });

          return isActive;
        } catch (e) {
          console.warn(
            `[Company ${companyId}] Error checking active hours, assuming active:`,
            e
          );
          return true;
        }
      };

      const waitUntilNextDay = async () => {
        const now = new Date();
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(0, 0, 0, 0);

        const timeUntilTomorrow = tomorrow - now;
        console.log(`[Company ${companyId}] Waiting until next day:`, {
          currentTime: now.toISOString(),
          tomorrowTime: tomorrow.toISOString(),
          waitMinutes: timeUntilTomorrow / 1000 / 60,
        });

        try {
          const messageCheck = await client.query(
            "SELECT status FROM scheduled_messages WHERE id = $1",
            [message.id]
          );

          if (messageCheck.rowCount === 0) {
            console.log(
              `[Company ${companyId}] Message not found in database, stopping`
            );
            return true;
          }

          if (messageCheck.rows[0].status === "stopped") {
            console.log(`[Company ${companyId}] Message sequence stopped`);
            return true;
          }

          console.log(
            `[Company ${companyId}] Waiting ${
              timeUntilTomorrow / 1000 / 60
            } minutes until next day`
          );
          await new Promise((resolve) =>
            setTimeout(resolve, timeUntilTomorrow)
          );
          return false;
        } catch (error) {
          console.error(
            `[Company ${companyId}] Error checking message status:`,
            error
          );
          return true; // Stop on error
        }
      };

      let currentMessageIndex = 0;
      let consecutiveErrors = 0;
      const MAX_CONSECUTIVE_ERRORS = 5;

      console.log(`[Company ${companyId}] Starting message processing loop`);

      while (true) {
        try {
          const loopStartTime = Date.now();

          // Check if we're within active hours
          if (!isWithinActiveHoursLocal()) {
            console.log(
              `[Company ${companyId}] ⏰ Outside active hours (${message.active_hours_start} - ${message.active_hours_end})`
            );
            
            // Calculate next check time (10 minutes from now)
            const nextCheckDelay = 10 * 60 * 1000; // 10 minutes
            
            console.log(
              `[Company ${companyId}] 🔄 Rescheduling job to check again in 10 minutes...`
            );
            
            // Get the queue for this company
            const queue = getQueueForBot(companyId);
            
            // Determine if this is a batch or single message
            const isBatch = message.id !== message.schedule_id;
            
            // Reschedule the job
            await queue.add(
              isBatch ? "send-message-batch" : "send-single-message",
              isBatch 
                ? {
                    companyId,
                    messageId: message.schedule_id,
                    batchId: message.id,
                  }
                : {
                    companyId,
                    messageId: message.id,
                  },
              {
                removeOnComplete: false,
                removeOnFail: false,
                delay: nextCheckDelay,
                jobId: message.id, // Use same jobId to replace existing job
              }
            );
            
            console.log(
              `[Company ${companyId}] ✅ Job rescheduled successfully. Exiting current job.`
            );
            
            // Return success to complete this job and let the rescheduled one take over
            return {
              success: true,
              rescheduled: true,
              reason: "Outside active hours",
              nextCheck: new Date(Date.now() + nextCheckDelay).toISOString()
            };
          }

          // Add rate limiting check
          if (!checkRateLimit(`message_processing_${companyId}`)) {
            console.log(
              `[Company ${companyId}] Rate limit reached, waiting 1 minute...`
            );
            await new Promise((resolve) => setTimeout(resolve, 60000));
            continue;
          }

          // Add a longer delay between processing cycles to reduce network load
          console.log(
            `[Company ${companyId}] Waiting 10 seconds between cycles...`
          );
          await new Promise((resolve) => setTimeout(resolve, 10000));

          // FIXED: Check if currentMessageIndex is within bounds
          if (currentMessageIndex >= messages.length) {
            console.log(
              `[Company ${companyId}] Reached end of messages array (${currentMessageIndex}/${messages.length})`
            );

            if (!message.infinite_loop) {
              console.log(`[Company ${companyId}] Sequence complete - ending`);
              break;
            }

            console.log(
              `[Company ${companyId}] Day ${dayCount} complete - preparing for next day`
            );
            const shouldStop = await waitUntilNextDay();
            if (shouldStop) {
              console.log(
                `[Company ${companyId}] Sequence stopped during day transition`
              );
              break;
            }

            currentMessageIndex = 0;
            dayCount++;
            console.log(`[Company ${companyId}] Starting day ${dayCount}`);
            continue; // Skip to next iteration to process first message again
          }

          console.log(
            `\n=== [Company ${companyId}] Processing Message Item ${
              currentMessageIndex + 1
            }/${messages.length} ===`
          );
          const messageItem = messages[currentMessageIndex];

          // FIXED: Validate messageItem exists
          if (!messageItem) {
            console.error(
              `[Company ${companyId}] Message item at index ${currentMessageIndex} is undefined`
            );
            console.log(`[Company ${companyId}] Messages array:`, messages);
            console.log(
              `[Company ${companyId}] Messages length:`,
              messages.length
            );
            console.log(
              `[Company ${companyId}] Current index:`,
              currentMessageIndex
            );

            // Skip this message and move to next
            currentMessageIndex++;
            continue;
          }

          console.log(`[Company ${companyId}] Current message item:`, {
            index: currentMessageIndex,
            chatId: messageItem.chatId,
            messageLength: messageItem.message?.length,
            delay: messageItem.delay,
            hasMedia: Boolean(messageItem.mediaUrl || messageItem.documentUrl),
            mediaUrl: messageItem.mediaUrl || null,
            documentUrl: messageItem.documentUrl || null,
          });

          const { chatId, message: messageText, delay } = messageItem;

          // FIXED: Validate chatId exists
          if (!chatId) {
            console.error(
              `[Company ${companyId}] chatId is undefined for message item at index ${currentMessageIndex}`
            );
            currentMessageIndex++;
            continue;
          }

          const phone = "+" + chatId.split("@")[0];

          console.log(`[Company ${companyId}] Processing chat:`, {
            chatId: chatId,
            phone: phone,
            originalPhone: chatId.split("@")[0],
          });

          console.log(
            `[Company ${companyId}] Fetching contact data for:`,
            phone
          );

          let contactData = {};

          // Determine which contacts to get for this batch
          let contactIds = [];
          if (message.multiple && message.contact_ids) {
            try {
              contactIds = safeJsonParse(
                message.contact_ids,
                [],
                `contact_ids for company ${companyId}`
              );
              console.log(
                `[Company ${companyId}] Using multiple contact IDs:`,
                contactIds
              );
            } catch (e) {
              console.warn(
                `[Company ${companyId}] Could not parse contact_ids:`,
                {
                  error: e.message,
                  contact_ids: message.contact_ids,
                  type: typeof message.contact_ids,
                }
              );
              contactIds = [];
            }
          } else if (message.contact_id) {
            contactIds = [message.contact_id];
            console.log(
              `[Company ${companyId}] Using single contact ID:`,
              contactIds
            );
          } else {
            console.log(
              `[Company ${companyId}] No contact IDs specified, will use phone lookup`
            );
          }

          // Fetch contact by ID if available, otherwise by phone
          if (contactIds.length > 0) {
            console.log(
              `[Company ${companyId}] Looking up contact by ID and phone`
            );
            const contactQuery = `
              SELECT * FROM contacts 
              WHERE company_id = $1 AND contact_id = ANY($2::text[]) AND phone = $3
            `;
            const contactResult = await client.query(contactQuery, [
              companyId,
              contactIds,
              phone,
            ]);

            if (contactResult.rowCount > 0) {
              contactData = contactResult.rows[0];
              console.log(
                `[Company ${companyId}] Found contact by ID and phone:`,
                {
                  contactId: contactData.contact_id,
                  name: contactData.name,
                  phone: contactData.phone,
                }
              );
            } else {
              console.log(
                `[Company ${companyId}] No contact found by ID and phone, trying phone-only lookup`
              );
              const phoneContactQuery = `
                SELECT * FROM contacts 
                WHERE company_id = $1 AND phone = $2
              `;
              const phoneContactResult = await client.query(phoneContactQuery, [
                companyId,
                phone,
              ]);
              contactData =
                phoneContactResult.rowCount > 0
                  ? phoneContactResult.rows[0]
                  : {};
              console.log(`[Company ${companyId}] Phone-only lookup result:`, {
                found: phoneContactResult.rowCount > 0,
                contactId: contactData.contact_id || null,
                name: contactData.name || null,
              });
            }
          } else {
            console.log(
              `[Company ${companyId}] Looking up contact by phone only`
            );
            const contactQuery = `
              SELECT * FROM contacts 
              WHERE company_id = $1 AND phone = $2
            `;
            const contactResult = await client.query(contactQuery, [
              companyId,
              phone,
            ]);
            contactData =
              contactResult.rowCount > 0 ? contactResult.rows[0] : {};
            console.log(`[Company ${companyId}] Phone lookup result:`, {
              found: contactResult.rowCount > 0,
              contactId: contactData.contact_id || null,
              name: contactData.name || null,
            });
          }

          console.log(`[Company ${companyId}] Contact data summary:`, {
            exists: Object.keys(contactData).length > 0,
            contactId: contactData.contact_id || null,
            name: contactData.name || null,
            phone: contactData.phone || null,
            tags: contactData.tags || null,
            customFields: contactData.custom_fields ? "Present" : "None",
          });

          // Check for stop bot tag
          if (
            companyId === "0128" &&
            contactData.tags &&
            contactData.tags.includes("stop bot")
          ) {
            console.log(
              `[Company ${companyId}] Skipping message - contact has 'stop bot' tag`
            );
            totalMessagesSkipped++;
            currentMessageIndex++;
            continue;
          }

          const processedMessageText = processMessage(
            messageText || message.message_content,
            contactData
          );

          const today = new Date().toISOString().split("T")[0];
          const contentHash = Buffer.from(processedMessageText)
            .toString("base64")
            .substring(0, 20);
          const messageIdentifier = `${today}_${currentMessageIndex}_${contentHash}`;

          console.log(`[Company ${companyId}] Message identifier:`, {
            today: today,
            currentIndex: currentMessageIndex,
            contentHash: contentHash,
            identifier: messageIdentifier,
          });

          const sentCheckQuery = `
            SELECT 1 FROM sent_messages 
            WHERE company_id = $1 AND chat_id = $2 AND identifier = $3
          `;
          const sentCheck = await client.query(sentCheckQuery, [
            companyId,
            chatId,
            messageIdentifier,
          ]);

          if (sentCheck.rowCount > 0) {
            console.log(
              `[Company ${companyId}] Skipping message - already sent`
            );
            totalMessagesSkipped++;
            currentMessageIndex++;
            continue;
          }

          console.log(`[Company ${companyId}] Message prepared:`, {
            originalLength: messageText?.length,
            processedLength: processedMessageText?.length,
            hasPlaceholders: messageText !== processedMessageText,
            identifier: messageIdentifier,
          });

          if (delay > 0) {
            console.log(
              `[Company ${companyId}] Adding delay of ${delay} seconds`
            );
            await new Promise((resolve) => setTimeout(resolve, delay * 1000));
          }

          try {
            console.log(`\n=== [Company ${companyId}] Sending Message ===`);

            const mediaUrl = messageItem.mediaUrl || message.media_url || "";
            const documentUrl =
              messageItem.documentUrl || message.document_url || "";
            const fileName = messageItem.fileName || message.file_name || "";

            // Use direct WhatsApp client instead of HTTP API
            const whatsappClient = botData[message.phone_index].client;

            if (!whatsappClient || !whatsappClient.info) {
              throw new Error("WhatsApp client not ready");
            }

            let messageResult;

            if (mediaUrl) {
              // Send image message using MessageMedia for whatsapp-web.js
              const media = await MessageMedia.fromUrl(mediaUrl);
              messageResult = await whatsappClient.sendMessage(chatId, media, {
                caption: processedMessageText || "",
              });
            } else if (documentUrl) {
              // Send document message using MessageMedia for whatsapp-web.js
              const media = await MessageMedia.fromUrl(documentUrl, {
                filename: fileName || "document",
              });
              messageResult = await whatsappClient.sendMessage(chatId, media, {
                caption: processedMessageText || "",
              });
            } else {
              // Send text message
              messageResult = await whatsappClient.sendMessage(
                chatId,
                processedMessageText || message.message_content || ""
              );
            }

            if (!messageResult) {
              throw new Error(
                "Failed to send WhatsApp message - no result returned"
              );
            }

            console.log(`[Company ${companyId}] WhatsApp message sent:`, {
              messageId: messageResult?.id?._serialized || "unknown",
              chatId: chatId,
              type: mediaUrl ? "image" : documentUrl ? "document" : "text",
            });

            await client.query(
              `INSERT INTO sent_messages (
                company_id, chat_id, identifier, sent_at, 
                message_index, message_content, message_type,
                media_url, document_url
              ) VALUES ($1, $2, $3, NOW(), $4, $5, $6, $7, $8)`,
              [
                companyId,
                chatId,
                messageIdentifier,
                currentMessageIndex,
                processedMessageText,
                mediaUrl ? "image" : documentUrl ? "document" : "text",
                mediaUrl || null,
                documentUrl || null,
              ]
            );

            console.log(
              `[Company ${companyId}] Recorded message as sent with ID: ${messageIdentifier}`
            );
            totalMessagesSent++;

            const messageTime = Date.now() - loopStartTime;
            console.log(
              `[Company ${companyId}] Message sent successfully in ${messageTime}ms`
            );
          } catch (error) {
            console.error(
              `\n=== [Company ${companyId}] Message Send Error ===`
            );
            console.error(`[Company ${companyId}] Error details:`, {
              name: error.name,
              message: error.message,
              stack: error.stack,
              chatId: chatId,
              phone: phone,
              messageIndex: currentMessageIndex,
            });

            await client.query(
              `INSERT INTO error_logs (
                company_id, message_id, error_type, 
                error_message, stack_trace, timestamp
              ) VALUES ($1, $2, $3, $4, $5, NOW())`,
              [
                companyId,
                message.id || "No messageId",
                error.name,
                error.message,
                error.stack,
              ]
            );

            totalErrors++;
            throw error;
          }

          currentMessageIndex++;

          // Check if we need to sleep after a certain number of messages
          if (
            message.activate_sleep &&
            message.sleep_after_messages &&
            message.sleep_duration
          ) {
            if (currentMessageIndex % message.sleep_after_messages === 0) {
              console.log(
                `[Company ${companyId}] Sleeping for ${message.sleep_duration} seconds after ${message.sleep_after_messages} messages`
              );
              await new Promise((resolve) =>
                setTimeout(resolve, message.sleep_duration * 1000)
              );
            }
          }

          console.log(`\n=== [Company ${companyId}] Sequence Status ===`);
          console.log({
            currentIndex: currentMessageIndex,
            totalMessages: messages.length,
            dayCount: dayCount,
            willContinue:
              currentMessageIndex < messages.length || message.infinite_loop,
            totalSent: totalMessagesSent,
            totalSkipped: totalMessagesSkipped,
            totalErrors: totalErrors,
            consecutiveErrors: consecutiveErrors,
          });

          consecutiveErrors = 0; // Reset on successful message
        } catch (error) {
          console.error(`[Company ${companyId}] Error in message processing:`, {
            error: error.message,
            stack: error.stack,
            currentIndex: currentMessageIndex,
            consecutiveErrors: consecutiveErrors + 1,
            messagesLength: messages.length,
            messageItem: messages[currentMessageIndex] || "undefined",
          });

          consecutiveErrors++;
          totalErrors++;

          if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
            console.error(
              `[Company ${companyId}] Max consecutive errors reached (${MAX_CONSECUTIVE_ERRORS}), stopping sequence`
            );
            break;
          }

          console.log(
            `[Company ${companyId}] Waiting 1 minute before retrying...`
          );
          await new Promise((resolve) => setTimeout(resolve, 60000));
        }
      }

      const totalTime = Date.now() - startTime;
      console.log(
        `\n=== [Company ${companyId}] sendScheduledMessage Complete ===`
      );
      console.log(`[Company ${companyId}] Final statistics:`, {
        totalTime: `${totalTime}ms`,
        totalMessages: messages.length,
        totalSent: totalMessagesSent,
        totalSkipped: totalMessagesSkipped,
        totalErrors: totalErrors,
        dayCount: dayCount,
        success: true,
      });

      // FIXED: Return statement now has access to all variables
      return {
        success: true,
        statistics: {
          totalTime: Date.now() - startTime,
          totalMessages: messages.length,
          totalSent: totalMessagesSent,
          totalSkipped: totalMessagesSkipped,
          totalErrors: totalErrors,
          dayCount: dayCount,
        },
      };
    } else {
      console.log(`[Company ${companyId}] Message is not V2 - skipping`);
      return {
        success: false,
        error: "Message is not V2 format",
        details: {
          messageId: message.id,
          companyId: companyId,
        },
      };
    }
  } catch (error) {
    const totalTime = Date.now() - startTime;
    console.error(
      `\n=== [Company ${companyId}] sendScheduledMessage Error ===`
    );
    console.error(`[Company ${companyId}] Error details:`, {
      name: error.name,
      message: error.message,
      stack: error.stack,
      totalTime: `${totalTime}ms`,
      phoneIndex: message.phone_index,
      messageId: message.id,
    });

    return {
      success: false,
      error: error.message,
      details: {
        name: error.name,
        stack: error.stack,
        totalTime: totalTime,
        phoneIndex: message.phone_index,
        messageId: message.id,
      },
    };
  } finally {
    if (client) {
      await safeRelease(client);
    }
  }
}

async function scheduleAllMessages(specificCompanyId = null) {
  const client = await pool.connect();
  try {
    console.log(
      `🔄 Scheduling all previous scheduled messages${
        specificCompanyId ? ` for company ${specificCompanyId}` : ""
      }...`
    );

    // Build query based on whether we're targeting a specific company
    let companiesQuery, companiesValues;
    if (specificCompanyId) {
      companiesQuery = `
        SELECT DISTINCT company_id FROM scheduled_messages
        WHERE status NOT IN ('completed', 'sent', 'stopped')
        AND company_id = $1
      `;
      companiesValues = [specificCompanyId];
    } else {
      companiesQuery = `
        SELECT DISTINCT company_id FROM scheduled_messages
        WHERE status NOT IN ('completed', 'sent', 'stopped')
      `;
      companiesValues = [];
    }

    const companiesResult = await client.query(companiesQuery, companiesValues);
    console.log(`📋 Found ${companiesResult.rows.length} companies with scheduled messages`);

    for (const companyRow of companiesResult.rows) {
      const companyId = companyRow.company_id;

      // Skip API URL check if we're targeting a specific company
      if (!specificCompanyId) {
        const apiUrlQuery = `
          SELECT api_url FROM companies WHERE company_id = $1
        `;
        const apiUrlResult = await client.query(apiUrlQuery, [companyId]);
        const companyApiUrl = apiUrlResult.rows[0]?.api_url;

        if (companyApiUrl !== "https://bisnesgpt.jutateknologi.com") {
          console.log(`⏭️ Skipping company ${companyId} - different API URL`);
          continue;
        }
      }

      console.log(`🤖 Initializing queue and worker for company ${companyId}...`);
      const queue = getQueueForBot(companyId);
      
      // Verify queue is ready
      await queue.waitUntilReady();
      console.log(`✅ Queue ready for company ${companyId}`);

      // Get all scheduled messages that need to be processed
      const messagesQuery = `
        SELECT * FROM scheduled_messages
        WHERE company_id = $1
        AND status = 'scheduled'
        AND scheduled_time > NOW()
        ORDER BY scheduled_time ASC
      `;
      const messagesResult = await client.query(messagesQuery, [companyId]);

      console.log(
        `📨 Found ${messagesResult.rows.length} scheduled messages for company ${companyId} (scheduled_time > NOW())`
      );
      
      // Also log how many are in the past (for debugging)
      const pastMessagesQuery = `
        SELECT COUNT(*) as past_count FROM scheduled_messages
        WHERE company_id = $1
        AND status = 'scheduled'
        AND scheduled_time <= NOW()
      `;
      const pastMessagesResult = await client.query(pastMessagesQuery, [companyId]);
      const pastCount = pastMessagesResult.rows[0]?.past_count || 0;
      
      if (pastCount > 0) {
        console.log(
          `⚠️ Warning: ${pastCount} scheduled messages for company ${companyId} have scheduled_time in the past (these will NOT be rescheduled)`
        );
      }

      for (const message of messagesResult.rows) {
        const messageId = message.id;
        const scheduleId = message.schedule_id;
        const delay = new Date(message.scheduled_time).getTime() - Date.now();

        // Skip if scheduled time has already passed
        if (delay < 0) {
          console.log(`⏭️ Skipping message ${messageId} - scheduled time has passed (delay: ${delay}ms)`);
          continue;
        }

        // Check if this is a batch message or a main message
        const isBatch = messageId !== scheduleId;

        if (isBatch) {
          // This is a batch message
          console.log(
            `📦 Checking batch message ${messageId} for schedule ${scheduleId} (delay: ${Math.round(delay/1000)}s)`
          );
          // Verify parent schedule still exists and is scheduled (protect against deleted main rows)
          try {
            const parentCheckQuery = `SELECT id, status FROM scheduled_messages WHERE id = $1 AND company_id = $2 LIMIT 1`;
            const parentCheck = await client.query(parentCheckQuery, [
              scheduleId,
              companyId,
            ]);
            if (parentCheck.rowCount === 0) {
              console.log(
                `Parent schedule ${scheduleId} not found for batch ${messageId} - skipping`
              );
              continue;
            }

            const parentStatus = parentCheck.rows[0].status;
            if (parentStatus !== "scheduled") {
              console.log(
                `Parent schedule ${scheduleId} status is '${parentStatus}' (not 'scheduled') - skipping batch ${messageId}`
              );
              continue;
            }
          } catch (checkErr) {
            console.error(
              `Error verifying parent schedule ${scheduleId} for batch ${messageId}:`,
              checkErr
            );
            continue;
          }
          // Double-check the batch row still exists and is scheduled. If not, remove any queued job and skip.
          try {
            const msgCheck = await client.query(
              `SELECT id, status FROM scheduled_messages WHERE id = $1 AND company_id = $2 LIMIT 1`,
              [messageId, companyId]
            );

            if (msgCheck.rowCount === 0) {
              console.log(
                `Batch message ${messageId} no longer exists in DB for company ${companyId} - removing queued job (if any) and skipping`
              );
              const existingJob = await queue.getJob(messageId);
              if (existingJob) {
                try {
                  await existingJob.remove();
                  console.log(
                    `Removed queued job ${messageId} for company ${companyId} because DB row is gone`
                  );
                } catch (rmErr) {
                  console.error(
                    `Failed to remove queued job ${messageId} for company ${companyId}:`,
                    rmErr
                  );
                }
              }
              continue;
            }

            if (msgCheck.rows[0].status !== "scheduled") {
              console.log(
                `Batch message ${messageId} status is '${msgCheck.rows[0].status}' (not 'scheduled') - removing queued job (if any) and skipping`
              );
              const existingJob = await queue.getJob(messageId);
              if (existingJob) {
                try {
                  await existingJob.remove();
                  console.log(
                    `Removed queued job ${messageId} for company ${companyId} because status changed`
                  );
                } catch (rmErr) {
                  console.error(
                    `Failed to remove queued job ${messageId} for company ${companyId}:`,
                    rmErr
                  );
                }
              }
              continue;
            }
          } catch (msgErr) {
            console.error(
              `Error verifying batch message ${messageId} before scheduling:`,
              msgErr
            );
            continue;
          }

          const existingJob = await queue.getJob(messageId);
          if (!existingJob) {
            console.log(
              `Scheduling batch message ${messageId} for schedule ${scheduleId} with delay ${delay}ms`
            );
            await queue.add(
              "send-message-batch",
              {
                companyId,
                messageId: scheduleId,
                batchId: messageId,
              },
              {
                removeOnComplete: false,
                removeOnFail: false,
                delay: Math.max(delay, 0),
                jobId: messageId,
              }
            );
          }
        } else {
          console.log(
            `Checking main message ${messageId} with delay ${delay}ms`
          );
          const batchesQuery = `
            SELECT COUNT(*) as batch_count FROM scheduled_messages 
            WHERE company_id = $1 
            AND schedule_id = $2
            AND id::text != schedule_id::text
            AND status = 'scheduled'
          `;
          const batchesResult = await client.query(batchesQuery, [
            companyId,
            messageId,
          ]);
          const hasBatches = batchesResult.rows[0].batch_count > 0;

          if (!hasBatches) {
            console.log(
              `Scheduling main message ${messageId} with delay ${delay}ms`
            );
            // Double-check the main message still exists and is scheduled. If not, remove queued job and skip.
            try {
              const msgCheck = await client.query(
                `SELECT id, status FROM scheduled_messages WHERE id = $1 AND company_id = $2 LIMIT 1`,
                [messageId, companyId]
              );

              if (msgCheck.rowCount === 0) {
                console.log(
                  `Main message ${messageId} no longer exists in DB for company ${companyId} - removing queued job (if any) and skipping`
                );
                const existingJob = await queue.getJob(messageId);
                if (existingJob) {
                  try {
                    await existingJob.remove();
                    console.log(
                      `Removed queued job ${messageId} for company ${companyId} because DB row is gone`
                    );
                  } catch (rmErr) {
                    console.error(
                      `Failed to remove queued job ${messageId} for company ${companyId}:`,
                      rmErr
                    );
                  }
                }
                continue;
              }

              if (msgCheck.rows[0].status !== "scheduled") {
                console.log(
                  `Main message ${messageId} status is '${msgCheck.rows[0].status}' (not 'scheduled') - removing queued job (if any) and skipping`
                );
                const existingJob = await queue.getJob(messageId);
                if (existingJob) {
                  try {
                    await existingJob.remove();
                    console.log(
                      `Removed queued job ${messageId} for company ${companyId} because status changed`
                    );
                  } catch (rmErr) {
                    console.error(
                      `Failed to remove queued job ${messageId} for company ${companyId}:`,
                      rmErr
                    );
                  }
                }
                continue;
              }
            } catch (msgErr) {
              console.error(
                `Error verifying main message ${messageId} before scheduling:`,
                msgErr
              );
              continue;
            }

            const existingJob = await queue.getJob(messageId);
            if (!existingJob) {
              await queue.add(
                "send-single-message",
                {
                  companyId,
                  messageId,
                },
                {
                  removeOnComplete: false,
                  removeOnFail: false,
                  delay: Math.max(delay, 0),
                  jobId: messageId,
                }
              );
            }
          }
        }
      }
    }

    console.log(
      `Finished scheduling messages${
        specificCompanyId ? ` for company ${specificCompanyId}` : ""
      }`
    );
  } catch (error) {
    console.error("Error in scheduleAllMessages:", error);
  } finally {
    await safeRelease(client);
  }
}

// Add this import at the top of server.js
const { broadcastNewMessageToCompany } = require("./utils/broadcast");
const {
  handleNewMessagesTemplateWweb,
} = require("./bots/handleMessagesTemplateWweb.js");

function setupMessageHandler(client, botName, phoneIndex) {
  client.on("message", async (msg) => {
    try {
      // Validate message object
      if (!msg) {
        console.error(`🔔 [MESSAGE_HANDLER] ❌ Received null/undefined message for bot ${botName}`);
        return;
      }

      console.log(`🔔 [MESSAGE_HANDLER] ===== INCOMING MESSAGE =====`);
      console.log(`🔔 [MESSAGE_HANDLER] Bot: ${botName}`);
      console.log(`🔔 [MESSAGE_HANDLER] From: ${msg.from}`);
      console.log(`🔔 [MESSAGE_HANDLER] Body: ${msg.body}`);
      console.log(`🔔 [MESSAGE_HANDLER] Type: ${msg.type}`);
      console.log(`🔔 [MESSAGE_HANDLER] From Me: ${msg.fromMe}`);
      console.log(`🔔 [MESSAGE_HANDLER] Timestamp: ${msg.timestamp}`);
      console.log(`🔔 [MESSAGE_HANDLER] ID: ${msg.id?._serialized || 'No ID'}`);

      // Filter out status messages before processing
      const chatId = msg.from;
      if (
        chatId.includes("status") ||
        chatId.includes("newsletter") ||
        chatId.includes("status@broadcast")
      ) {
        console.log(
          `🔔 [MESSAGE_HANDLER] ❌ Status message filtered out - skipping processing and broadcast`
        );
        console.log(`🔔 [MESSAGE_HANDLER] ===== INCOMING MESSAGE END =====`);
        return;
      }

      await handleNewMessagesTemplateWweb(client, msg, botName, phoneIndex);

      // Add broadcast call here - using safe extraction
      const extractedNumber = await safeExtractPhoneNumber(msg, client);
      if (!extractedNumber) {
        console.log(
          `🔔 [MESSAGE_HANDLER] ❌ Could not extract phone number, skipping broadcast`
        );
        return;
      }

      const cleanExtractedNumber = extractedNumber.replace("+", "");
      const messageData = {
        chatId: msg.from,
        message: msg.body,
        extractedNumber: extractedNumber,
        contactId: `${botName}-${cleanExtractedNumber}`,
        fromMe: msg.fromMe,
        timestamp: Math.floor(Date.now() / 1000),
        messageType: msg.type,
        contactName: msg.notifyName || cleanExtractedNumber,
      };

      console.log(
        `🔔 [MESSAGE_HANDLER] Calling broadcastNewMessageToCompany with company: ${botName}`
      );
      broadcastNewMessageToCompany(botName, messageData);

      console.log(`🔔 [MESSAGE_HANDLER] ✅ Message processed successfully`);
      console.log(`🔔 [MESSAGE_HANDLER] ===== INCOMING MESSAGE END =====`);
    } catch (error) {
      console.error(
        `🔔 [MESSAGE_HANDLER] ❌ Error in message handling:`,
        error
      );
      console.error(`🔔 [MESSAGE_HANDLER] Error message:`, error?.message || 'No message');
      console.error(`🔔 [MESSAGE_HANDLER] Error stack:`, error?.stack || 'No stack trace');
      console.error(`🔔 [MESSAGE_HANDLER] Error type:`, typeof error);
      console.error(`🔔 [MESSAGE_HANDLER] Error keys:`, Object.keys(error || {}));
    }
  });
}

function setupMessageCreateHandler(client, botName, phoneIndex) {
  client.on("message_create", async (msg) => {
    broadcastBotActivity(botName, true);
    try {
      console.log("My WhatsApp number:", client.info.wid.user);
      if (botName === "049815") {
        console.log(`=== MessageCreateHandler for bot ${botName} ===`);
        console.log("Message details:", msg);
        const chat = await msg.getChat();
        console.log("[MessageCreateHandler] Chat details:", chat);
        const contact = await chat.getContact();
        console.log("[MessageCreateHandler] Contact details:", contact);
        console.log(
          "[MessageCreateHandler] Contact Chat ID:",
          contact.id._serialized
        );
      }
      const isFromHuman = msg.fromMe && msg.author;
      if (msg.fromMe) {
        const extractedNumber = await safeExtractToPhoneNumber(msg, client);
        if (!extractedNumber) {
          console.error(
            `❌ [MessageCreateHandler] Could not extract phone number from msg.to, skipping`
          );
          return;
        }

        const cleanExtractedNumber = extractedNumber.replace("+", "");
        const contactID = botName + "-" + cleanExtractedNumber;
        const myNumber = "+" + client.info.wid.user;
        if (extractedNumber === myNumber) {
          return;
        }
        const companyId = botName;
        const chatId = msg.to;
        const phoneNumber = extractedNumber;

        // 1. Ensure contact exists in SQL
        let contactResult;
        try {
          contactResult = await sqlDb.query(
            `INSERT INTO contacts (contact_id, phone, company_id, name, last_updated)
             VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
             RETURNING *`,
            [contactID, phoneNumber, companyId, phoneNumber] // Use phoneNumber as fallback name
          );
        } catch (err) {
          if (err.code === "23505") {
            contactResult = await sqlDb.query(
              `UPDATE contacts 
               SET last_updated = CURRENT_TIMESTAMP
               WHERE contact_id = $1 AND company_id = $2
               RETURNING *`,
              [contactID, companyId]
            );
          } else {
            throw err;
          }
        }

        // 2. Save the message to SQL
        const { type } = addMessageToPostgres(
          msg,
          companyId,
          extractedNumber,
          contactResult.rows[0]?.name,
          phoneIndex
        );

        // 3. Update contact's last_message in SQL
        await sqlDb.query(
          `UPDATE contacts 
           SET last_message = $1, last_updated = CURRENT_TIMESTAMP
           WHERE contact_id = $2 AND company_id = $3`,
          [
            JSON.stringify({
              chat_id: chatId,
              from: msg.from,
              from_me: true,
              id: msg.id._serialized,
              phoneIndex: phoneIndex,
              source: "",
              status: "sent",
              text: { body: msg.body },
              timestamp: Math.floor(Date.now() / 1000),
              type: type,
            }),
            contactID,
            companyId,
          ]
        );

        // 4. Handle OpenAI thread logic
        let threadId = contactResult.rows[0]?.thread_id;
        if (isFromHuman) {
          if (threadId) {
            await handleOpenAIMyMessage(msg.body, threadId);
          } else {
            try {
              const thread = await createThread();
              threadId = thread.id;
              await sqlDb.query(
                `UPDATE contacts SET thread_id = $1 WHERE contact_id = $2 AND company_id = $3`,
                [threadId, contactID, companyId]
              );
              await handleOpenAIMyMessage(msg.body, threadId);
            } catch (error) {
              console.error("Error creating AI thread:", error);
            }
          }
        }

        // 4.5. Handle AI Responses for Own Messages
        console.log(
          "\n=== Processing AI Responses in MessageCreateHandler ==="
        );
        const contactData = await getContactDataFromDatabaseByPhone(
          extractedNumber,
          botName
        );
        await fetchConfigFromDatabase(botName);

        const handlerParams = {
          client: client,
          msg: msg.body,
          idSubstring: botName,
          extractedNumber: extractedNumber,
          contactName:
            contactData?.name || contactData?.contact_name || extractedNumber,
          phoneIndex: phoneIndex,
        };

        // Process AI responses for 'user'
        await processAIResponses({
          ...handlerParams,
          keywordSource: "own",
          handlers: {
            assign: true,
            tag: true,
            followUp: true,
            document: true,
            image: true,
            video: true,
            voice: true,
          },
        }); // Add broadcast call here
        const messageData = {
          chatId: msg.to,
          message: msg.body,
          extractedNumber: extractedNumber,
          contactId: `${botName}-${cleanExtractedNumber}`,
          fromMe: msg.fromMe,
          timestamp: Math.floor(Date.now() / 1000),
          messageType: msg.type,
          contactName: cleanExtractedNumber,
        };

        console.log(
          `🔔 [MESSAGE_CREATE] Calling broadcastNewMessageToCompany with company: ${botName}`
        );
        broadcastNewMessageToCompany(botName, messageData);

        // 5. Handle bot tags for certain companies
        if (
          isFromHuman &&
          [
            "0100",
            "0145",
            "0128",
            "020",
            "001",
            "0123",
            "0119",
            "0102",
            "0156",
            "058666"
          ].includes(companyId)
        ) {
          await sqlDb.query(
            `UPDATE contacts 
             SET tags = COALESCE(tags, '[]'::jsonb) || '"stop bot"'::jsonb
             WHERE contact_id = $1 AND company_id = $2`,
            [contactID, companyId]
          );
        }

        // Clear the "active" status after 10 seconds of no messages
        setTimeout(() => {
          broadcastBotActivity(botName, false);
        }, 10000);
      }
    } catch (error) {
      console.error(
        `ERROR in message_create handling for bot ${botName}:`,
        error
      );
    }
  });
}

async function fetchConfigFromDatabase(idSubstring) {
  let sqlClient;
  try {
    sqlClient = await pool.connect();

    const query = `
      SELECT *
      FROM public.companies 
      WHERE company_id = $1
    `;

    const result = await sqlClient.query(query, [idSubstring]);

    if (result.rows.length === 0) {
      console.log("No such company found!");
      return;
    }

    companyConfig = result.rows[0];
    console.log(`CompanyConfig for company ${idSubstring}:`, companyConfig);
  } catch (error) {
    console.error("Error fetching config:", error);
  } finally {
    if (sqlClient) {
      await safeRelease(sqlClient);
    }
  }
}

// Modular function to process all AI responses
async function processAIResponses({
  client,
  msg,
  idSubstring,
  extractedNumber,
  contactName,
  phoneIndex,
  keywordSource,
  handlers = {
    assign: true,
    tag: true,
    followUp: true,
    document: true,
    image: true,
    video: true,
    voice: true,
  },
}) {
  console.log(`[processAIResponses] Starting for company ${idSubstring}`);

  let followUpTemplates = [];
  try {
    followUpTemplates = await getFollowUpTemplates(idSubstring);
  } catch (error) {
    console.error(
      `[processAIResponses] Error getting follow-up templates for company ${idSubstring}:`,
      error
    );
    followUpTemplates = [];
  }

  const chatid = formatPhoneNumber(extractedNumber) + "@c.us";

  const handlerParams = {
    client: client,
    message: msg,
    chatId: chatid,
    extractedNumber: extractedNumber,
    idSubstring: idSubstring,
    contactName: contactName,
    phoneIndex: phoneIndex,
    keywordSource: keywordSource,
  };

  // Handle user-triggered responses
  if (handlers.assign) {
    await handleAIAssignResponses({
      ...handlerParams,
    });
  }

  if (handlers.tag) {
    await handleAITagResponses({
      ...handlerParams,
      followUpTemplates: followUpTemplates,
    });
  }

  if (handlers.followUp) {
    await handleAIFollowUpResponses({
      ...handlerParams,
      followUpTemplates: followUpTemplates,
    });
  }

  if (handlers.document) {
    await handleAIDocumentResponses({
      ...handlerParams,
    });
  }

  if (handlers.image) {
    await handleAIImageResponses({
      ...handlerParams,
    });
  }

  if (handlers.video) {
    await handleAIVideoResponses({
      ...handlerParams,
    });
  }

  if (handlers.voice) {
    await handleAIVoiceResponses({
      ...handlerParams,
    });
  }
}

app.post("/api/upload-media", upload.single("file"), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: "No file uploaded" });
  }
  const baseUrl = process.env.URL;
  const fileUrl = `${baseUrl}/media/${req.file.filename}`;
  res.json({ url: fileUrl });
});

// New file upload endpoint for general file uploads
app.post("/api/upload-file", upload.single("file"), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: "No file uploaded" });
    }

    // Get additional parameters
    const { fileName, companyId } = req.body;

    // Validate required fields
    if (!fileName) {
      return res.status(400).json({ error: "fileName is required" });
    }

    const baseUrl = process.env.URL;
    const fileUrl = `${baseUrl}/media/${req.file.filename}`;

    // Log the upload for debugging
    console.log(
      `File uploaded: ${req.file.originalname} -> ${req.file.filename}`
    );
    console.log(`Company ID: ${companyId}`);
    console.log(`Requested filename: ${fileName}`);

    res.json({
      success: true,
      url: fileUrl,
      filename: req.file.filename,
      originalName: req.file.originalname,
      size: req.file.size,
    });
  } catch (error) {
    console.error("Error uploading file:", error);
    res.status(500).json({
      success: false,
      error: "Failed to upload file",
    });
  }
});

// Create a new follow-up template
app.post("/api/followup-templates", async (req, res) => {
  console.log("=== Starting POST /api/followup-templates ===");
  console.log("Request body:", JSON.stringify(req.body, null, 2));

  const {
    companyId,
    name,
    status = "active",
    createdAt,
    startTime,
    isCustomStartTime,
    trigger_tags = [],
    trigger_keywords = [],
    batchSettings = {},
  } = req.body;

  // Validation
  if (!companyId) {
    console.error("Missing companyId");
    return res
      .status(400)
      .json({ success: false, message: "Missing companyId" });
  }

  if (!name || !name.trim()) {
    console.error("Missing or empty template name");
    return res
      .status(400)
      .json({ success: false, message: "Template name is required" });
  }

  const sqlClient = await pool.connect();

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    // Generate template_id (UUID)
    const templateId = require("crypto").randomUUID();
    console.log("Generated template ID:", templateId);

    // Insert the template
    const insertTemplateQuery = `
      INSERT INTO public.followup_templates (
        id,
        template_id,
        company_id,
        name,
        created_at,
        updated_at,
        trigger_keywords,
        trigger_tags,
        keyword_source,
        status,
        content,
        delay_hours
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING *
    `;

    const templateParams = [
      require("crypto").randomUUID(), // id (UUID)
      templateId, // template_id
      companyId,
      name.trim(),
      createdAt ? new Date(createdAt) : new Date(),
      new Date(),
      Array.isArray(trigger_keywords) ? trigger_keywords : [],
      Array.isArray(trigger_tags) ? trigger_tags : [],
      "bot", // default keyword_source
      status,
      "", // default content (empty for now)
      24, // default delay_hours
    ];

    console.log("Executing template insert with params:", templateParams);
    const templateResult = await sqlClient.query(
      insertTemplateQuery,
      templateParams
    );
    console.log("Template inserted successfully:", templateResult.rows[0]);

    // If batchSettings has messages, insert them into followup_messages
    if (batchSettings.messages && Array.isArray(batchSettings.messages)) {
      console.log(`Inserting ${batchSettings.messages.length} messages`);

      for (let i = 0; i < batchSettings.messages.length; i++) {
        const message = batchSettings.messages[i];
        console.log(`Processing message ${i + 1}:`, message);

        const insertMessageQuery = `
          INSERT INTO public.followup_messages (
            id,
            template_id,
            message,
            day_number,
            sequence,
            status,
            created_at,
            document,
            image,
            video,
            delay_after,
            specific_numbers,
            use_scheduled_time,
            scheduled_time,
            add_tags,
            remove_tags
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
        `;

        const messageParams = [
          require("crypto").randomUUID(), // id
          templateId, // template_id
          message.content || "",
          message.dayNumber || 0,
          message.sequence || i + 1,
          "active",
          new Date(),
          message.document || null,
          message.image || null,
          message.video || null,
          message.delayAfter ? JSON.stringify(message.delayAfter) : null,
          message.specificNumbers
            ? JSON.stringify(message.specificNumbers)
            : null,
          message.useScheduledTime || false,
          message.scheduledTime || null,
          Array.isArray(message.addTags) ? message.addTags : [],
          Array.isArray(message.removeTags) ? message.removeTags : [],
        ];

        console.log(`Inserting message ${i + 1} with params:`, messageParams);
        await sqlClient.query(insertMessageQuery, messageParams);
        console.log(`Message ${i + 1} inserted successfully`);
      }
    }

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");

    // Return the created template
    const createdTemplate = {
      id: templateResult.rows[0].id,
      templateId: templateResult.rows[0].template_id,
      companyId: templateResult.rows[0].company_id,
      name: templateResult.rows[0].name,
      createdAt: templateResult.rows[0].created_at,
      updatedAt: templateResult.rows[0].updated_at,
      triggerKeywords: templateResult.rows[0].trigger_keywords || [],
      triggerTags: templateResult.rows[0].trigger_tags || [],
      keywordSource: templateResult.rows[0].keyword_source,
      status: templateResult.rows[0].status,
      content: templateResult.rows[0].content,
      delayHours: templateResult.rows[0].delay_hours,
    };

    console.log("Returning created template:", createdTemplate);
    console.log("=== Completed POST /api/followup-templates ===");

    res.status(201).json({
      success: true,
      message: "Template created successfully",
      template: createdTemplate,
    });
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("=== Error in POST /api/followup-templates ===");
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);
    console.error("Full error:", error);

    res.status(500).json({
      success: false,
      message: "Failed to create template",
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});

async function getFollowUpTemplates(companyId) {
  console.log("Starting getFollowUpTemplates for companyId:", companyId);
  const templates = [];
  const sqlClient = await pool.connect();

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        id,
        template_id,
        company_id,
        name,
        created_at,
        updated_at,
        trigger_keywords,
        trigger_tags,
        keyword_source,
        status,
        content,
        delay_hours
      FROM 
        public.followup_templates
      WHERE 
        company_id = $1
      ORDER BY created_at DESC
    `;

    const result = await sqlClient.query(query, [companyId]);

    for (const row of result.rows) {
      const templateObj = {
        id: row.id,
        templateId: row.template_id,
        companyId: row.company_id,
        name: row.name,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        triggerKeywords: Array.isArray(row.trigger_keywords)
          ? row.trigger_keywords
          : [],
        triggerTags: Array.isArray(row.trigger_tags) ? row.trigger_tags : [],
        keywordSource: row.keyword_source || "bot",
        status: row.status || "active",
        content: row.content,
        delayHours: row.delay_hours || 24,
      };

      templates.push(templateObj);
    }

    await sqlClient.query("COMMIT");
    return templates;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error in getFollowUpTemplates:", error);
    return [];
  } finally {
    await safeRelease(sqlClient);
  }
}

// Add a new message to a follow-up template
app.post("/api/followup-templates/:templateId/messages", async (req, res) => {
  console.log(
    "=== Starting POST /api/followup-templates/:templateId/messages ==="
  );
  console.log("Template ID:", req.params.templateId);
  console.log("Request body:", JSON.stringify(req.body, null, 2));

  const { templateId } = req.params;
  const {
    message,
    dayNumber = 1,
    sequence = 1,
    status = "active",
    createdAt,
    document = null,
    image = null,
    video = null,
    delayAfter = null,
    specificNumbers = null,
    useScheduledTime = false,
    scheduledTime = "",
    addTags = [],
    removeTags = [],
  } = req.body;

  // Validation
  if (!templateId) {
    console.error("Missing templateId");
    return res
      .status(400)
      .json({ success: false, message: "Missing templateId" });
  }

  if (!message || !message.trim()) {
    console.error("Missing or empty message content");
    return res
      .status(400)
      .json({ success: false, message: "Message content is required" });
  }

  if (!dayNumber || dayNumber < 0) {
    console.error("Invalid day number");
    return res.status(400).json({
      success: false,
      message: "Day number must be a positive number",
    });
  }

  if (!sequence || sequence < 1) {
    console.error("Invalid sequence number");
    return res
      .status(400)
      .json({ success: false, message: "Sequence number must be at least 1" });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting message insert"
    );
    return res
      .status(500)
      .json({ success: false, message: "Failed to add message" });
  }

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    // First, verify the template exists - CAST templateId to VARCHAR to match the column type
    const templateCheckQuery = `
      SELECT id, template_id, company_id, name 
      FROM public.followup_templates 
      WHERE template_id = $1::character varying AND status = 'active'
    `;
    console.log("Checking if template exists with ID:", templateId);
    const templateCheckResult = await sqlClient.query(templateCheckQuery, [
      templateId,
    ]);

    if (templateCheckResult.rows.length === 0) {
      console.error(`Template not found: ${templateId}`);
      await safeRollback(sqlClient);
      return res.status(404).json({
        success: false,
        message: "Template not found or inactive",
      });
    }

    const template = templateCheckResult.rows[0];
    console.log("Template found:", template);

    // Check for duplicate message (same day and sequence) - CAST templateId to VARCHAR
    const duplicateCheckQuery = `
      SELECT id FROM public.followup_messages 
      WHERE template_id = $1::character varying AND day_number = $2 AND sequence = $3 AND status = 'active'
    `;
    console.log("Checking for duplicate message...");
    const duplicateCheckResult = await sqlClient.query(duplicateCheckQuery, [
      templateId,
      dayNumber,
      sequence,
    ]);

    if (duplicateCheckResult.rows.length > 0) {
      console.error(
        `Duplicate message found: day ${dayNumber}, sequence ${sequence}`
      );
      await safeRollback(sqlClient);
      return res.status(409).json({
        success: false,
        message: "A message with this day and sequence number already exists",
      });
    }

    // Insert the new message - CAST templateId to VARCHAR
    const insertMessageQuery = `
      INSERT INTO public.followup_messages (
        id,
        template_id,
        message,
        day_number,
        sequence,
        status,
        created_at,
        document,
        image,
        video,
        delay_after,
        specific_numbers,
        use_scheduled_time,
        scheduled_time,
        add_tags,
        remove_tags
      ) VALUES ($1, $2::character varying, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
      RETURNING *
    `;

    const messageParams = [
      require("crypto").randomUUID(), // id
      templateId, // template_id (will be cast to VARCHAR)
      message.trim(), // message
      dayNumber, // day_number
      sequence, // sequence
      status, // status
      createdAt ? new Date(createdAt) : new Date(), // created_at
      document ? JSON.stringify({ url: document }) : null, // document
      image ? JSON.stringify({ url: image }) : null, // image
      video ? JSON.stringify({ url: video }) : null, // video
      delayAfter ? JSON.stringify(delayAfter) : null, // delay_after
      specificNumbers ? JSON.stringify(specificNumbers) : null, // specific_numbers
      useScheduledTime, // use_scheduled_time
      scheduledTime || null, // scheduled_time
      Array.isArray(addTags) ? addTags : [], // add_tags
      Array.isArray(removeTags) ? removeTags : [], // remove_tags
    ];

    console.log("Executing message insert with params:", messageParams);
    const messageResult = await sqlClient.query(
      insertMessageQuery,
      messageParams
    );
    console.log("Message inserted successfully:", messageResult.rows[0]);

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");

    // Return the created message
    const createdMessage = {
      id: messageResult.rows[0].id,
      templateId: messageResult.rows[0].template_id,
      message: messageResult.rows[0].message,
      dayNumber: messageResult.rows[0].day_number,
      sequence: messageResult.rows[0].sequence,
      status: messageResult.rows[0].status,
      createdAt: messageResult.rows[0].created_at,
      document: messageResult.rows[0].document,
      image: messageResult.rows[0].image,
      video: messageResult.rows[0].video,
      delayAfter: messageResult.rows[0].delay_after,
      specificNumbers: messageResult.rows[0].specific_numbers,
      useScheduledTime: messageResult.rows[0].use_scheduled_time,
      scheduledTime: messageResult.rows[0].scheduled_time,
      addTags: messageResult.rows[0].add_tags || [],
      removeTags: messageResult.rows[0].remove_tags || [],
    };

    console.log("Returning created message:", createdMessage);
    console.log(
      "=== Completed POST /api/followup-templates/:templateId/messages ==="
    );

    res.status(201).json({
      success: true,
      message: "Message added successfully",
      data: createdMessage,
    });
  } catch (error) {
    await safeRollback(sqlClient);
    console.error(
      "=== Error in POST /api/followup-templates/:templateId/messages ==="
    );
    console.error("Template ID:", templateId);
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);
    console.error("Full error:", error);

    res.status(500).json({
      success: false,
      message: "Failed to add message",
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});

async function getMessagesForTemplate(templateId) {
  console.log("Starting getMessagesForTemplate for templateId:", templateId);
  const messages = [];
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting getMessagesForTemplate"
    );
    return [];
  }

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        id,
        template_id,
        message,
        day_number,
        sequence,
        status,
        created_at,
        document,
        image,
        video,
        delay_after,
        specific_numbers,
        use_scheduled_time,
        scheduled_time,
        add_tags,
        remove_tags
      FROM 
        public.followup_messages
      WHERE 
        template_id = $1
      ORDER BY sequence ASC, day_number ASC, created_at ASC
    `;

    console.log("Fetching followup_messages...");
    const result = await sqlClient.query(query, [templateId]);
    console.log("Found followup_messages records:", result.rows.length);

    for (const row of result.rows) {
      console.log("\nProcessing message:", row.id);
      console.log("Message data:", row);

      const messageObj = {
        id: row.id,
        templateId: row.template_id,
        message: row.message,
        dayNumber: row.day_number,
        sequence: row.sequence,
        status: row.status || "active",
        createdAt: row.created_at,
        document: row.document,
        image: row.image,
        video: row.video,
        delayAfter: row.delay_after,
        specificNumbers: row.specific_numbers,
        useScheduledTime: row.use_scheduled_time,
        scheduledTime: row.scheduled_time,
        addTags: row.add_tags || [],
        removeTags: row.remove_tags || [],
      };

      console.log("Adding message object:", messageObj);
      messages.push(messageObj);
    }

    await sqlClient.query("COMMIT");
    console.log("\nFinal messages array:", messages);
    return messages;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error in getMessagesForTemplate:", error);
    throw error;
  } finally {
    await safeRelease(sqlClient);
  }
}

// Get all follow-up templates for a company
app.get("/api/followup-templates", async (req, res) => {
  const { companyId } = req.query;
  if (!companyId) {
    return res
      .status(400)
      .json({ success: false, message: "Missing companyId" });
  }
  try {
    const templates = await getFollowUpTemplates(companyId);
    res.json({ success: true, templates });
  } catch (error) {
    console.error("Error fetching follow-up templates:", error);
    res.status(500).json({ success: false, message: "Server error" });
  }
});

// Get all messages for a specific follow-up template
app.get("/api/followup-templates/:templateId/messages", async (req, res) => {
  const { templateId } = req.params;
  if (!templateId) {
    return res
      .status(400)
      .json({ success: false, message: "Missing templateId" });
  }
  try {
    // You need to implement this function based on your DB structure
    const messages = await getMessagesForTemplate(templateId);
    res.json({ success: true, messages });
  } catch (error) {
    console.error("Error fetching template messages:", error);
    res.status(500).json({ success: false, message: "Server error" });
  }
});

// Update a follow-up template
app.put("/api/followup-templates/:templateId", async (req, res) => {
  console.log("=== Starting PUT /api/followup-templates/:templateId ===");
  console.log("Template ID:", req.params.templateId);
  console.log("Request body:", JSON.stringify(req.body, null, 2));

  const { templateId } = req.params;
  const {
    name,
    status,
    trigger_tags = [],
    trigger_keywords = [],
    batchSettings = {},
  } = req.body;

  // Validation
  if (!templateId) {
    console.error("Missing templateId");
    return res
      .status(400)
      .json({ success: false, message: "Missing templateId" });
  }

  if (!name || !name.trim()) {
    console.error("Missing or empty template name");
    return res
      .status(400)
      .json({ success: false, message: "Template name is required" });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting template update"
    );
    return res
      .status(500)
      .json({ success: false, message: "Failed to update template" });
  }

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    // Update the template
    const updateTemplateQuery = `
      UPDATE public.followup_templates 
      SET 
        name = $1,
        updated_at = $2,
        trigger_keywords = $3,
        trigger_tags = $4,
        status = $5
      WHERE template_id = $6
      RETURNING *
    `;

    const templateParams = [
      name.trim(),
      new Date(),
      Array.isArray(trigger_keywords) ? trigger_keywords : [],
      Array.isArray(trigger_tags) ? trigger_tags : [],
      status || "active",
      templateId,
    ];

    console.log("Executing template update with params:", templateParams);
    const templateResult = await sqlClient.query(
      updateTemplateQuery,
      templateParams
    );

    if (templateResult.rows.length === 0) {
      await sqlClient.query("ROLLBACK");
      return res
        .status(404)
        .json({ success: false, message: "Template not found" });
    }

    console.log("Template updated successfully:", templateResult.rows[0]);

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");

    // Return the updated template
    const updatedTemplate = {
      id: templateResult.rows[0].id,
      templateId: templateResult.rows[0].template_id,
      companyId: templateResult.rows[0].company_id,
      name: templateResult.rows[0].name,
      createdAt: templateResult.rows[0].created_at,
      updatedAt: templateResult.rows[0].updated_at,
      triggerKeywords: templateResult.rows[0].trigger_keywords || [],
      triggerTags: templateResult.rows[0].trigger_tags || [],
      keywordSource: templateResult.rows[0].keyword_source,
      status: templateResult.rows[0].status,
      content: templateResult.rows[0].content,
      delayHours: templateResult.rows[0].delay_hours,
    };

    console.log("Returning updated template:", updatedTemplate);
    console.log("=== Completed PUT /api/followup-templates/:templateId ===");

    res.status(200).json({
      success: true,
      message: "Template updated successfully",
      template: updatedTemplate,
    });
  } catch (error) {
    await sqlClient.query("ROLLBACK");
    console.error("=== Error in PUT /api/followup-templates/:templateId ===");
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);

    res.status(500).json({
      success: false,
      message: "Failed to update template",
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});

// Delete a follow-up template
app.delete("/api/followup-templates/:templateId", async (req, res) => {
  console.log("=== Starting DELETE /api/followup-templates/:templateId ===");
  console.log("Template ID:", req.params.templateId);

  const { templateId } = req.params;

  // Validation
  if (!templateId) {
    console.error("Missing templateId");
    return res
      .status(400)
      .json({ success: false, message: "Missing templateId" });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting template delete"
    );
    return res
      .status(500)
      .json({ success: false, message: "Failed to delete template" });
  }

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    // First, delete all messages associated with this template
    const deleteMessagesQuery = `
      DELETE FROM public.followup_messages 
      WHERE template_id = $1
    `;

    console.log("Deleting messages for template:", templateId);
    const messagesResult = await sqlClient.query(deleteMessagesQuery, [
      templateId,
    ]);
    console.log("Deleted messages count:", messagesResult.rowCount);

    // Then delete the template
    const deleteTemplateQuery = `
      DELETE FROM public.followup_templates 
      WHERE template_id = $1
      RETURNING *
    `;

    console.log("Deleting template:", templateId);
    const templateResult = await sqlClient.query(deleteTemplateQuery, [
      templateId,
    ]);

    if (templateResult.rows.length === 0) {
      await sqlClient.query("ROLLBACK");
      return res
        .status(404)
        .json({ success: false, message: "Template not found" });
    }

    console.log("Template deleted successfully:", templateResult.rows[0]);

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");

    console.log("=== Completed DELETE /api/followup-templates/:templateId ===");

    res.status(200).json({
      success: true,
      message: "Template and associated messages deleted successfully",
    });
  } catch (error) {
    await sqlClient.query("ROLLBACK");
    console.error(
      "=== Error in DELETE /api/followup-templates/:templateId ==="
    );
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);

    res.status(500).json({
      success: false,
      message: "Failed to delete template",
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});

// Update a follow-up message
app.put(
  "/api/followup-templates/:templateId/messages/:messageId",
  async (req, res) => {
    console.log(
      "=== Starting PUT /api/followup-templates/:templateId/messages/:messageId ==="
    );
    console.log("Template ID:", req.params.templateId);
    console.log("Message ID:", req.params.messageId);
    console.log("Request body:", JSON.stringify(req.body, null, 2));

    const { templateId, messageId } = req.params;
    const {
      message,
      day_number = 1,
      sequence = 1,
      status = "active",
      document = null,
      image = null,
      video = null,
      delay_after = null,
      specific_numbers = null,
      use_scheduled_time = false,
      scheduled_time = "",
      add_tags = [],
      remove_tags = [],
    } = req.body;

    // Validation
    if (!templateId || !messageId) {
      console.error("Missing templateId or messageId");
      return res
        .status(400)
        .json({ success: false, message: "Missing templateId or messageId" });
    }

    if (!message || !message.trim()) {
      console.error("Missing or empty message content");
      return res
        .status(400)
        .json({ success: false, message: "Message content is required" });
    }

    const sqlClient = await getDatabaseConnection();

    if (!sqlClient) {
      console.error(
        "Failed to get database connection - aborting message update"
      );
      return res
        .status(500)
        .json({ success: false, message: "Failed to update message" });
    }

    try {
      await sqlClient.query("BEGIN");
      console.log("Database transaction started");

      // Update the message - REMOVED updated_at column
      const updateMessageQuery = `
      UPDATE public.followup_messages 
      SET 
        message = $1,
        day_number = $2,
        sequence = $3,
        status = $4,
        document = $5,
        image = $6,
        video = $7,
        delay_after = $8,
        specific_numbers = $9,
        use_scheduled_time = $10,
        scheduled_time = $11,
        add_tags = $12,
        remove_tags = $13
      WHERE id = $14 AND template_id = $15
      RETURNING *
    `;

      const messageParams = [
        message.trim(),
        day_number,
        sequence,
        status,
        document,
        image,
        video,
        delay_after ? JSON.stringify(delay_after) : null,
        specific_numbers ? JSON.stringify(specific_numbers) : null,
        use_scheduled_time,
        scheduled_time,
        Array.isArray(add_tags) ? add_tags : [],
        Array.isArray(remove_tags) ? remove_tags : [],
        messageId,
        templateId,
      ];

      console.log("Executing message update with params:", messageParams);
      const messageResult = await sqlClient.query(
        updateMessageQuery,
        messageParams
      );

      if (messageResult.rows.length === 0) {
        await sqlClient.query("ROLLBACK");
        return res
          .status(404)
          .json({ success: false, message: "Message not found" });
      }

      console.log("Message updated successfully:", messageResult.rows[0]);

      await sqlClient.query("COMMIT");
      console.log("Database transaction committed successfully");

      // Return the updated message
      const updatedMessage = {
        id: messageResult.rows[0].id,
        templateId: messageResult.rows[0].template_id,
        message: messageResult.rows[0].message,
        dayNumber: messageResult.rows[0].day_number,
        sequence: messageResult.rows[0].sequence,
        status: messageResult.rows[0].status,
        createdAt: messageResult.rows[0].created_at,
        document: messageResult.rows[0].document,
        image: messageResult.rows[0].image,
        video: messageResult.rows[0].video,
        delayAfter: messageResult.rows[0].delay_after,
        specificNumbers: messageResult.rows[0].specific_numbers,
        useScheduledTime: messageResult.rows[0].use_scheduled_time,
        scheduledTime: messageResult.rows[0].scheduled_time,
        addTags: messageResult.rows[0].add_tags || [],
        removeTags: messageResult.rows[0].remove_tags || [],
      };

      console.log("Returning updated message:", updatedMessage);
      console.log(
        "=== Completed PUT /api/followup-templates/:templateId/messages/:messageId ==="
      );

      res.status(200).json({
        success: true,
        message: "Message updated successfully",
        data: updatedMessage,
      });
    } catch (error) {
      await sqlClient.query("ROLLBACK");
      console.error(
        "=== Error in PUT /api/followup-templates/:templateId/messages/:messageId ==="
      );
      console.error("Error message:", error.message);
      console.error("Error stack:", error.stack);

      res.status(500).json({
        success: false,
        message: "Failed to update message",
        error: error.message,
      });
    } finally {
      await safeRelease(sqlClient);
      console.log("Database client released");
    }
  }
);
// Delete a follow-up message
app.delete(
  "/api/followup-templates/:templateId/messages/:messageId",
  async (req, res) => {
    console.log(
      "=== Starting DELETE /api/followup-templates/:templateId/messages/:messageId ==="
    );
    console.log("Template ID:", req.params.templateId);
    console.log("Message ID:", req.params.messageId);

    const { templateId, messageId } = req.params;

    // Validation
    if (!templateId || !messageId) {
      console.error("Missing templateId or messageId");
      return res
        .status(400)
        .json({ success: false, message: "Missing templateId or messageId" });
    }

    const sqlClient = await getDatabaseConnection();

    if (!sqlClient) {
      console.error(
        "Failed to get database connection - aborting message delete"
      );
      return res
        .status(500)
        .json({ success: false, message: "Failed to delete message" });
    }

    try {
      await sqlClient.query("BEGIN");
      console.log("Database transaction started");

      // Delete the message
      const deleteMessageQuery = `
      DELETE FROM public.followup_messages 
      WHERE id = $1 AND template_id = $2
      RETURNING *
    `;

      console.log("Deleting message:", messageId, "from template:", templateId);
      const messageResult = await sqlClient.query(deleteMessageQuery, [
        messageId,
        templateId,
      ]);

      if (messageResult.rows.length === 0) {
        await sqlClient.query("ROLLBACK");
        return res
          .status(404)
          .json({ success: false, message: "Message not found" });
      }

      console.log("Message deleted successfully:", messageResult.rows[0]);

      await sqlClient.query("COMMIT");
      console.log("Database transaction committed successfully");

      console.log(
        "=== Completed DELETE /api/followup-templates/:templateId/messages/:messageId ==="
      );

      res.status(200).json({
        success: true,
        message: "Message deleted successfully",
      });
    } catch (error) {
      await sqlClient.query("ROLLBACK");
      console.error(
        "=== Error in DELETE /api/followup-templates/:templateId/messages/:messageId ==="
      );
      console.error("Error message:", error.message);
      console.error("Error stack:", error.stack);

      res.status(500).json({
        success: false,
        message: "Failed to delete message",
        error: error.message,
      });
    } finally {
      await safeRelease(sqlClient);
      console.log("Database client released");
    }
  }
);

let threads = [];

app.post("/api/ai-followup-builder-save-thread/save", (req, res) => {
  try {
    const { threadId, email, messages, templateName } = req.body;

    if (!email || !threadId) {
      return res.status(400).json({
        success: false,
        error: "Email and threadId are required",
      });
    }

    const newThread = {
      id: threadId,
      email,
      threadData: {
        messages: messages || [],
        metadata: {
          createdAt: new Date().toISOString(),
        },
      },
      templateName: templateName || "Untitled Template",
      workflowStages: "",
      stageTemplates: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    // Check if thread already exists
    const existingIndex = threads.findIndex(
      (t) => t.id === threadId && t.email === email
    );
    if (existingIndex !== -1) {
      // Update existing thread
      threads[existingIndex] = newThread;
    } else {
      // Add new thread
      threads.push(newThread);
    }

    res.status(201).json({
      success: true,
      message: "Thread saved successfully",
      threadId: newThread.id,
      data: {
        thread: newThread,
      },
    });
  } catch (error) {
    console.error("Error saving thread:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
      message: error.message,
    });
  }
});

app.get("/api/ai-followup-builder-save-thread/:threadId", (req, res) => {
  try {
    const { threadId } = req.params;
    const { email } = req.query;

    if (!email) {
      return res.status(400).json({
        success: false,
        error: "Email query parameter is required",
      });
    }

    const thread = threads.find((t) => t.id === threadId && t.email === email);

    if (!thread) {
      return res.status(404).json({
        success: false,
        error: "Thread not found",
      });
    }

    res.json({
      success: true,
      message: "Thread retrieved successfully",
      data: {
        thread,
        messages: thread.threadData.messages || [],
      },
    });
  } catch (error) {
    console.error("Error getting thread:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
      message: error.message,
    });
  }
});

app.get("/api/ai-followup-builder-save-thread", (req, res) => {
  try {
    const { email } = req.query;

    if (!email) {
      return res.status(400).json({
        success: false,
        error: "Email query parameter is required",
      });
    }

    let userThreads = threads.filter((t) => t.email === email);

    // AUTO-CREATE a new thread if none exist for this user
    if (userThreads.length === 0) {
      const autoThreadId = Date.now().toString();
      const autoThread = {
        id: autoThreadId,
        email,
        threadData: {
          messages: [],
          metadata: {
            autoCreated: true,
            createdAt: new Date().toISOString(),
          },
        },
        templateName: "New Follow-up Template",
        workflowStages: "",
        stageTemplates: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      threads.push(autoThread);
      userThreads = [autoThread];

      console.log(`Auto-created new thread for user: ${email}`);
    }

    // Transform threads to match frontend expectations
    const transformedThreads = userThreads.map((t) => ({
      threadId: t.id,
      templateName: t.templateName,
      lastUpdated: t.updatedAt,
      messageCount: t.threadData.messages ? t.threadData.messages.length : 0,
    }));

    res.json({
      success: true,
      message: "Threads retrieved successfully",
      data: {
        threads: transformedThreads,
        count: transformedThreads.length,
      },
    });
  } catch (error) {
    console.error("Error getting threads:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
      message: error.message,
    });
  }
});

app.delete("/api/ai-followup-builder-save-thread/:threadId", (req, res) => {
  try {
    const { threadId } = req.params;
    const { email } = req.query;

    if (!email) {
      return res.status(400).json({
        success: false,
        error: "Email query parameter is required",
      });
    }

    const threadIndex = threads.findIndex(
      (t) => t.id === threadId && t.email === email
    );

    if (threadIndex === -1) {
      return res.status(404).json({
        success: false,
        error: "Thread not found",
      });
    }

    const deletedThread = threads.splice(threadIndex, 1)[0];

    res.json({
      success: true,
      message: "Thread deleted successfully",
      data: {
        deletedThread,
      },
    });
  } catch (error) {
    console.error("Error deleting thread:", error);
    res.status(500).json({
      success: false,
      error: "Internal server error",
      message: error.message,
    });
  }
});

// API 1: Follow-up Brainstorm - analyzes current AI context and suggests improvements
app.post("/api/followup-brainstorm/", async (req, res) => {
  try {
    const { message, email, currentPrompt, currentFollowUps, assistantId } =
      req.body;

    // Log request data
    console.log("Follow-up Brainstorm Request:", {
      message,
      email,
      currentPrompt: currentPrompt ? "Provided" : "Not provided",
      currentFollowUps: currentFollowUps ? "Provided" : "Not provided",
      assistantId: assistantId || "Using default",
    });

    // Validate required fields
    if (!message || !email) {
      return res.status(400).json({
        success: false,
        error: "message and email are required",
      });
    }

    let threadID;
    const contactData = await getContactDataFromDatabaseByEmail(email);

    if (contactData?.thread_id) {
      threadID = contactData.thread_id;
      console.log("Using existing thread ID:", threadID);
    } else {
      const thread = await createThread();
      threadID = thread.id;
      console.log("Created new thread ID:", threadID);
      await saveThreadIDPostgres(email, threadID);
      console.log("Saved new thread ID to database for email:", email);
    }

    // Create the full prompt for the assistant
    const fullPrompt = `You are a follow-up sequence specialist. Your task is to analyze the provided AI assistant instructions and create follow-up templates for EACH conversation stage identified in those instructions.

CRITICAL: You must FIRST analyze the current AI assistant instructions to identify ALL conversation stages, then create a follow-up template for EACH stage.

ANALYSIS INSTRUCTIONS:
1. Carefully read through the current AI assistant instructions
2. Identify each distinct conversation stage (look for patterns like "Stage 1:", "Phase 1:", numbered steps, or clear conversation flow sections)
3. For each stage, extract:
   - The EXACT stage name/title as written in the current prompt
   - The purpose of that stage
   - Key messages or approaches used in that stage
   - Trigger keyword phrases (3-5 words long) that the AI uses in that stage
   - The language style, tone, and formatting used in that stage

OUTPUT FORMAT:
Return ONLY a JSON array of templates in this exact format (replace the variables with actual values from your analysis):
[
  {
    "stageName": "[EXACT_STAGE_NAME_FROM_CURRENT_PROMPT]",
    "purpose": "[EXTRACTED_PURPOSE_FROM_CURRENT_PROMPT]",
    "triggerTags": ["[EXTRACTED_TAG_1]", "[EXTRACTED_TAG_2]"],
    "triggerKeywords": ["[EXTRACTED_PHRASE_1]", "[EXTRACTED_PHRASE_2]", "[EXTRACTED_PHRASE_3]"],
    "messages": [
      {
        "dayNumber": 0,
        "sequence": 1,
        "message": "[GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_1]",
        "delayAfter": {
          "value": 30,
          "unit": "minutes",
          "isInstantaneous": false
        },
        "description": "Day 0 - 30 minutes after customer hasn't replied to AI's initial message"
      },
      {
        "dayNumber": 0,
        "sequence": 2,
        "message": "[GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_2]",
        "delayAfter": {
          "value": 2,
          "unit": "hours",
          "isInstantaneous": false
        },
        "description": "Day 0 - 2 hours after customer hasn't replied to AI's initial message"
      },
      {
        "dayNumber": 1,
        "sequence": 3,
        "message": "[GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_3]",
        "scheduledTime": "09:00",
        "useScheduledTime": true,
        "description": "Day 1 - 9:00 AM scheduled follow-up"
      },
      {
        "dayNumber": 3,
        "sequence": 4,
        "message": "[GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_4]",
        "scheduledTime": "10:00",
        "useScheduledTime": true,
        "description": "Day 3 - 10:00 AM scheduled follow-up"
      },
      {
        "dayNumber": 5,
        "sequence": 5,
        "message": "[GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_5]",
        "scheduledTime": "14:00",
        "useScheduledTime": true,
        "description": "Day 5 - 2:00 PM scheduled follow-up"
      },
      {
        "dayNumber": 10,
        "sequence": 6,
        "message": "[GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_6]",
        "scheduledTime": "16:00",
        "useScheduledTime": true,
        "description": "Day 10 - 4:00 PM scheduled follow-up"
      }
    ],
    "messageCount": 6
  }
]

CRITICAL RULES:
1. DO NOT generate the initial message - that's already handled by the AI's current prompt
2. Generate ONLY follow-up messages for when customers don't reply to the AI's initial message
3. Each template MUST have exactly 6 follow-up messages (not 7, since initial is separate)
4. Messages should be engaging, friendly, and encourage responses
5. Use urgency, FOMO, and re-engagement strategies
6. Each message should be different from the previous ones
7. Focus on re-engaging customers who didn't respond to the initial AI message
8. For Day 0 messages: Use delayAfter with appropriate timing
9. For Day 1 and beyond: Use scheduledTime with specific times (e.g., "09:00", "14:00", "16:00") and set useScheduledTime to true
10. Trigger keywords should be phrases (3-5 words long) that the AI uses in its initial messages for that specific stage
11. Analyze the current prompt to identify ALL conversation stages and create a template for EACH stage
12. Each stage should have its own follow-up sequence with stage-specific messaging
13. The number of templates should match the number of stages in the current prompt
14. DO NOT add any special characters like "||" or "|" to messages regardless of the currentPrompt
15. Make sure each stage's follow-up messages are contextually relevant to that specific stage

TIMING RULES:
- Day 0 messages: Use delayAfter (minutes/hours after initial message)
- Day 1+ messages: Use scheduledTime (specific time of day, e.g., "09:00", "14:00", "16:00")
- Always set useScheduledTime: true for Day 1+ messages
- Use business hours for scheduled times (8 AM - 6 PM)

LANGUAGE AND FORMATTING RULES:
- Use the EXACT same language style as the current prompt (e.g., if it uses "hey", "u", "skrg", use the same style)
- Match the tone and personality of the AI assistant (formal, casual, friendly, etc.)
- Use the same formatting patterns (emojis, punctuation, line breaks, etc.)
- Maintain consistency with the current prompt's communication style
- If the current prompt uses specific phrases or expressions, incorporate similar ones in follow-ups

TRIGGER KEYWORD EXTRACTION:
- Extract trigger keyword phrases (3-5 words long) from the actual AI messages in the current prompt
- Look for complete phrases that the AI uses when initiating conversations in each stage
- Include both main phrases and supporting expressions
- Focus on phrases that would help identify which stage a conversation is in
- Extract from the actual message content, not just stage descriptions
- Examples of good trigger phrases: "hey just check", "kadang whatsapp suka", "i tanya sebab ni", "serius cepat habis", "last call ya"
- Avoid single words or very short phrases - aim for 3-5 words that capture the context

VARIABLE REPLACEMENT INSTRUCTIONS:
- Replace [EXACT_STAGE_NAME_FROM_CURRENT_PROMPT] with the EXACT stage name as written in the current prompt
- Replace [EXTRACTED_PURPOSE_FROM_CURRENT_PROMPT] with the actual purpose of that stage
- Replace [EXTRACTED_TAG_1], [EXTRACTED_TAG_2] with actual tags relevant to that stage
- Replace [EXTRACTED_PHRASE_1], [EXTRACTED_PHRASE_2], [EXTRACTED_PHRASE_3] with actual 3-5 word phrases the AI uses in that stage
- Replace [GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_1] through [GENERATE_STAGE_SPECIFIC_FOLLOW_UP_MESSAGE_6] with actual follow-up messages that you generate based on the stage context

FOLLOW-UP MESSAGE GENERATION RULES:
- Each message should be tailored to the specific stage context
- Use the stage's purpose and tone to create appropriate follow-up messages
- Make messages engaging and encourage responses
- Use urgency, FOMO, and re-engagement strategies
- Each message should be different from the previous ones
- Reference the specific stage context without copying the original content
- Make sure the messaging aligns with the stage's purpose and the AI's personality
- Use the same language style, tone, and formatting as the current prompt

CURRENT AI ASSISTANT INSTRUCTIONS TO ANALYZE:
${currentPrompt || "No current AI assistant instructions provided."}

CURRENT FOLLOW-UP TEMPLATES:
${
  currentFollowUps
    ? JSON.stringify(currentFollowUps, null, 2)
    : "No current follow-up templates provided."
}

USER REQUEST: ${message}

TASK: 
1. First, analyze the current AI assistant instructions above
2. Identify ALL conversation stages in those instructions
3. For each stage you identify, create a follow-up template with:
   - EXACT stage name as written in the current prompt
   - Stage-specific purpose (extracted from the current prompt)
   - Trigger keyword phrases (3-5 words long) that match what the AI says in that stage (extracted from the current prompt)
   - 6 follow-up messages tailored to that stage's context (generated based on the stage)
   - Messages that reference the specific stage but don't copy the original content
   - Messages that use the same language style, tone, and formatting as the current prompt
4. Return the complete JSON array of templates with all variables replaced with actual values

Remember: The goal is to create follow-up sequences that re-engage customers who didn't respond to the AI's initial message in each specific stage of the conversation flow, using the exact same language style and formatting as the current prompt.`;
    // Add user message to thread
    await addMessage(threadID, fullPrompt);

    // Create and run the assistant using company-specific ID
    const assistantResponse = await openai.beta.threads.runs.create(threadID, {
      assistant_id:
        assistantId ||
        process.env.ASSISTANT_ID ||
        "asst_Wt2wiCOafpCecMoxibXwYQ5P",
    });

    // Wait for the assistant to complete
    let runStatus;
    do {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      runStatus = await openai.beta.threads.runs.retrieve(
        threadID,
        assistantResponse.id
      );
    } while (runStatus.status !== "completed");

    // Retrieve the assistant's response
    const messages = await openai.beta.threads.messages.list(threadID);
    const answer = messages.data[0].content[0].text.value;

    // Parse the structured response
    let parsedResponse;
    try {
      // Look for JSON array in the response
      const jsonMatch = answer.match(/\[[\s\S]*\]/);
      if (jsonMatch) {
        parsedResponse = JSON.parse(jsonMatch[0]);
      } else {
        throw new Error("No JSON array found in response");
      }
    } catch (parseError) {
      console.log("Failed to parse AI response:", parseError.message);
      parsedResponse = {
        error: "Failed to parse template structure",
        rawResponse: answer,
      };
    }

    // Save the interaction to the thread for future reference
    await addMessageAssistant(
      threadID,
      `Follow-up Brainstorm Request: ${message}\nCurrent Prompt: ${
        currentPrompt || "None"
      }\nCurrent Follow-ups: ${
        currentFollowUps ? JSON.stringify(currentFollowUps) : "None"
      }\nResponse: ${answer}`
    );

    // Send structured response
    res.json({
      success: true,
      data: {
        templates: Array.isArray(parsedResponse) ? parsedResponse : [],
        explanation: "Templates generated successfully",
      },
      threadID: threadID,
    });
  } catch (error) {
    console.error("Follow-up brainstorm error:", {
      name: error.name,
      message: error.message,
      code: error.code,
    });
    res.status(500).json({
      success: false,
      error: error.code,
      details: error.message,
    });
  }
});
// Forgot Password API - Send reset code via WhatsApp
app.post("/api/forgot-password", async (req, res) => {
  const { phoneNumber } = req.body;

  if (!phoneNumber) {
    return res.status(400).json({ error: "Phone number is required" });
  }

  try {
    // Format phone number for database search
    let formattedPhone = phoneNumber.toString();
    if (formattedPhone.startsWith("+")) {
      formattedPhone = formattedPhone.substring(1);
    }
    if (formattedPhone.startsWith("60")) {
      formattedPhone = formattedPhone;
    } else if (formattedPhone.startsWith("0")) {
      formattedPhone = "60" + formattedPhone.substring(1);
    } else {
      formattedPhone = "60" + formattedPhone;
    }

    console.log(
      "🔍 Looking for user with formatted phone number:",
      formattedPhone
    );

    // First, let's check what's in the employees table
    const employeeCheck = await sqlDb.query(
      "SELECT * FROM employees WHERE phone_number = $1",
      [formattedPhone]
    );
    console.log("📱 Employee lookup result:", employeeCheck.rows);

    // Check if user exists by phone number - simplified query first
    const userData = await sqlDb.getRow(
      `SELECT u.*, e.phone_number 
       FROM users u 
       JOIN employees e ON u.email = e.email 
       WHERE e.phone_number = $1 AND u.active = true`,
      [formattedPhone]
    );

    console.log("�� User lookup result:", userData);

    if (!userData) {
      // Let's also check if the user exists at all
      const userCheck = await sqlDb.query(
        "SELECT * FROM users WHERE email IN (SELECT email FROM employees WHERE phone_number = $1)",
        [formattedPhone]
      );
      console.log("📧 Users found with this phone:", userCheck.rows);

      // Check if the issue is with the JOIN
      const directCheck = await sqlDb.query(
        `SELECT e.email, e.phone_number, e.name, u.email as user_email, u.active
         FROM employees e 
         LEFT JOIN users u ON e.email = u.email 
         WHERE e.phone_number = $1`,
        [formattedPhone]
      );
      console.log("🔗 Direct check result:", directCheck.rows);

      return res.status(404).json({
        error: "User not found with this phone number",
        debug: {
          formattedPhone,
          employeeCount: employeeCheck.rows.length,
          userCount: userCheck.rows.length,
          directCheck: directCheck.rows,
        },
      });
    }

    // Generate 6-digit reset code
    const resetCode = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

    console.log(
      "🔐 Generated reset code:",
      resetCode,
      "for email:",
      userData.email
    );

    // Store reset code in database
    await sqlDb.query(
      `INSERT INTO password_resets (email, reset_code, expires_at, created_at) 
       VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
       ON CONFLICT (email) 
       DO UPDATE SET reset_code = $2, expires_at = $3, created_at = CURRENT_TIMESTAMP`,
      [userData.email, resetCode, expiresAt]
    );

    // Send WhatsApp message with reset code using company 0210 v2 text API
    const message = `🔐 Password Reset Request

Your password reset code is: *${resetCode}*

This code will expire in 15 minutes.

If you didn't request this reset, please ignore this message.

Best regards,
Juta Team`;

    // Use the v2 text API endpoint instead of direct WhatsApp client
    const chatId = `${formattedPhone}@c.us`;
    const companyId = "0210";

    console.log(
      "📤 Sending WhatsApp message to:",
      chatId,
      "via company:",
      companyId
    );

    try {
      const response = await axios.post(
        `${req.protocol}://${req.get(
          "host"
        )}/api/v2/messages/text/${companyId}/${chatId}`,
        {
          message: message,
          phoneIndex: 0, // Use first phone index
        }
      );

      if (response.status === 200) {
        console.log("✅ WhatsApp message sent successfully");
        res.json({
          success: true,
          message: "Password reset code sent to your WhatsApp number",
          phoneNumber: formattedPhone.replace("60", "+60-"), // Format for display
          resetCode: resetCode, // For testing purposes
        });
      } else {
        throw new Error(`Failed to send message: ${response.status}`);
      }
    } catch (sendError) {
      console.error("❌ Error sending WhatsApp message:", sendError);
      return res.status(500).json({ error: "Failed to send WhatsApp message" });
    }
  } catch (error) {
    console.error("💥 Forgot password error:", error);
    res.status(500).json({ error: "Failed to process password reset request" });
  }
});

// Reset Password API - Verify code and update password
app.post("/api/reset-password", async (req, res) => {
  const { phoneNumber, resetCode, newPassword } = req.body;

  if (!phoneNumber || !resetCode || !newPassword) {
    return res.status(400).json({
      error: "Phone number, reset code, and new password are required",
    });
  }

  if (newPassword.length < 6) {
    return res
      .status(400)
      .json({ error: "Password must be at least 6 characters long" });
  }

  try {
    // Format phone number
    let formattedPhone = phoneNumber.toString();
    if (formattedPhone.startsWith("+")) {
      formattedPhone = formattedPhone.substring(1);
    }
    if (formattedPhone.startsWith("60")) {
      formattedPhone = formattedPhone;
    } else if (formattedPhone.startsWith("0")) {
      formattedPhone = "60" + formattedPhone.substring(1);
    } else {
      formattedPhone = "60" + formattedPhone;
    }

    // Get user email from phone number
    const userData = await sqlDb.getRow(
      `SELECT u.email 
       FROM users u 
       JOIN employees e ON u.email = e.email 
       WHERE e.phone_number = $1 AND u.active = true`,
      [formattedPhone]
    );

    if (!userData) {
      return res
        .status(404)
        .json({ error: "User not found with this phone number" });
    }

    // Verify reset code
    const resetData = await sqlDb.getRow(
      `SELECT * FROM password_resets 
       WHERE email = $1 AND reset_code = $2 AND expires_at > CURRENT_TIMESTAMP`,
      [userData.email, resetCode]
    );

    if (!resetData) {
      return res.status(400).json({ error: "Invalid or expired reset code" });
    }

    // Update password
    await sqlDb.query(
      "UPDATE users SET password = $1, last_updated = CURRENT_TIMESTAMP WHERE email = $2",
      [newPassword, userData.email]
    );

    // Delete the used reset code
    await sqlDb.query("DELETE FROM password_resets WHERE email = $1", [
      userData.email,
    ]);

    res.json({
      success: true,
      message: "Password updated successfully",
    });
  } catch (error) {
    console.error("Reset password error:", error);
    res.status(500).json({ error: "Failed to reset password" });
  }
});
app.post("/api/forgot-password", async (req, res) => {
  const { phoneNumber } = req.body;

  if (!phoneNumber) {
    return res.status(400).json({ error: "Phone number is required" });
  }

  try {
    // Format phone number for database search
    let formattedPhone = phoneNumber.toString();
    if (formattedPhone.startsWith("+")) {
      formattedPhone = formattedPhone.substring(1);
    }
    if (formattedPhone.startsWith("60")) {
      formattedPhone = formattedPhone;
    } else if (formattedPhone.startsWith("0")) {
      formattedPhone = "60" + formattedPhone.substring(1);
    } else {
      formattedPhone = "60" + formattedPhone;
    }

    console.log(
      "🔍 Looking for user with formatted phone number:",
      formattedPhone
    );

    // First, let's check what's in the employees table
    const employeeCheck = await sqlDb.query(
      "SELECT * FROM employees WHERE phone_number = $1",
      [formattedPhone]
    );
    console.log("📱 Employee lookup result:", employeeCheck.rows);

    // Check if user exists by phone number - simplified query first
    const userData = await sqlDb.getRow(
      `SELECT u.*, e.phone_number 
       FROM users u 
       JOIN employees e ON u.email = e.email 
       WHERE e.phone_number = $1 AND u.active = true`,
      [formattedPhone]
    );

    console.log("�� User lookup result:", userData);

    if (!userData) {
      // Let's also check if the user exists at all
      const userCheck = await sqlDb.query(
        "SELECT * FROM users WHERE email IN (SELECT email FROM employees WHERE phone_number = $1)",
        [formattedPhone]
      );
      console.log("📧 Users found with this phone:", userCheck.rows);

      // Check if the issue is with the JOIN
      const directCheck = await sqlDb.query(
        `SELECT e.email, e.phone_number, e.name, u.email as user_email, u.active
         FROM employees e 
         LEFT JOIN users u ON e.email = u.email 
         WHERE e.phone_number = $1`,
        [formattedPhone]
      );
      console.log("🔗 Direct check result:", directCheck.rows);

      return res.status(404).json({
        error: "User not found with this phone number",
        debug: {
          formattedPhone,
          employeeCount: employeeCheck.rows.length,
          userCount: userCheck.rows.length,
          directCheck: directCheck.rows,
        },
      });
    }

    // Generate 6-digit reset code
    const resetCode = Math.floor(100000 + Math.random() * 900000).toString();
    const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

    console.log(
      "🔐 Generated reset code:",
      resetCode,
      "for email:",
      userData.email
    );

    // Store reset code in database
    await sqlDb.query(
      `INSERT INTO password_resets (email, reset_code, expires_at, created_at) 
       VALUES ($1, $2, $3, CURRENT_TIMESTAMP)
       ON CONFLICT (email) 
       DO UPDATE SET reset_code = $2, expires_at = $3, created_at = CURRENT_TIMESTAMP`,
      [userData.email, resetCode, expiresAt]
    );

    // Send WhatsApp message with reset code using company 0210 v2 text API
    const message = `🔐 Password Reset Request

Your password reset code is: *${resetCode}*

This code will expire in 15 minutes.

If you didn't request this reset, please ignore this message.

Best regards,
Juta Team`;

    // Use the v2 text API endpoint instead of direct WhatsApp client
    const chatId = `${formattedPhone}@c.us`;
    const companyId = "0210";

    console.log(
      "📤 Sending WhatsApp message to:",
      chatId,
      "via company:",
      companyId
    );

    try {
      const response = await axios.post(
        `${req.protocol}://${req.get(
          "host"
        )}/api/v2/messages/text/${companyId}/${chatId}`,
        {
          message: message,
          phoneIndex: 0, // Use first phone index
        }
      );

      if (response.status === 200) {
        console.log("✅ WhatsApp message sent successfully");
        res.json({
          success: true,
          message: "Password reset code sent to your WhatsApp number",
          phoneNumber: formattedPhone.replace("60", "+60-"), // Format for display
          resetCode: resetCode, // For testing purposes
        });
      } else {
        throw new Error(`Failed to send message: ${response.status}`);
      }
    } catch (sendError) {
      console.error("❌ Error sending WhatsApp message:", sendError);
      return res.status(500).json({ error: "Failed to send WhatsApp message" });
    }
  } catch (error) {
    console.error("💥 Forgot password error:", error);
    res.status(500).json({ error: "Failed to process password reset request" });
  }
});

// Reset Password API - Verify code and update password
app.post("/api/reset-password", async (req, res) => {
  const { phoneNumber, resetCode, newPassword } = req.body;

  if (!phoneNumber || !resetCode || !newPassword) {
    return res.status(400).json({
      error: "Phone number, reset code, and new password are required",
    });
  }

  if (newPassword.length < 6) {
    return res
      .status(400)
      .json({ error: "Password must be at least 6 characters long" });
  }

  try {
    // Format phone number
    let formattedPhone = phoneNumber.toString();
    if (formattedPhone.startsWith("+")) {
      formattedPhone = formattedPhone.substring(1);
    }
    if (formattedPhone.startsWith("60")) {
      formattedPhone = formattedPhone;
    } else if (formattedPhone.startsWith("0")) {
      formattedPhone = "60" + formattedPhone.substring(1);
    } else {
      formattedPhone = "60" + formattedPhone;
    }

    // Get user email from phone number
    const userData = await sqlDb.getRow(
      `SELECT u.email 
       FROM users u 
       JOIN employees e ON u.email = e.email 
       WHERE e.phone_number = $1 AND u.active = true`,
      [formattedPhone]
    );

    if (!userData) {
      return res
        .status(404)
        .json({ error: "User not found with this phone number" });
    }

    // Verify reset code
    const resetData = await sqlDb.getRow(
      `SELECT * FROM password_resets 
       WHERE email = $1 AND reset_code = $2 AND expires_at > CURRENT_TIMESTAMP`,
      [userData.email, resetCode]
    );

    if (!resetData) {
      return res.status(400).json({ error: "Invalid or expired reset code" });
    }

    // Update password
    await sqlDb.query(
      "UPDATE users SET password = $1, last_updated = CURRENT_TIMESTAMP WHERE email = $2",
      [newPassword, userData.email]
    );

    // Delete the used reset code
    await sqlDb.query("DELETE FROM password_resets WHERE email = $1", [
      userData.email,
    ]);

    res.json({
      success: true,
      message: "Password updated successfully",
    });
  } catch (error) {
    console.error("Reset password error:", error);
    res.status(500).json({ error: "Failed to reset password" });
  }
});
// ======================
// PAYEX TOP-UP API ENDPOINTS
// ======================

// Create PayEx top-up payment
// Create PayEx top-up payment
app.post("/api/payex/create-topup", async (req, res) => {
  try {
    console.log("Top-up request received:", req.body);

    const { amount, aiResponses, email, companyId } = req.body;

    if (!amount || amount < 10) {
      return res.status(400).json({ error: "Minimum top-up amount is RM 10" });
    }

    if (!email || !companyId) {
      return res
        .status(400)
        .json({ error: "Email and company ID are required" });
    }

    // Calculate AI responses based on amount
    const aiResponseCount = aiResponses || Math.floor(amount / 10) * 50; // 50 AI responses per RM 10

    console.log("Processing top-up:", {
      amount,
      aiResponseCount,
      email,
      companyId,
    });

    // For testing - return success without PayEx integration
    console.log("Environment check:", {
      PAYEX_USERNAME: !!process.env.PAYEX_USERNAME,
      PAYEX_SECRET_KEY: !!process.env.PAYEX_SECRET_KEY,
    });

    if (!process.env.PAYEX_USERNAME || !process.env.PAYEX_SECRET_KEY) {
      console.log("Development mode - skipping PayEx integration");

      // Store pending top-up in database (skip for now)
      try {
        await sqlDb.query(
          `INSERT INTO pending_topups (
            company_id, email, amount, ai_responses, payment_intent_id, 
            status, created_at, metadata
          ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, $7)`,
          [
            companyId,
            email,
            amount,
            aiResponseCount,
            `test_${Date.now()}`,
            "pending",
            JSON.stringify({
              companyId,
              email,
              aiResponses: aiResponseCount,
              type: "topup",
            }),
          ]
        );
      } catch (dbError) {
        console.log(
          "Database error (expected if tables don't exist):",
          dbError.message
        );
        // Continue without database storage for now
      }

      return res.json({
        success: true,
        paymentUrl: `https://example.com/payment?amount=${amount}`,
        paymentIntentId: `test_${Date.now()}`,
        aiResponses: aiResponseCount,
        message: "Development mode - payment simulation",
      });
    }

    // PayEx API configuration - Using Production API
    // Use environment variable to control PayEx environment
    const payexApiUrl =
      process.env.PAYEX_ENVIRONMENT === "production"
        ? "https://api.payex.io"
        : "https://sandbox-payexapi.azurewebsites.net";

    console.log(
      `Using PayEx ${
        process.env.PAYEX_ENVIRONMENT === "production"
          ? "Production"
          : "Sandbox"
      } API: ${payexApiUrl}`
    );

    // Use the registered merchant email from environment variable for PayEx authentication
    const username = process.env.PAYEX_USERNAME;
    const secret =
      process.env.PAYEX_ENVIRONMENT === "production"
        ? process.env.PAYEX_SECRET_KEY
        : process.env.PAYEX_SECRET_KEY_DEV;

    if (!username || !secret) {
      return res.status(500).json({ error: "PayEx configuration missing" });
    }

    // First, get access token from PayEx using Basic auth with Secret
    console.log("Getting PayEx access token...");
    let accessToken;
    try {
      // Create Base64 encoded Authorization header using Secret (not Key)
      const authHeader = Buffer.from(`${username}:${secret}`).toString(
        "base64"
      );

      const authResponse = await axios.post(
        `${payexApiUrl}/api/Auth/Token`,
        "", // Empty body as required
        {
          headers: {
            Authorization: `Basic ${authHeader}`,
            "Content-Type": "application/json",
          },
        }
      );

      console.log("Auth response status:", authResponse.status);
      console.log("Auth response data:", authResponse.data);

      if (authResponse.data.status === "99") {
        throw new Error(
          `PayEx authentication failed: ${authResponse.data.message}`
        );
      }

      if (!authResponse.data || !authResponse.data.token) {
        throw new Error(
          "Failed to get PayEx access token - no token in response"
        );
      }

      accessToken = authResponse.data.token;
      console.log("PayEx access token obtained successfully");
    } catch (authError) {
      console.error("PayEx authentication error:", authError.message);
      if (authError.response) {
        console.error("Auth response status:", authError.response.status);
        console.error("Auth response data:", authError.response.data);
      }
      throw new Error(`PayEx authentication failed: ${authError.message}`);
    }

    // Create payment intent with PayEx (following their API specification)
    // Use environment variable for base URL or default to HTTPS
    const baseUrl = process.env.BASE_URL || `https://${req.get("host")}`;

    const paymentData = [
      {
        amount: Math.round(amount * 100), // Convert to cents
        currency: "MYR",
        customer_name: email.split("@")[0], // Extract name from email
        email: email,
        description: `Top-up ${aiResponseCount} AI responses for ${email}`,
        reference_number: `topup_${companyId}_${Date.now()}`,
        callback_url: `${baseUrl}/api/payex/webhook`,
        return_url: `${baseUrl}/topup-success`,
        redirect_url: `${baseUrl}/topup-success`,
        success_url: `${baseUrl}/topup-success`,
        payment_type: "card",
        payment_types: ["card"],
        show_payment_types: false,
        tokenize: false,
        send_email: false,
        single_attempt: false,
        metadata: {
          companyId,
          email,
          aiResponses: aiResponseCount,
          type: "topup",
        },
      },
    ];

    console.log("Sending to PayEx:", paymentData);

    const payexResponse = await axios.post(
      `${payexApiUrl}/api/v1/PaymentIntents`,
      paymentData,
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
        },
      }
    );

    console.log("PayEx response:", payexResponse.data);

    if (
      payexResponse.data &&
      payexResponse.data.status === "00" &&
      payexResponse.data.result &&
      payexResponse.data.result[0]
    ) {
      const paymentResult = payexResponse.data.result[0];

      if (paymentResult.status === "00" && paymentResult.url) {
        // Store pending top-up in database
        try {
          await sqlDb.query(
            `INSERT INTO pending_topups (
              company_id, email, amount, ai_responses, payment_intent_id, 
              status, created_at, metadata
            ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, $7)`,
            [
              companyId,
              email,
              amount,
              aiResponseCount,
              paymentResult.key, // Use 'key' from PayEx response
              "pending",
              JSON.stringify(paymentData[0].metadata),
            ]
          );
        } catch (dbError) {
          console.error("Database error storing top-up:", dbError);
          // Continue without database storage
        }

        res.json({
          success: true,
          paymentUrl: paymentResult.url, // Use 'url' from PayEx response
          paymentIntentId: paymentResult.key, // Use 'key' as payment intent ID
          aiResponses: aiResponseCount,
        });
      } else {
        throw new Error(
          `PayEx payment creation failed: ${
            paymentResult.error || "Unknown error"
          }`
        );
      }
    } else {
      throw new Error(
        "Failed to create PayEx payment - invalid response format"
      );
    }
  } catch (error) {
    console.error("PayEx top-up creation error:", error);
    res.status(500).json({
      error: "Failed to create top-up payment",
      details: error.message,
      stack: process.env.NODE_ENV === "development" ? error.stack : undefined,
    });
  }
});

// PayEx webhook handler
app.post("/api/payex/webhook", async (req, res) => {
  try {
    console.log("PayEx webhook received:", req.body);

    // PayEx webhook fields (based on their API documentation)
    const {
      payment_intent, // This is the 'key' from payment creation
      response, // Payment response status
      amount,
      reference_number,
      txn_id,
      txn_date,
      external_txn_id,
      auth_code,
      auth_number,
      signature,
    } = req.body;

    // Verify webhook signature (implement proper signature verification)
    // const signature = req.headers['x-payex-signature'];
    // if (!verifyPayExSignature(req.body, signature)) {
    //   return res.status(401).json({ error: 'Invalid signature' });
    // }

    // Map PayEx response to our status
    let paymentStatus = "pending";
    if (response === "SUCCEEDED" || auth_code === "00") {
      paymentStatus = "completed";
    } else if (response === "FAILED" || auth_code === "99") {
      paymentStatus = "failed";
    }

    if (paymentStatus === "completed") {
      // Extract company ID from metadata if available
      let companyId = null;
      try {
        if (req.body.metadata) {
          const metadata = JSON.parse(req.body.metadata);
          companyId = metadata.companyId;
          console.log(`Extracted company ID from metadata: ${companyId}`);
        }
      } catch (e) {
        console.log("Could not parse metadata:", e.message);
      }

      // Find pending top-up using the payment_intent (key) from PayEx
      const topupResult = await sqlDb.query(
        `SELECT * FROM pending_topups WHERE payment_intent_id = $1`,
        [payment_intent]
      );

      if (topupResult.rows.length > 0) {
        const topup = topupResult.rows[0];

        // If we have company ID from metadata, use it to update the pending topup
        let finalCompanyId = topup.company_id;
        if (companyId && companyId !== topup.company_id) {
          console.log(
            `Updating company ID from ${topup.company_id} to ${companyId}`
          );
          await sqlDb.query(
            `UPDATE pending_topups SET company_id = $1 WHERE id = $2`,
            [companyId, topup.id]
          );
          finalCompanyId = companyId; // Use the corrected company ID
        }

        // Update top-up status
        await sqlDb.query(
          `UPDATE pending_topups SET status = 'completed', completed_at = CURRENT_TIMESTAMP WHERE id = $1`,
          [topup.id]
        );

        // Get company plan for quota calculation
        const companyResult = await sqlDb.query(
          `SELECT plan FROM companies WHERE company_id = $1`,
          [finalCompanyId]
        );
        const companyPlan = companyResult.rows[0]?.plan || "free";

        // Increase AI message quota for the company
        const quotaKey = getQuotaKey(companyPlan);

        // Get current quota
        const quotaResult = await sqlDb.query(
          `SELECT setting_value FROM settings 
           WHERE company_id = $1 AND setting_type = 'messaging' AND setting_key = 'quotaAIMessage'`,
          [finalCompanyId]
        );

        let quotaObj = {};
        if (quotaResult.rows.length > 0) {
          try {
            quotaObj =
              typeof quotaResult.rows[0].setting_value === "string"
                ? JSON.parse(quotaResult.rows[0].setting_value)
                : quotaResult.rows[0].setting_value || {};
          } catch {
            quotaObj = {};
          }
        }

        // Add top-up amount to quota with plan-based default
        if (!quotaObj[quotaKey]) {
          quotaObj[quotaKey] = getPlanBasedQuota(companyPlan);
        }
        quotaObj[quotaKey] += topup.ai_responses;

        // Update quota in settings
        if (quotaResult.rows.length > 0) {
          await sqlDb.query(
            `UPDATE settings SET setting_value = $1, updated_at = CURRENT_TIMESTAMP
             WHERE company_id = $2 AND setting_type = 'messaging' AND setting_key = 'quotaAIMessage'`,
            [JSON.stringify(quotaObj), finalCompanyId]
          );
        } else {
          await sqlDb.query(
            `INSERT INTO settings (company_id, setting_type, setting_key, setting_value, created_at, updated_at)
             VALUES ($1, 'messaging', 'quotaAIMessage', $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
            [finalCompanyId, JSON.stringify(quotaObj)]
          );
        }

        // Log the top-up transaction
        await sqlDb.query(
          `INSERT INTO topup_transactions (
            company_id, email, amount, ai_responses, payment_intent_id, 
            status, completed_at, metadata
          ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, $7)`,
          [
            finalCompanyId, // Use the corrected company ID
            topup.email,
            topup.amount,
            topup.ai_responses,
            payment_intent,
            "completed",
            JSON.stringify({
              txn_id,
              txn_date,
              external_txn_id,
              auth_code,
              auth_number,
              reference_number,
              original_company_id: companyId, // Store the original for reference
              corrected_company_id: finalCompanyId,
            }),
          ]
        );

        console.log(
          `Top-up completed for company ${finalCompanyId}: ${topup.ai_responses} AI responses added`
        );
      } else {
        // If no pending topup found, create one from the webhook data
        console.log("No pending topup found, creating from webhook data");
        if (companyId) {
          try {
            // Parse metadata to get AI responses
            let aiResponses = 100; // Default
            try {
              if (req.body.metadata) {
                const metadata = JSON.parse(req.body.metadata);
                aiResponses = metadata.aiResponses || aiResponses;
              }
            } catch (e) {
              console.log(
                "Could not parse metadata for AI responses:",
                e.message
              );
            }

            // Create the topup transaction directly
            await sqlDb.query(
              `INSERT INTO topup_transactions (
                company_id, email, amount, ai_responses, payment_intent_id, 
                status, completed_at, metadata
              ) VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, $7)`,
              [
                companyId, // This should be '0210' from metadata
                req.body.customer_name || "admin@juta.com",
                parseFloat(amount) / 100, // Convert from cents
                aiResponses,
                payment_intent,
                "completed",
                JSON.stringify({
                  txn_id,
                  txn_date,
                  external_txn_id,
                  auth_code,
                  auth_number,
                  reference_number,
                  source: "webhook_fallback",
                  company_id_from_metadata: companyId,
                }),
              ]
            );

            // Get company plan for quota calculation
            const companyResult = await sqlDb.query(
              `SELECT plan FROM companies WHERE company_id = $1`,
              [companyId]
            );
            const companyPlan = companyResult.rows[0]?.plan || "free";

            // Update quota
            const quotaKey = getQuotaKey(companyPlan);

            // Get current quota
            const quotaResult = await sqlDb.query(
              `SELECT setting_value FROM settings 
               WHERE company_id = $1 AND setting_type = 'messaging' AND setting_key = 'quotaAIMessage'`,
              [companyId]
            );

            let quotaObj = {};
            if (quotaResult.rows.length > 0) {
              try {
                quotaObj =
                  typeof quotaResult.rows[0].setting_value === "string"
                    ? JSON.parse(quotaResult.rows[0].setting_value)
                    : quotaResult.rows[0].setting_value || {};
              } catch {
                quotaObj = {};
              }
            }

            // Add top-up amount to quota with plan-based default
            if (!quotaObj[quotaKey]) {
              quotaObj[quotaKey] = getPlanBasedQuota(companyPlan);
            }
            quotaObj[quotaKey] += aiResponses;

            // Update quota in settings
            if (quotaResult.rows.length > 0) {
              await sqlDb.query(
                `UPDATE settings SET setting_value = $1, updated_at = CURRENT_TIMESTAMP
                 WHERE company_id = $2 AND setting_type = 'messaging' AND setting_key = 'quotaAIMessage'`,
                [JSON.stringify(quotaObj), companyId]
              );
            } else {
              await sqlDb.query(
                `INSERT INTO settings (company_id, setting_type, setting_key, setting_value, created_at, updated_at)
                 VALUES ($1, 'messaging', 'quotaAIMessage', $2, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
                [companyId, JSON.stringify(quotaObj)]
              );
            }

            console.log(
              `Top-up completed for company ${companyId} via webhook fallback: ${aiResponses} AI responses added`
            );
          } catch (fallbackError) {
            console.error(
              "Error in webhook fallback processing:",
              fallbackError
            );
          }
        }
      }
    } else if (paymentStatus === "failed") {
      // Update top-up status to failed
      await sqlDb.query(
        `UPDATE pending_topups SET status = $1, completed_at = CURRENT_TIMESTAMP WHERE payment_intent_id = $2`,
        [paymentStatus, payment_intent]
      );
    }

    res.json({ success: true });
  } catch (error) {
    console.error("PayEx webhook error:", error);
    res.status(500).json({ error: "Webhook processing failed" });
  }
});

// Test webhook endpoint (for development/testing)
app.post("/api/payex/test-webhook", async (req, res) => {
  try {
    console.log("Test webhook received:", req.body);

    // Simulate a successful PayEx webhook
    const testWebhookData = {
      payment_intent: req.body.payment_intent_id || "test_key_123",
      response: "00", // Success
      amount: req.body.amount || "1000",
      reference_number: req.body.reference_number || "test_ref_123",
      txn_id: "test_txn_123",
      txn_date: new Date().toISOString(),
      external_txn_id: "test_external_123",
      auth_code: "test_auth_123",
      auth_number: "test_auth_num_123",
      signature: "test_signature_123",
    };

    // Process the test webhook
    const webhookReq = { body: testWebhookData };
    const webhookRes = {
      json: (data) => console.log("Test webhook response:", data),
    };

    // Call the actual webhook handler
    await app._router.handle(webhookReq, webhookRes, () => {});

    res.json({
      success: true,
      message: "Test webhook processed",
      testData: testWebhookData,
    });
  } catch (error) {
    console.error("Test webhook error:", error);
    res.status(500).json({ error: "Test webhook failed" });
  }
});

// Get top-up history for a company
app.get("/api/payex/topup-history/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;

    const historyResult = await sqlDb.query(
      `SELECT * FROM topup_transactions 
       WHERE company_id = $1 
       ORDER BY completed_at DESC 
       LIMIT 50`,
      [companyId]
    );

    res.json({
      success: true,
      history: historyResult.rows,
    });
  } catch (error) {
    console.error("Top-up history error:", error);
    res.status(500).json({ error: "Failed to fetch top-up history" });
  }
});

// Get current quota status for a company
app.get("/api/payex/quota-status/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;

    const now = new Date();
    const year = now.getFullYear();
    const month = (now.getMonth() + 1).toString().padStart(2, "0");
    const monthlyKey = `${year}-${month}`;

    // Get current usage
    const usageResult = await sqlDb.query(
      `SELECT SUM(usage_count) AS total_usage
       FROM usage_logs
       WHERE company_id = $1 AND feature = 'aiMessages'
       AND to_char(date, 'YYYY-MM') = $2`,
      [companyId, monthlyKey]
    );

    const currentUsage = usageResult.rows[0]?.total_usage || 0;

    // Get current quota
    const quotaResult = await sqlDb.query(
      `SELECT setting_value FROM settings
       WHERE company_id = $1 AND setting_type = 'messaging' AND setting_key = 'quotaAIMessage'`,
      [companyId]
    );

    let quotaObj = {};
    if (quotaResult.rows.length > 0) {
      try {
        quotaObj =
          typeof quotaResult.rows[0].setting_value === "string"
            ? JSON.parse(quotaResult.rows[0].setting_value)
            : quotaResult.rows[0].setting_value || {};
      } catch {
        quotaObj = {};
      }
    }

    const currentQuota = quotaObj[monthlyKey] || 500;
    const remainingQuota = Math.max(0, currentQuota - currentUsage);

    res.json({
      success: true,
      currentUsage,
      currentQuota,
      remainingQuota,
      monthlyKey,
    });
  } catch (error) {
    console.error("Quota status error:", error);
    res.status(500).json({ error: "Failed to fetch quota status" });
  }
});

app.post("/api/followup-save-templates/", async (req, res) => {
  try {
    const { companyId, email, templates } = req.body;

    console.log("=== SAVE API DEBUG ===");
    console.log("Request received:", {
      companyId,
      email,
      templatesCount: templates?.length,
    });

    // Validate required fields
    if (!companyId || !email || !templates || !Array.isArray(templates)) {
      return res.status(400).json({
        success: false,
        error: "MISSING_FIELDS",
        details: "companyId, email, and templates array are required",
      });
    }

    const sqlClient = await pool.connect();
    let templatesUpdated = 0;
    let templatesCreated = 0;

    try {
      await sqlClient.query("BEGIN");

      for (const template of templates) {
        console.log(
          `Processing template: ${template.stageName} with ${
            template.messages?.length || 0
          } messages`
        );
        console.log(
          `Template has templateId: ${template.templateId ? "YES" : "NO"}`
        );

        // Validate template structure
        if (
          !template.stageName ||
          !template.messages ||
          !Array.isArray(template.messages)
        ) {
          console.error(`Invalid template structure:`, template);
          throw new Error(
            `Invalid template structure for ${template.stageName || "unknown"}`
          );
        }

        // Check if template exists by name and company
        const existingTemplate = await sqlClient.query(
          `SELECT id, template_id FROM public.followup_templates WHERE company_id = $1 AND name = $2`,
          [companyId, template.stageName]
        );

        if (existingTemplate.rows.length > 0) {
          console.log(`Updating existing template: ${template.stageName}`);
          console.log(
            `Existing template ID: ${existingTemplate.rows[0].id}, Template ID: ${existingTemplate.rows[0].template_id}`
          );

          // Update existing template
          await sqlClient.query(
            `UPDATE public.followup_templates SET 
             trigger_keywords = $1, trigger_tags = $2, content = $3, updated_at = CURRENT_TIMESTAMP 
             WHERE company_id = $4 AND name = $5`,
            [
              template.triggerKeywords || [],
              template.triggerTags || [],
              template.purpose || "",
              companyId,
              template.stageName,
            ]
          );

          // For existing templates, use the existing template_id (VARCHAR) to link messages
          const templateId = existingTemplate.rows[0].template_id; // This is the VARCHAR template_id
          console.log(`Using existing template_id for messages: ${templateId}`);

          // Delete existing messages
          await sqlClient.query(
            `DELETE FROM public.followup_messages WHERE template_id = $1`,
            [templateId]
          );

          // Insert new messages
          for (let i = 0; i < template.messages.length; i++) {
            const message = template.messages[i];
            console.log(
              `Inserting message ${i + 1}: ${
                message.message
                  ? message.message.substring(0, 50)
                  : "No message"
              }...`
            );

            // Handle both old string format and new object format
            const messageText =
              typeof message === "string" ? message : message.message;
            const messageData =
              typeof message === "object"
                ? message
                : {
                    message: message,
                    dayNumber: i + 1,
                    sequence: i + 1,
                    delayAfter: {
                      value: 30,
                      unit: "minutes",
                      isInstantaneous: false,
                    },
                    useScheduledTime: false,
                    scheduledTime: "",
                    addTags: [],
                    removeTags: [],
                    specificNumbers: {
                      enabled: false,
                      numbers: [],
                    },
                  };

            await sqlClient.query(
              `INSERT INTO public.followup_messages (
                template_id, message, day_number, sequence, status, created_at, 
                delay_after, specific_numbers, use_scheduled_time, scheduled_time, add_tags, remove_tags
              ) VALUES ($1, $2, $3, $4, 'active', CURRENT_TIMESTAMP, $5, $6, $7, $8, $9, $10)`,
              [
                templateId, // Use the existing VARCHAR template_id
                messageText,
                messageData.dayNumber,
                messageData.sequence,
                JSON.stringify(messageData.delayAfter), // delay_after
                JSON.stringify(messageData.specificNumbers), // specific_numbers
                messageData.useScheduledTime, // use_scheduled_time
                messageData.scheduledTime || null, // scheduled_time
                messageData.addTags, // add_tags
                messageData.removeTags, // remove_tags
              ]
            );
          }
          templatesUpdated++;
        } else {
          console.log(`Creating new template: ${template.stageName}`);

          // For new templates, use the templateId from the frontend if provided, otherwise generate one
          const templateId =
            template.templateId ||
            `template_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          console.log(`Creating template with templateId: ${templateId}`);

          const templateResult = await sqlClient.query(
            `INSERT INTO public.followup_templates (
              company_id, template_id, name, trigger_keywords, trigger_tags, content, 
              status, created_at, updated_at, delay_hours
            ) VALUES ($1, $2, $3, $4, $5, $6, 'active', CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, $7) RETURNING id, template_id`,
            [
              companyId,
              templateId,
              template.stageName,
              template.triggerKeywords || [],
              template.triggerTags || [],
              template.purpose || "",
              24, // default delay_hours
            ]
          );

          // For new templates, use the template_id (VARCHAR) to link messages
          const newTemplateId = templateResult.rows[0].template_id; // This is the VARCHAR template_id
          console.log(
            `New template created with template_id: ${newTemplateId}`
          );

          // Insert messages
          for (let i = 0; i < template.messages.length; i++) {
            const message = template.messages[i];
            console.log(
              `Inserting message ${i + 1}: ${
                message.message
                  ? message.message.substring(0, 50)
                  : "No message"
              }...`
            );

            // Handle both old string format and new object format
            const messageText =
              typeof message === "string" ? message : message.message;
            const messageData =
              typeof message === "object"
                ? message
                : {
                    message: message,
                    dayNumber: i + 1,
                    sequence: i + 1,
                    delayAfter: {
                      value: 30,
                      unit: "minutes",
                      isInstantaneous: false,
                    },
                    useScheduledTime: false,
                    scheduledTime: "",
                    addTags: [],
                    removeTags: [],
                    specificNumbers: {
                      enabled: false,
                      numbers: [],
                    },
                  };

            await sqlClient.query(
              `INSERT INTO public.followup_messages (
                template_id, message, day_number, sequence, status, created_at, 
                delay_after, specific_numbers, use_scheduled_time, scheduled_time, add_tags, remove_tags
              ) VALUES ($1, $2, $3, $4, 'active', CURRENT_TIMESTAMP, $5, $6, $7, $8, $9, $10)`,
              [
                newTemplateId, // Use the VARCHAR template_id
                messageText,
                messageData.dayNumber,
                messageData.sequence,
                JSON.stringify(messageData.delayAfter), // delay_after
                JSON.stringify(messageData.specificNumbers), // specific_numbers
                messageData.useScheduledTime, // use_scheduled_time
                messageData.scheduledTime || null, // scheduled_time
                messageData.addTags, // add_tags
                messageData.removeTags, // remove_tags
              ]
            );
          }
          templatesCreated++;
        }
      }

      await sqlClient.query("COMMIT");
      console.log(
        `✅ Successfully processed: ${templatesUpdated} updated, ${templatesCreated} created`
      );

      res.json({
        success: true,
        data: {
          templatesUpdated,
          templatesCreated,
          totalChanges: templatesUpdated + templatesCreated,
        },
      });
    } catch (error) {
      await sqlClient.query("ROLLBACK");
      console.error("Database error during save:", error);
      throw error;
    } finally {
      sqlClient.release();
    }
  } catch (error) {
    console.error("Follow-up save templates error:", error);
    res.status(500).json({
      success: false,
      error: error.code || "UNKNOWN_ERROR",
      details: error.message,
    });
  }
});

async function getAIAssignResponses(companyId) {
  console.log("Starting getAIAssignResponses for companyId:", companyId);
  const responses = [];
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting getAIAssignResponses"
    );
    return [];
  }

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        response_id,
        keywords,
        keyword_source,
        assigned_employees,
        description,
        created_at,
        status
      FROM 
        public.ai_assign_responses
      WHERE 
        company_id = $1 
        AND status = 'active'
    `;

    const result = await sqlClient.query(query, [companyId]);

    for (const row of result.rows) {
      console.log("\nProcessing record:", row.response_id);

      const assignedEmployees = row.assigned_employees || [];

      if (assignedEmployees.length === 0) {
        console.log("No assigned employees found, skipping record");
        continue;
      }

      const responseObj = {
        keywords: Array.isArray(row.keywords)
          ? row.keywords
          : [row.keywords?.toLowerCase()].filter(Boolean),
        keywordSource: row.keyword_source || "user",
        assignedEmployees: assignedEmployees,
        description: row.description || "",
        createdAt: row.created_at || null,
        status: row.status || "active",
      };

      responses.push(responseObj);
    }

    await sqlClient.query("COMMIT");
    return responses;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error in getAIAssignResponses:", error);
    console.error("Full error:", error.stack);
    throw error;
  } finally {
    await safeRelease(sqlClient);
  }
}

async function getAITagResponses(companyId) {
  const responses = [];
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting getAITagResponses"
    );
    return [];
  }

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        response_id,
        keywords,
        tags,
        remove_tags,
        keyword_source,
        tag_action_mode
      FROM 
        public.ai_tag_responses
      WHERE 
        company_id = $1 
        AND status = 'active'
    `;

    const result = await sqlClient.query(query, [companyId]);

    for (const row of result.rows) {
      responses.push({
        keywords: row.keywords || [],
        tags: row.tags || [],
        removeTags: row.remove_tags || [],
        keywordSource: row.keyword_source || "user",
        tagActionMode: row.tag_action_mode || "add",
      });
    }

    await sqlClient.query("COMMIT");
    return responses;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error fetching AI tag responses:", error);
    throw error;
  } finally {
    await safeRelease(sqlClient);
  }
}

async function getAIImageResponses(companyId) {
  const responses = [];
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting getAIImageResponses"
    );
    return [];
  }

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        response_id,
        keywords,
        image_urls,
        keyword_source,
        status
      FROM 
        public.ai_image_responses
      WHERE 
        company_id = $1 
        AND status = 'active'
    `;

    const result = await sqlClient.query(query, [companyId]);

    for (const row of result.rows) {
      responses.push({
        keywords: row.keywords || [],
        imageUrls: row.image_urls || [],
        keywordSource: row.keyword_source || "user",
      });
    }

    await sqlClient.query("COMMIT");
    return responses;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error fetching AI image responses:", error);
    throw error;
  } finally {
    await safeRelease(sqlClient);
  }
}

async function getAIVideoResponses(companyId) {
  const responses = [];
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting getAIVideoResponses"
    );
    return [];
  }

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        response_id,
        keywords,
        video_urls,
        captions,
        keyword_source,
        status
      FROM 
        public.ai_video_responses
      WHERE 
        company_id = $1 
        AND status = 'active'
    `;

    const result = await sqlClient.query(query, [companyId]);

    for (const row of result.rows) {
      responses.push({
        keywords: row.keywords || [],
        videoUrls: row.video_urls || [],
        captions: row.captions || [],
        keywordSource: row.keyword_source || "user",
      });
    }

    await sqlClient.query("COMMIT");
    return responses;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error fetching AI video responses:", error);
    throw error;
  } finally {
    await safeRelease(sqlClient);
  }
}

async function getAIVoiceResponses(companyId) {
  const responses = [];
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting getAIVoiceResponses"
    );
    return [];
  }

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        response_id,
        keywords,
        voice_urls,
        captions,
        keyword_source
      FROM 
        public.ai_voice_responses
      WHERE 
        company_id = $1 
        AND status = 'active'
    `;

    const result = await sqlClient.query(query, [companyId]);

    for (const row of result.rows) {
      responses.push({
        keywords: row.keywords || [],
        voiceUrls: row.voice_urls || [],
        captions: row.captions || [],
        keywordSource: row.keyword_source || "user",
      });
    }

    await sqlClient.query("COMMIT");
    return responses;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error fetching AI voice responses:", error);
    throw error;
  } finally {
    await safeRelease(sqlClient);
  }
}

async function getAIDocumentResponses(companyId) {
  const responses = [];
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting getAIDocumentResponses"
    );
    return [];
  }

  try {
    await sqlClient.query("BEGIN");

    const query = `
      SELECT 
        response_id,
        keywords,
        document_urls,
        document_names,
        keyword_source
      FROM 
        public.ai_document_responses
      WHERE 
        company_id = $1 
        AND status = 'active'
    `;

    const result = await sqlClient.query(query, [companyId]);

    for (const row of result.rows) {
      responses.push({
        keywords: row.keywords || [],
        documentUrls: row.document_urls || [],
        documentNames: row.document_names || [],
        keywordSource: row.keyword_source || "user",
      });
    }

    await sqlClient.query("COMMIT");
    return responses;
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error fetching AI document responses:", error);
    throw error;
  } finally {
    await safeRelease(sqlClient);
  }
}

async function checkKeywordMatch(response, message, keywordSource) {
  return (
    response.keywordSource === keywordSource &&
    response.keywords.some((kw) =>
      message.toLowerCase().includes(kw.toLowerCase())
    )
  );
}

async function checkKeywordMatchTemplate(
  keywords,
  message,
  tempKeywordSource,
  keywordSource
) {
  return (
    keywordSource === tempKeywordSource &&
    keywords.some((kw) => message.toLowerCase().includes(kw.toLowerCase()))
  );
}

// Handles AI video responses
async function handleAIVideoResponses({
  client,
  message,
  chatId,
  extractedNumber,
  idSubstring,
  contactName,
  keywordSource,
  phoneIndex,
}) {
  if (!companyConfig.status_ai_responses?.ai_video) {
    return false;
  }

  const aiVideoResponses = await getAIVideoResponses(idSubstring);

  for (const response of aiVideoResponses) {
    if (await checkKeywordMatch(response, message, keywordSource)) {
      console.log("Videos found for keywords:", response.keywords);

      for (let i = 0; i < response.videoUrls.length; i++) {
        try {
          const videoUrl = response.videoUrls[i];
          const caption = response.captions?.[i] || "";

          const media = await MessageMedia.fromUrl(videoUrl);
          if (!media) throw new Error("Failed to load video from URL");

          const videoMessage = await client.sendMessage(chatId, media, {
            caption,
            sendVideoAsGif: false,
          });
          console.log("Video message sent successfully:", videoMessage);

          await addMessageToPostgres(
            videoMessage,
            idSubstring,
            extractedNumber,
            contactName,
            phoneIndex
          );
          await new Promise((resolve) => setTimeout(resolve, 1000));
        } catch (error) {
          console.error(`Error sending video ${i}:`, error);
        }
      }
    }
  }
}

// Handles AI voice responses
async function handleAIVoiceResponses({
  client,
  message,
  chatId,
  extractedNumber,
  idSubstring,
  contactName,
  keywordSource,
  phoneIndex,
}) {
  if (!companyConfig.status_ai_responses?.ai_voice) {
    return false;
  }

  const aiVoiceResponses = await getAIVoiceResponses(idSubstring);

  for (const response of aiVoiceResponses) {
    if (await checkKeywordMatch(response, message, keywordSource)) {
      console.log("Voice messages found for keywords:", response.keywords);

      for (let i = 0; i < response.voiceUrls.length; i++) {
        try {
          const caption = response.captions?.[i] || "";
          const voiceMessage = await sendVoiceMessage(
            client,
            chatId,
            response.voiceUrls[i],
            caption
          );
          await addMessageToPostgres(
            voiceMessage,
            idSubstring,
            extractedNumber,
            contactName,
            phoneIndex
          );

          if (i < response.voiceUrls.length - 1) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
          }
        } catch (error) {
          console.error(`Error sending voice message:`, error);
        }
      }
    }
  }
}

async function sendVoiceMessage(client, chatId, voiceUrl, caption = "") {
  try {
    console.log("Sending voice message:", { chatId, voiceUrl, caption });

    // Download the audio file
    const response = await axios.get(voiceUrl, { responseType: "arraybuffer" });
    const audioBuffer = Buffer.from(response.data);

    // Create MessageMedia object
    const media = new MessageMedia(
      "audio/mpeg", // Default MIME type for voice messages
      audioBuffer.toString("base64"),
      `voice_${Date.now()}.mp3` // Generate unique filename
    );

    // Send the voice message with options
    const messageOptions = {
      sendAudioAsVoice: true, // This ensures it's sent as a voice message
    };

    if (caption) {
      messageOptions.caption = caption;
    }

    const sent = await client.sendMessage(chatId, media, messageOptions);
    console.log("Voice message sent successfully");

    return sent;
  } catch (error) {
    console.error("Error sending voice message:", error);
    // Log detailed error information
    if (error.response) {
      console.error("Response error:", {
        status: error.response.status,
        data: error.response.data,
      });
    }
    throw new Error(`Failed to send voice message: ${error.message}`);
  }
}

// Handles AI image responses
async function handleAIImageResponses({
  client,
  message,
  chatId,
  extractedNumber,
  idSubstring,
  contactName,
  keywordSource,
  phoneIndex,
}) {
  if (!companyConfig.status_ai_responses?.ai_image) {
    return false;
  }

  const aiImageResponses = await getAIImageResponses(idSubstring);

  for (const response of aiImageResponses) {
    if (await checkKeywordMatch(response, message, keywordSource)) {
      console.log("Images found for keywords:", response.keywords);

      for (const imageUrl of response.imageUrls) {
        try {
          console.log("Sending image:", imageUrl);
          console.log("Chat ID:", chatId);
          const media = await MessageMedia.fromUrl(imageUrl);
          const imageMessage = await client.sendMessage(chatId, media);
          await addMessageToPostgres(
            imageMessage,
            idSubstring,
            extractedNumber,
            contactName,
            phoneIndex
          );
        } catch (error) {
          console.error(`Error sending image:`, error);
        }
      }
    }
  }
}

// Handles AI document responses
async function handleAIDocumentResponses({
  client,
  message,
  chatId,
  extractedNumber,
  idSubstring,
  contactName,
  keywordSource,
  phoneIndex,
}) {
  if (!companyConfig.status_ai_responses?.ai_document) {
    return false;
  }

  const aiDocumentResponses = await getAIDocumentResponses(idSubstring);

  for (const response of aiDocumentResponses) {
    if (await checkKeywordMatch(response, message, keywordSource)) {
      console.log("Documents found for keywords:", response.keywords);

      for (let i = 0; i < response.documentUrls.length; i++) {
        try {
          const documentUrl = response.documentUrls[i];
          const documentName = response.documentNames[i] || `document_${i + 1}`;

          const media = await MessageMedia.fromUrl(documentUrl);
          if (!media) throw new Error("Failed to load document from URL");

          media.filename = documentName;
          media.mimetype =
            media.mimetype ||
            getMimeTypeFromExtension(path.extname(documentName));

          const documentMessage = await client.sendMessage(chatId, media, {
            sendMediaAsDocument: true,
          });

          await addMessageToPostgres(
            documentMessage,
            idSubstring,
            extractedNumber,
            contactName,
            phoneIndex
          );
          await new Promise((resolve) => setTimeout(resolve, 1000));
        } catch (error) {
          console.error(`Error sending document:`, error);
        }
      }
    }
  }
}

// Handles AI tag responses
async function handleAITagResponses({
  message,
  extractedNumber,
  idSubstring,
  contactName,
  phoneIndex,
  keywordSource,
  followUpTemplates,
}) {
  if (!companyConfig.status_ai_responses?.ai_tag) {
    return false;
  }

  console.log("=== Starting handleAITagResponses ===");
  console.log("Message:", message);
  console.log("Extracted number:", extractedNumber);
  console.log("Company ID substring:", idSubstring);
  console.log("Contact name:", contactName);
  console.log("Phone index:", phoneIndex);
  console.log("Keyword source:", keywordSource);

  const aiTagResponses = await getAITagResponses(idSubstring);

  for (const response of aiTagResponses) {
    if (await checkKeywordMatch(response, message, keywordSource)) {
      console.log("Tags found for keywords:", response.keywords);

      try {
        if (response.tagActionMode === "delete") {
          await handleTagDeletion(
            response,
            extractedNumber,
            idSubstring,
            followUpTemplates
          );
        } else {
          await handleTagAddition(
            response,
            extractedNumber,
            idSubstring,
            followUpTemplates,
            contactName,
            phoneIndex
          );
        }
      } catch (error) {
        console.error(`Error handling tags:`, error);
      }
    }
  }
}

// Handles AI assignment responses
async function handleAIAssignResponses({
  client,
  message,
  extractedNumber,
  idSubstring,
  contactName,
  keywordSource,
}) {
  if (!companyConfig.status_ai_responses?.ai_assign) {
    return false;
  }

  const aiAssignResponses = await getAIAssignResponses(idSubstring);

  for (const response of aiAssignResponses) {
    if (await checkKeywordMatch(response, message, keywordSource)) {
      console.log("Assignment found for keywords:", response.keywords);

      try {
        const matchedKeyword = response.keywords.find((kw) =>
          message.toLowerCase().includes(kw.toLowerCase())
        );

        await handleEmployeeAssignment(
          response,
          idSubstring,
          extractedNumber,
          contactName,
          client,
          matchedKeyword
        );
      } catch (error) {
        console.error(`Error handling assignment:`, error);
      }
    }
  }
}

function getMimeTypeFromExtension(ext) {
  const mimeTypes = {
    ".pdf": "application/pdf",
    ".doc": "application/msword",
    ".docx":
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".xls": "application/vnd.ms-excel",
    ".xlsx":
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".ppt": "application/vnd.ms-powerpoint",
    ".pptx":
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ".txt": "text/plain",
    ".csv": "text/csv",
    ".zip": "application/zip",
    ".rar": "application/x-rar-compressed",
  };
  return mimeTypes[ext.toLowerCase()] || "application/octet-stream";
}

async function handleAIFollowUpResponses({
  msg,
  extractedNumber,
  idSubstring,
  contactName,
  phoneIndex,
  keywordSource,
  followUpTemplates,
}) {
  for (const template of followUpTemplates) {
    if (
      await checkKeywordMatchTemplate(
        template.triggerKeywords,
        msg,
        template.keywordSource,
        keywordSource
      )
    ) {
      console.log("Follow-up trigger found for template:", template.name);

      try {
        await processFollowUpTemplate(
          template,
          extractedNumber,
          idSubstring,
          contactName,
          phoneIndex,
          followUpTemplates
        );
      } catch (error) {
        console.error("Error triggering follow-up sequence:", error);
      }
      return true;
    }
  }
  return false;
}

async function handleTagDeletion(
  response,
  extractedNumber,
  idSubstring,
  followUpTemplates
) {
  for (const tag of response.tags) {
    await addTagToPostgres(extractedNumber, tag, idSubstring, true);
    console.log(`Removed tag: ${tag} from number: ${extractedNumber}`);

    await handleFollowUpTemplateCleanup(
      tag,
      extractedNumber,
      idSubstring,
      followUpTemplates
    );
  }
}

async function handleTagAddition(
  response,
  extractedNumber,
  idSubstring,
  followUpTemplates,
  contactName,
  phoneIndex
) {
  console.log("=== Starting handleTagAddition ===");
  console.log("Response object:", JSON.stringify(response, null, 2));
  console.log("Extracted number:", extractedNumber);
  console.log("Company ID:", idSubstring);
  console.log("Contact name:", contactName);
  console.log("Phone index:", phoneIndex);

  try {
    // Handle tag removal first
    const tagsToRemove = response.remove_tags || response.removeTags || [];
    console.log("Tags to remove:", tagsToRemove);

    for (const tagToRemove of tagsToRemove) {
      console.log(`Processing tag removal: ${tagToRemove}`);
      try {
        await addTagToPostgres(extractedNumber, tagToRemove, idSubstring, true);
        console.log(`Successfully removed tag: ${tagToRemove}`);

        await handleFollowUpTemplateCleanup(
          tagToRemove,
          extractedNumber,
          idSubstring,
          followUpTemplates
        );
        console.log(
          `Successfully cleaned up followup templates for removed tag: ${tagToRemove}`
        );
      } catch (error) {
        console.error(`Error removing tag ${tagToRemove}:`, error);
      }
    }

    // Handle tag addition
    const tagsToAdd =
      response.tags || response.add_tags || response.addTags || [];
    console.log("Tags to add:", tagsToAdd);

    for (const tag of tagsToAdd) {
      console.log(`Processing tag addition: ${tag}`);
      try {
        await addTagToPostgres(extractedNumber, tag, idSubstring);
        console.log(
          `Successfully added tag: ${tag} for number: ${extractedNumber}`
        );

        await handleFollowUpTemplateActivation(
          tag,
          extractedNumber,
          idSubstring,
          contactName,
          phoneIndex,
          followUpTemplates
        );
        console.log(
          `Successfully activated followup templates for added tag: ${tag}`
        );
      } catch (error) {
        console.error(`Error adding tag ${tag}:`, error);
      }
    }

    console.log("=== Completed handleTagAddition ===");
  } catch (error) {
    console.error("Error in handleTagAddition:", error);
    console.error("Full error stack:", error.stack);
    throw error;
  }
}

async function addTagToPostgres(contactID, tag, companyID, remove = false) {
  console.log(`=== Starting addTagToPostgres ===`);
  console.log(`Action: ${remove ? "Removing" : "Adding"} tag "${tag}"`);
  console.log(`Contact ID (input): ${contactID}`);
  console.log(`Company ID: ${companyID}`);
  console.log(`Remove flag: ${remove}`);

  // Construct the full contact ID
  const fullContactID =
    companyID +
    "-" +
    (contactID.startsWith("+") ? contactID.slice(1) : contactID);
  console.log(`Full contact ID: ${fullContactID}`);

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting addTagToPostgres"
    );
    return;
  }

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    // Check if contact exists
    const checkQuery = `
      SELECT 1 FROM public.contacts 
      WHERE contact_id = $1 AND company_id = $2
    `;
    console.log("Checking if contact exists...");
    const checkResult = await sqlClient.query(checkQuery, [
      fullContactID,
      companyID,
    ]);
    console.log(`Contact check result: ${checkResult.rows.length} rows found`);

    if (checkResult.rows.length === 0) {
      console.error(
        `Contact does not exist: ${fullContactID} in company ${companyID}`
      );
      throw new Error("Contact does not exist!");
    }

    console.log("Contact exists, proceeding with tag operation");

    if (remove) {
      console.log("Executing tag removal...");

      // First check if tag exists
      const tagExistsQuery = `
        SELECT (tags ? $1::text) AS tag_exists 
        FROM public.contacts 
        WHERE contact_id = $2 AND company_id = $3
      `;
      const tagExistsResult = await sqlClient.query(tagExistsQuery, [
        tag,
        fullContactID,
        companyID,
      ]);

      const tagExists = tagExistsResult.rows[0]?.tag_exists || false;
      console.log(`Tag "${tag}" exists before removal: ${tagExists}`);

      // Remove the tag
      const removeQuery = `
        UPDATE public.contacts 
        SET 
          tags = CASE 
            WHEN tags ? $1::text THEN 
              (SELECT jsonb_agg(t) FROM jsonb_array_elements_text(tags) t WHERE t != $1::text)
            ELSE 
              tags 
          END,
          last_updated = CURRENT_TIMESTAMP
        WHERE contact_id = $2 AND company_id = $3
      `;
      await sqlClient.query(removeQuery, [tag, fullContactID, companyID]);

      if (tagExists) {
        console.log(
          `Tag "${tag}" removed successfully from contact ${fullContactID}`
        );

        // Handle monthly assignment tracking for employee tags
        if (await isEmployeeTag(tag, companyID)) {
          console.log(`Decrementing monthly assignment for employee: ${tag}`);
          await decrementMonthlyAssignment(companyID, tag, sqlClient);
        }
      } else {
        console.log(`Tag "${tag}" doesn't exist for contact ${fullContactID}`);
      }
    } else {
      console.log("Executing tag addition...");

      // First check if tag already exists
      const tagExistsQuery = `
        SELECT (tags ? $1::text) AS tag_exists 
        FROM public.contacts 
        WHERE contact_id = $2 AND company_id = $3
      `;
      const tagExistsResult = await sqlClient.query(tagExistsQuery, [
        tag,
        fullContactID,
        companyID,
      ]);

      const tagExists = tagExistsResult.rows[0]?.tag_exists || false;
      console.log(`Tag "${tag}" exists before addition: ${tagExists}`);

      // Add the tag
      const addQuery = `
        UPDATE public.contacts 
        SET 
          tags = CASE 
            WHEN tags IS NULL THEN jsonb_build_array($1::text)
            WHEN NOT tags ? $1::text THEN tags || jsonb_build_array($1::text)
            ELSE tags
          END,
          last_updated = CURRENT_TIMESTAMP
        WHERE contact_id = $2 AND company_id = $3
      `;
      await sqlClient.query(addQuery, [tag, fullContactID, companyID]);

      if (!tagExists) {
        console.log(
          `Tag "${tag}" added successfully to contact ${fullContactID}`
        );

        // Handle monthly assignment tracking for employee tags
        if (await isEmployeeTag(tag, companyID)) {
          console.log(`Incrementing monthly assignment for employee: ${tag}`);
          await incrementMonthlyAssignment(companyID, tag, sqlClient);
        }
      } else {
        console.log(`Tag "${tag}" already exists for contact ${fullContactID}`);
      }
    }

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error managing tags in PostgreSQL:", error);
    console.error("Full error stack:", error.stack);
    throw error;
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
    console.log(`=== Completed addTagToPostgres ===`);
  }
}

async function isEmployeeTag(tag, companyID) {
  console.log(
    `Checking if tag "${tag}" is an employee for company ${companyID}`
  );
  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error("Failed to get database connection - aborting isEmployeeTag");
    return false;
  }

  try {
    const query = `
      SELECT 1 FROM public.employees 
      WHERE company_id = $1 AND name = $2
    `;
    const result = await sqlClient.query(query, [companyID, tag]);
    const isEmployee = result.rows.length > 0;
    console.log(`Tag "${tag}" is employee: ${isEmployee}`);
    return isEmployee;
  } catch (error) {
    console.error("Error checking if tag is employee:", error);
    return false;
  } finally {
    await safeRelease(sqlClient);
  }
}

async function incrementMonthlyAssignment(companyID, employeeName, sqlClient) {
  console.log(`Incrementing monthly assignment for employee: ${employeeName}`);

  try {
    const currentMonth = getCurrentMonthKey();
    console.log(`Current month key: ${currentMonth}`);

    // First get the employee ID from the employees table
    const employeeQuery = `
      SELECT id FROM public.employees 
      WHERE company_id = $1 AND name = $2
    `;

    const employeeResult = await sqlClient.query(employeeQuery, [
      companyID,
      employeeName,
    ]);

    if (employeeResult.rows.length === 0) {
      console.log(
        `No employee found with name ${employeeName} in company ${companyID}`
      );
      return 0;
    }

    const employeeId = employeeResult.rows[0].id;
    console.log(`Found employee ID: ${employeeId} for name: ${employeeName}`);

    const upsertQuery = `
      INSERT INTO public.employee_monthly_assignments (company_id, employee_id, month_key, assignments_count)
      VALUES ($1, $2, $3, 1)
      ON CONFLICT (employee_id, month_key)
      DO UPDATE SET assignments_count = employee_monthly_assignments.assignments_count + 1
      RETURNING assignments_count
    `;

    const result = await sqlClient.query(upsertQuery, [
      companyID,
      employeeId,
      currentMonth,
    ]);
    const newCount = result.rows[0].assignments_count;
    console.log(
      `Monthly assignment count for ${employeeName} is now: ${newCount}`
    );

    return newCount;
  } catch (error) {
    console.error("Error incrementing monthly assignment:", error);
    throw error;
  }
}

async function decrementMonthlyAssignment(companyID, employeeName, sqlClient) {
  console.log(`Decrementing monthly assignment for employee: ${employeeName}`);

  try {
    const currentMonth = getCurrentMonthKey();
    console.log(`Current month key: ${currentMonth}`);

    // First get the employee ID from the employees table
    const employeeQuery = `
      SELECT id FROM public.employees 
      WHERE company_id = $1 AND name = $2
    `;

    const employeeResult = await sqlClient.query(employeeQuery, [
      companyID,
      employeeName,
    ]);

    if (employeeResult.rows.length === 0) {
      console.log(
        `No employee found with name ${employeeName} in company ${companyID}`
      );
      return 0;
    }

    const employeeId = employeeResult.rows[0].id;
    console.log(`Found employee ID: ${employeeId} for name: ${employeeName}`);

    const updateQuery = `
      UPDATE public.employee_monthly_assignments 
      SET assignments_count = GREATEST(assignments_count - 1, 0)
      WHERE employee_id = $1 AND month_key = $2
      RETURNING assignments_count
    `;

    const result = await sqlClient.query(updateQuery, [
      employeeId,
      currentMonth,
    ]);

    if (result.rows.length > 0) {
      const newCount = result.rows[0].assignments_count;
      console.log(
        `Monthly assignment count for ${employeeName} is now: ${newCount}`
      );
      return newCount;
    } else {
      console.log(
        `No monthly assignment record found for ${employeeName} in ${currentMonth}`
      );
      return 0;
    }
  } catch (error) {
    console.error("Error decrementing monthly assignment:", error);
    throw error;
  }
}

async function handleEmployeeAssignment(
  response,
  idSubstring,
  extractedNumber,
  contactName,
  client,
  matchedKeyword
) {
  const stateResult = await pool.query(
    "SELECT current_index FROM bot_state WHERE company_id = $1 AND bot_name = $2",
    [idSubstring, "assignmentState"]
  );
  let currentIndex = stateResult.rows[0]?.current_index || 0;

  const employeeIDs = response.assignedEmployees;
  if (employeeIDs.length === 0) {
    console.log("No employees available for assignment");
    return;
  }

  const nextID = employeeIDs[currentIndex % employeeIDs.length];
  const employeeResult = await pool.query(
    "SELECT * FROM employees WHERE company_id = $1 AND id = $2",
    [idSubstring, nextID]
  );

  if (employeeResult.rows.length > 0) {
    const employeeData = employeeResult.rows[0];
    await assignToEmployee(
      employeeData,
      "Sales",
      extractedNumber,
      contactName,
      client,
      idSubstring,
      matchedKeyword
    );

    const newIndex = (currentIndex + 1) % employeeIDs.length;
    await pool.query(
      "INSERT INTO bot_state (company_id, bot_name, state, current_index, last_updated) " +
        "VALUES ($1, $2, $3, $4, $5) " +
        "ON CONFLICT (company_id, bot_name) DO UPDATE SET current_index = $4, last_updated = $5",
      [
        idSubstring,
        "assignmentState",
        { currentIndex: newIndex },
        newIndex,
        new Date(),
      ]
    );
  }
}

async function assignToEmployee(
  employee,
  role,
  contactID,
  contactName,
  client,
  idSubstring,
  triggerKeyword = "",
  phoneIndex = 0
) {
  const rawNumber = employee.phone_number?.replace(/\D/g, "");
  const employeeID = rawNumber ? rawNumber + "@c.us" : null;

  // Get current date and time in Malaysia timezone
  const currentDateTime = new Date().toLocaleString("en-MY", {
    timeZone: "Asia/Kuala_Lumpur",
    dateStyle: "medium",
    timeStyle: "medium",
  });

  const message =
    idSubstring === "0245"
      ? `Hello ${employee.name}, a new contact has been assigned to you:

Name: ${contactName}
Phone: ${contactID}
     
Triggered keyword: ${
          triggerKeyword ? `*${triggerKeyword}*` : "[No keyword trigger found]"
        }
     
Date & Time: ${currentDateTime}`
      : idSubstring === "0335"
      ? `Hello ${employee.name}, a new contact has been assigned to you:

Name: ${contactName}
Phone: ${contactID}

Thank you.`
      : `Hello ${employee.name}, a new contact has been assigned to you:

Name: ${contactName}
Phone: ${contactID}

Kindly login to the CRM software to continue.

Thank you.`;

  // Send WhatsApp message to employee
  await client.sendMessage(employeeID, message);

  // Add employee name as tag to contact
  await addTagToPostgres(contactID, employee.name, idSubstring);

  // Create assignment record in assignments table
  try {
    const sqlClient = await getDatabaseConnection();
    if (!sqlClient) {
      console.error(
        "Failed to get database connection - aborting assignToEmployee"
      );
      return;
    }
    try {
      await sqlClient.query("BEGIN");

      // Get contact details
      const contactQuery = `
        SELECT contact_id FROM contacts 
        WHERE phone = $1 AND company_id = $2
      `;
      const contactResult = await sqlClient.query(contactQuery, [
        contactID,
        idSubstring,
      ]);

      if (contactResult.rows.length > 0) {
        const currentDate = new Date();
        const currentMonthKey = `${currentDate.getFullYear()}-${(
          currentDate.getMonth() + 1
        )
          .toString()
          .padStart(2, "0")}`;

        const assignmentId = `${idSubstring}-${
          contactResult.rows[0].contact_id
        }-${employee.employee_id}-${Date.now()}`;

        const assignmentInsertQuery = `
          INSERT INTO assignments (
            assignment_id, company_id, employee_id, contact_id, 
            assigned_at, status, month_key, assignment_type, 
            phone_index, weightage_used, employee_role
          ) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, 'active', $5, 'auto', $6, 1, $7)
        `;

        await sqlClient.query(assignmentInsertQuery, [
          assignmentId,
          idSubstring,
          employee.employee_id,
          contactResult.rows[0].contact_id,
          currentMonthKey,
          phoneIndex,
          role,
        ]);

        // Update employee's assigned_contacts count
        const employeeUpdateQuery = `
          UPDATE employees
          SET assigned_contacts = assigned_contacts + 1
          WHERE company_id = $1 AND employee_id = $2
        `;

        await sqlClient.query(employeeUpdateQuery, [
          idSubstring,
          employee.employee_id,
        ]);

        // Update monthly assignments
        const monthlyAssignmentUpsertQuery = `
          INSERT INTO employee_monthly_assignments (employee_id, company_id, month_key, assignments_count, last_updated)
          VALUES ($1, $2, $3, 1, CURRENT_TIMESTAMP)
          ON CONFLICT (employee_id, month_key) DO UPDATE
          SET assignments_count = employee_monthly_assignments.assignments_count + 1,
              last_updated = CURRENT_TIMESTAMP
        `;

        await sqlClient.query(monthlyAssignmentUpsertQuery, [
          employee.id,
          idSubstring,
          currentMonthKey,
        ]);
      }

      await sqlClient.query("COMMIT");
    } catch (error) {
      await safeRollback(sqlClient);
      console.error("Error creating assignment record:", error);
    } finally {
      await safeRelease(sqlClient);
    }
  } catch (error) {
    console.error("Error in assignToEmployee database operations:", error);
  }

  console.log(`Assigned ${role}: ${employee.name}`);
}

async function processFollowUpTemplate(
  template,
  extractedNumber,
  idSubstring,
  contactName,
  phoneIndex,
  followUpTemplates
) {
  const contactResult = await pool.query(
    "SELECT tags FROM contacts WHERE company_id = $1 AND phone = $2",
    [idSubstring, extractedNumber]
  );
  const contactData = contactResult.rows[0];
  const currentTags = contactData?.tags || [];

  for (const otherTemplate of followUpTemplates) {
    const tagToRemove = otherTemplate.trigger_tags?.[0];
    if (tagToRemove && currentTags.includes(tagToRemove)) {
      await addTagToPostgres(extractedNumber, tagToRemove, idSubstring, true);
      await callFollowUpAPI(
        "removeTemplate",
        extractedNumber,
        contactName,
        phoneIndex,
        otherTemplate.id,
        idSubstring
      );
    }
  }

  if (template.trigger_tags.length > 0) {
    await addTagToPostgres(
      extractedNumber,
      template.trigger_tags[0],
      idSubstring
    );
  }

  await callFollowUpAPI(
    "startTemplate",
    extractedNumber,
    contactName,
    phoneIndex,
    template.id,
    idSubstring
  );
}

async function handleFollowUpTemplateCleanup(
  tag,
  extractedNumber,
  idSubstring,
  followUpTemplates
) {
  console.log(`=== Starting handleFollowUpTemplateCleanup ===`);
  console.log(`Tag to remove: ${tag}`);
  console.log(`Company ID: ${idSubstring}`);
  console.log(
    `Number of templates to check: ${
      followUpTemplates ? followUpTemplates.length : "undefined"
    }`
  );

  if (!followUpTemplates || !Array.isArray(followUpTemplates)) {
    console.log(`No follow-up templates provided or not an array`);
    return;
  }

  for (const template of followUpTemplates) {
    console.log(`\n--- Checking template: ${template.name || "unnamed"} ---`);
    console.log(`Template ID: ${template.id || template.templateId}`);
    console.log(`Template object:`, JSON.stringify(template, null, 2));

    // Check both possible field names for trigger tags
    const triggerTags = template.trigger_tags || template.triggerTags;
    console.log(`Trigger tags found: ${triggerTags}`);
    console.log(`Is trigger_tags array? ${Array.isArray(triggerTags)}`);
    console.log(`Tag to match: ${tag}`);
    console.log(`Includes check: ${triggerTags && triggerTags.includes(tag)}`);

    if (
      triggerTags &&
      Array.isArray(triggerTags) &&
      triggerTags.includes(tag)
    ) {
      console.log(
        `✓ Template "${template.name}" matches tag "${tag}" - calling removeTemplate API`
      );
      console.log(
        `Using templateId: ${template.templateId} (not UUID: ${template.id})`
      );
      await callFollowUpAPI(
        "removeTemplate",
        extractedNumber,
        null,
        null,
        template.templateId, // FIXED: Use templateId instead of id
        idSubstring
      );
    } else {
      console.log(`✗ Template "${template.name}" does not match tag "${tag}"`);
    }
  }
  console.log(`=== Completed handleFollowUpTemplateCleanup ===`);
}
async function handleFollowUpTemplateActivation(
  tag,
  extractedNumber,
  idSubstring,
  contactName,
  phoneIndex,
  followUpTemplates
) {
  console.log("=== Starting handleFollowUpTemplateActivation ===");
  console.log("Tag:", tag);
  console.log("Extracted number:", extractedNumber);
  console.log("Company ID:", idSubstring);
  console.log("Contact name:", contactName);
  console.log("Phone index:", phoneIndex);
  console.log("Number of templates:", followUpTemplates);

  for (const template of followUpTemplates) {
    console.log(`\n--- Checking template: ${template.name} ---`);
    console.log("Template ID:", template.templateId);
    console.log("Template UUID:", template.id);
    console.log("Trigger tags:", template.triggerTags);
    console.log("Is trigger_tags array?", Array.isArray(template.triggerTags));
    console.log("Tag to match:", tag);
    console.log(
      "Includes check:",
      template.triggerTags && template.triggerTags.includes(tag)
    );

    if (template.triggerTags && template.triggerTags.includes(tag)) {
      console.log(`✓ Template "${template.name}" matches tag "${tag}"`);
      await callFollowUpAPI(
        "startTemplate",
        extractedNumber,
        contactName,
        phoneIndex,
        template.templateId, // Fixed: use templateId instead of id
        idSubstring
      );
    } else {
      console.log(`✗ Template "${template.name}" does not match tag "${tag}"`);
    }
  }
  console.log("=== Completed handleFollowUpTemplateActivation ===");
}

// Get scheduled messages for a company
app.get("/api/scheduled-messages", async (req, res) => {
  const { companyId, status } = req.query;

  console.log(
    `Fetching scheduled messages for companyId: ${companyId}, status: ${
      status || "all"
    }`
  );

  // Validation
  if (!companyId) {
    console.error("Missing companyId parameter");
    return res
      .status(400)
      .json({ success: false, message: "Missing companyId parameter" });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting scheduled messages fetch"
    );
    return res
      .status(500)
      .json({ success: false, message: "Failed to fetch scheduled messages" });
  }

  try {
    await sqlClient.query("BEGIN");

    // Build the query based on status filter
    let query = `
      SELECT 
        id,
        schedule_id,
        company_id,
        contact_id,
        contact_ids,
        multiple,
        message_content,
        media_url,
        scheduled_time,
        status,
        attempt_count,
        last_attempt,
        created_at,
        sent_at,
        phone_index,
        from_me,
        active_hours_start,
        active_hours_end
      FROM scheduled_messages 
      WHERE company_id = $1
      AND id::text = schedule_id
    `;

    const queryParams = [companyId];
    let paramIndex = 2;

    // Add status filter if provided
    if (status && status !== "all") {
      let dbStatus = status;
      query += ` AND status = $${paramIndex}`;
      queryParams.push(dbStatus);
      paramIndex++;
    }

    // Order by scheduled_time (earliest first)
    query += ` ORDER BY scheduled_time ASC`;
    const { rows } = await sqlClient.query(query, queryParams);

    // Transform the data to match frontend expectations
    const messages = rows.map((row) => {
      let contactIds = null;
      if (row.contact_ids) {
        try {
          contactIds = Array.isArray(row.contact_ids)
            ? row.contact_ids
            : JSON.parse(row.contact_ids);
        } catch (e) {
          contactIds = [row.contact_ids];
        }
      }
      return {
        id: row.id,
        scheduleId: row.schedule_id,
        companyId: row.company_id,
        contactId: row.contact_id,
        contactIds: contactIds,
        multiple: row.multiple,
        messageContent: row.message_content,
        mediaUrl: row.media_url,
        scheduledTime: row.scheduled_time,
        status: row.status,
        attemptCount: row.attempt_count,
        lastAttempt: row.last_attempt,
        createdAt: row.created_at,
        sentAt: row.sent_at,
        phoneIndex: row.phone_index,
        fromMe: row.from_me,
        activeHours: row.active_hours_start && row.active_hours_end ? {
          start: row.active_hours_start,
          end: row.active_hours_end
        } : null,
      };
    });

    await sqlClient.query("COMMIT");

    res.json({
      success: true,
      messages: messages,
      count: messages.length,
    });
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error fetching scheduled messages:", error);
    console.error("Full error:", error.stack);
    res.status(500).json({
      success: false,
      message: "Failed to fetch scheduled messages",
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
  }
});

// New API: Get scheduled messages for a single contact
app.get("/api/scheduled-messages/contact", async (req, res) => {
  const { companyId, contactId, status } = req.query;

  console.log(
    `Fetching scheduled messages for companyId: ${companyId}, contactId: ${contactId}, status: ${
      status || "all"
    }`
  );

  if (!companyId || !contactId) {
    return res.status(400).json({
      success: false,
      message: "Missing companyId or contactId parameter",
    });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting scheduled messages fetch for contact"
    );
    return res.status(500).json({
      success: false,
      message: "Failed to fetch scheduled messages for contact",
    });
  }

  try {
    await sqlClient.query("BEGIN");

    let query = `
      SELECT 
        id,
        schedule_id,
        company_id,
        contact_id,
        contact_ids,
        multiple,
        message_content,
        media_url,
        scheduled_time,
        status,
        attempt_count,
        last_attempt,
        created_at,
        sent_at,
        phone_index,
        from_me,
        active_hours_start,
        active_hours_end
      FROM scheduled_messages 
      WHERE company_id = $1
      AND id::text = schedule_id
      AND (
        contact_id = $2 
        OR 
        (contact_ids IS NOT NULL AND contact_ids::jsonb ? $2)
      )
    `;
    const queryParams = [companyId, contactId];
    let paramIndex = 3;

    if (status && status !== "all") {
      query += ` AND status = $${paramIndex}`;
      queryParams.push(status);
      paramIndex++;
    }

    query += ` ORDER BY scheduled_time ASC`;
    const { rows } = await sqlClient.query(query, queryParams);

    const messages = rows.map((row) => {
      let contactIds = null;
      if (row.contact_ids) {
        try {
          contactIds = Array.isArray(row.contact_ids)
            ? row.contact_ids
            : JSON.parse(row.contact_ids);
        } catch (e) {
          contactIds = [row.contact_ids];
        }
      }
      return {
        id: row.id,
        scheduleId: row.schedule_id,
        companyId: row.company_id,
        contactId: row.contact_id,
        contactIds: contactIds,
        multiple: row.multiple,
        messageContent: row.message_content,
        mediaUrl: row.media_url,
        scheduledTime: row.scheduled_time,
        status: row.status,
        attemptCount: row.attempt_count,
        lastAttempt: row.last_attempt,
        createdAt: row.created_at,
        sentAt: row.sent_at,
        phoneIndex: row.phone_index,
        fromMe: row.from_me,
        activeHours: row.active_hours_start && row.active_hours_end ? {
          start: row.active_hours_start,
          end: row.active_hours_end
        } : null,
      };
    });

    await sqlClient.query("COMMIT");

    console.log(
      `Returning ${messages.length} main scheduled messages for contactId: ${contactId} (excluding batch entries)`
    );

    res.json({
      success: true,
      messages: messages,
      count: messages.length,
    });
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("Error fetching scheduled messages for contact:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch scheduled messages for contact",
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
  }
});

async function callFollowUpAPI(
  action,
  phone,
  contactName,
  phoneIndex,
  templateId,
  idSubstring
) {
  try {
    const response = await fetch(`${process.env.URL}/api/tag/followup`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        requestType: action,
        phone: phone,
        first_name: contactName || phone,
        phoneIndex: phoneIndex || 0,
        templateId: templateId,
        idSubstring: idSubstring,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API request failed: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    console.log(
      `Successfully completed ${action} for template ${templateId} via API`
    );
    return result;
  } catch (error) {
    console.error(`Error in callFollowUpAPI for ${action}:`, error);
    throw error;
  }
}

app.get("/api/storage-pricing", async (req, res) => {
  let client;
  try {
    client = await pool.connect();

    const companyId = "0123";
    const category = "storage";

    const query = `
      SELECT pricing_data 
      FROM pricing 
      WHERE company_id = $1 AND category = $2
      ORDER BY updated_at DESC
      LIMIT 1
    `;

    const { rows } = await client.query(query, [companyId, category]);

    if (rows.length === 0) {
      return res.status(404).json({ error: "Pricing data not found" });
    }

    const pricingData = rows[0].pricing_data;
    res.json({ success: true, data: pricingData });
  } catch (error) {
    console.error("Error fetching storage pricing:", error);
    res.status(500).json({ error: "Failed to fetch pricing data" });
  } finally {
    if (client) await safeRelease(client);
  }
});

async function handleOpenAIMyMessage(message, threadID) {
  query = `You sent this to the user: ${message}. Please remember this for the next interaction. Do not re-send this query to the user, this is only for you to remember the interaction.`;
  await addMessageAssistant(threadID, query);
}

async function addMessageAssistant(threadId, message) {
  const response = await openai.beta.threads.messages.create(threadId, {
    role: "user",
    content: message,
  });
  return response;
}

async function addMessageToPostgres(
  msg,
  idSubstring,
  extractedNumber,
  contactName,
  phoneIndex = 0,
  userName
) {
  // Validate inputs
  if (!extractedNumber || !extractedNumber.startsWith("+")) {
    console.error("Invalid extractedNumber for database:", extractedNumber);
    return;
  }

  if (!idSubstring) {
    console.error("Invalid idSubstring for database");
    return;
  }

  // Prepare contact ID
  const contactID =
    idSubstring +
    "-" +
    (extractedNumber.startsWith("+")
      ? extractedNumber.slice(1)
      : extractedNumber);

  // Extract all message data using modular functions
  const basicInfo = await extractBasicMessageInfo(msg);
  const messageData = await prepareMessageData(msg, idSubstring, phoneIndex);

  // Get message body (with audio transcription if applicable)
  let messageBody = messageData.text?.body || "";
  if (msg.hasMedia && (msg.type === "audio" || msg.type === "ptt")) {
    console.log("Voice message detected during saving to NeonDB");
    const media = await msg.downloadMedia();
    const transcription = await transcribeAudio(media.data);

    if (
      transcription &&
      transcription !== "Audio transcription failed. Please try again."
    ) {
      messageBody += transcription;
    } else {
      messageBody +=
        "I couldn't transcribe the audio. Could you please type your message instead?";
    }
  }

  // Prepare media data
  let mediaUrl = null;
  let mediaData = null;
  let mediaMetadata = {};

  if (msg.hasMedia) {
    if (msg.type === "video") {
      mediaUrl = messageData.video?.link || null;
    } else if (msg.type !== "audio" && msg.type !== "ptt") {
      const mediaTypeData = messageData[msg.type];
      if (mediaTypeData) {
        mediaData = mediaTypeData.data || null;
        mediaUrl = mediaTypeData.link || null;
        mediaMetadata = {
          mimetype: mediaTypeData.mimetype,
          filename: mediaTypeData.filename || "",
          caption: mediaTypeData.caption || "",
          thumbnail: mediaTypeData.thumbnail || null,
          mediaKey: mediaTypeData.media_key || null,
          ...(msg.type === "image" && {
            width: mediaTypeData.width,
            height: mediaTypeData.height,
          }),
          ...(msg.type === "document" && {
            pageCount: mediaTypeData.page_count,
            fileSize: mediaTypeData.file_size,
          }),
        };
      }
    } else if (msg.type === "audio" || msg.type === "ptt") {
      mediaData = messageData.audio?.data || null;
    }
  }

  // Prepare quoted message
  const quotedMessage = messageData.text?.context || null;

  // Determine author
  let author = userName;
  if (!author && msg.from.includes("@g.us") && basicInfo.author) {
    const authorData = await getContactDataFromDatabaseByPhone(
      basicInfo.author,
      idSubstring
    );
    author = authorData ? authorData.contactName : basicInfo.author;
  }

  // Database operations
  try {
    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      // Create/update contact
      const contactCheckQuery = `
        SELECT id FROM public.contacts 
        WHERE contact_id = $1 AND company_id = $2
      `;
      const contactResult = await client.query(contactCheckQuery, [
        contactID,
        idSubstring,
      ]);

      if (contactResult.rows.length === 0) {
        console.log(
          `Creating new contact: ${contactID} for company: ${idSubstring}`
        );
        const contactQuery = `
          INSERT INTO public.contacts (
            contact_id, company_id, name, contact_name, phone, email,
            thread_id, profile, points, tags, reaction, reaction_timestamp,
            last_updated, edited, edited_at, whapi_token, created_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
          ON CONFLICT (contact_id, company_id) DO UPDATE
          SET name = EXCLUDED.name,
              contact_name = EXCLUDED.contact_name,
              phone = EXCLUDED.phone,
              last_updated = EXCLUDED.last_updated
        `;
        await client.query(contactQuery, [
          contactID,
          idSubstring,
          extractedNumber,
          extractedNumber,
          extractedNumber,
          "",
          msg.from,
          {},
          0,
          [],
          null,
          null,
          new Date(),
          false,
          null,
          null,
          new Date(),
        ]);
        console.log(`Contact created successfully: ${contactID}`);
      }

      // Insert message
      const messageQuery = `
        INSERT INTO public.messages (
          message_id, company_id, contact_id, content, message_type,
          media_url, media_data, media_metadata, timestamp, direction,
          status, from_me, chat_id, author, phone_index, quoted_message,
          thread_id, customer_phone
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
        ON CONFLICT (message_id, company_id) DO NOTHING
        RETURNING id
      `;
      const messageValues = [
        basicInfo.idSerialized,
        idSubstring,
        contactID,
        messageBody,
        basicInfo.type,
        mediaUrl,
        mediaData,
        Object.keys(mediaMetadata).length > 0
          ? JSON.stringify(mediaMetadata)
          : null,
        new Date(basicInfo.timestamp * 1000),
        msg.fromMe ? "outbound" : "inbound",
        "delivered",
        msg.fromMe || false,
        msg.from,
        author || contactID,
        phoneIndex,
        quotedMessage ? JSON.stringify(quotedMessage) : null,
        msg.to,
        extractedNumber,
      ];

      await client.query(messageQuery, messageValues);

      await client.query("COMMIT");
      console.log(
        `Message successfully added to PostgreSQL with ID: ${basicInfo.idSerialized}`
      );
      return { type: basicInfo.type };
    } catch (error) {
      await safeRollback(client);
      console.error("Error in PostgreSQL transaction:", error);
      throw error;
    } finally {
      await safeRelease(client);
      let profilePicUrl = null;
      try {
        const chat = await msg.getChat();
        const contact = await chat.getContact();
        profilePicUrl = await getProfilePicUrl(contact);
        console.log("Profile picture URL:", profilePicUrl);
      } catch (error) {
        console.log("Could not get profile picture URL:", error.message);
      }
      await addNotificationToUser(
        idSubstring,
        messageBody,
        contactName,
        contactID,
        msg.from,
        extractedNumber,
        profilePicUrl
      );
    }
  } catch (error) {
    console.error("PostgreSQL connection error:", error);
    throw error;
  }
}

async function addNotificationToUser(
  companyId,
  message,
  contactName,
  contactId = null,
  chatId = null,
  phoneNumber = null,
  profilePicUrl = null
) {
  console.log(`[BOT ${companyId}] Adding notification and sending OneSignal`);
  try {
    const client = await pool.connect();

    try {
      const usersQuery = await client.query(
        "SELECT user_id, email FROM public.users WHERE company_id = $1",
        [companyId]
      );

      if (usersQuery.rows.length === 0) {
        console.log("No matching users found during notification addition.");
        return;
      }

      // Fix: Handle both string and object message types
      let cleanMessage;
      if (typeof message === "string") {
        cleanMessage = { text: { body: message }, type: "text" };
      } else if (message && typeof message === "object") {
        cleanMessage = Object.fromEntries(
          Object.entries(message).filter(([_, value]) => value !== undefined)
        );
      } else {
        cleanMessage = { text: { body: "New message received" }, type: "text" };
      }

      let notificationText = cleanMessage.text?.body || "New message received";
      if (cleanMessage.hasMedia) {
        notificationText = `Media: ${cleanMessage.type || "attachment"}`;
      }

      // Send OneSignal notification to all users in the company
      try {
        // Determine notification type based on context
        let notificationType = "company_announcement";
        let additionalData = {
          company_id: companyId,
        };

        if (contactName && contactId && chatId) {
          // This is an actual message from a contact
          notificationType = "message";
          additionalData = {
            ...additionalData,
            message_type: cleanMessage.type || "message",
            has_media: cleanMessage.hasMedia || false,
            contact_name: contactName,
            contact_id: contactId,
            chat_id: chatId,
            phone: phoneNumber,
            profile_pic_url: profilePicUrl,
            type: notificationType,
          };
        } else {
          // This is a company announcement
          additionalData = {
            ...additionalData,
            type: notificationType,
          };
        }
      } catch (onesignalError) {
        console.error("Failed to send OneSignal notification:", onesignalError);
        // Continue with database operations even if OneSignal fails
      }

      const promises = usersQuery.rows.map(async (user) => {
        const userId = user.user_id;

        await client.query(
          `INSERT INTO public.notifications (
            company_id, user_id, title, message, type, read, message_data, created_at
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, CURRENT_TIMESTAMP)`,
          [
            companyId,
            userId,
            contactName,
            notificationText,
            cleanMessage.type || "message",
            false,
            JSON.stringify(cleanMessage),
          ]
        );
      });

      await Promise.all(promises);
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error adding notification or sending OneSignal: ", error);
  }
}

async function extractBasicMessageInfo(msg) {
  return {
    id: msg.id ?? "",
    idSerialized: msg.id._serialized ?? "",
    from: msg.from ?? "",
    fromMe: msg.fromMe ?? false,
    body: msg.body ?? "",
    timestamp: msg.timestamp ?? 0,
    type: msg.type === "chat" ? "text" : msg.type,
    deviceType: msg.deviceType ?? "",
    notifyName: msg.notifyName ?? "",
    chatId: msg.from,
    author: msg.author ? "+" + msg.author.split("@")[0] : null,
  };
}

async function processMessageMedia(msg) {
  if (!msg.hasMedia || msg.type === "audio" || msg.type === "ptt") {
    return null;
  }

  try {
    const media = await msg.downloadMedia();
    if (!media) {
      console.log(
        `Failed to download media for message: ${msg.id._serialized}`
      );
      return null;
    }

    const fileSizeBytes = Math.floor((media.data.length * 3) / 4);
    const fileSizeMB = fileSizeBytes / (1024 * 1024);
    const FILE_SIZE_LIMIT_MB = 5;

    const mediaData = {
      mimetype: media.mimetype,
      data: media.data,
      filename: msg._data.filename || media.filename || "",
      caption: msg._data.caption || media.caption || "",
    };

    switch (msg.type) {
      case "image":
        mediaData.width = msg._data.width;
        mediaData.height = msg._data.height;
        if (fileSizeMB > FILE_SIZE_LIMIT_MB) {
          mediaData.link = await storeMediaData(
            media.data,
            mediaData.filename,
            media.mimetype
          );
          delete mediaData.data;
        }
        break;
      case "document":
        mediaData.page_count = msg._data.pageCount;
        mediaData.file_size = msg._data.size;
        if (fileSizeMB > FILE_SIZE_LIMIT_MB) {
          mediaData.link = await storeMediaData(
            media.data,
            mediaData.filename,
            media.mimetype
          );
          delete mediaData.data;
        }
        break;
      case "video":
        mediaData.link = await storeMediaData(
          media.data,
          mediaData.filename,
          media.mimetype
        );
        delete mediaData.data;
        break;
      default:
        if (fileSizeMB > FILE_SIZE_LIMIT_MB) {
          mediaData.link = await storeMediaData(
            media.data,
            mediaData.filename,
            media.mimetype
          );
          delete mediaData.data;
        } else {
          mediaData.link = null;
        }
        break;
    }

    if (msg._data.thumbnailHeight && msg._data.thumbnailWidth) {
      mediaData.thumbnail = {
        height: msg._data.thumbnailHeight,
        width: msg._data.thumbnailWidth,
      };
    }

    if (msg.mediaKey) {
      mediaData.media_key = msg.mediaKey;
    }

    return mediaData;
  } catch (error) {
    console.error(
      `Error handling media for message ${msg.id._serialized}:`,
      error
    );
    return null;
  }
}

async function processAudioMessage(msg) {
  if (msg.type !== "audio" && msg.type !== "ptt") {
    return null;
  }

  const media = await msg.downloadMedia();

  return {
    mimetype: "audio/ogg; codecs=opus",
    data: media.data,
  };
}

async function processLocationMessage(msg) {
  if (msg.type !== "location") {
    return null;
  }

  return {
    latitude: msg.location.latitude,
    longitude: msg.location.longitude,
    description: msg.location.description || "",
    timestamp: new Date(),
  };
}

async function processQuotedMessage(msg, idSubstring, client = null) {
  if (!msg.hasQuotedMsg) {
    return null;
  }

  const quotedMsg = await msg.getQuotedMessage();

  // Handle @lid case for quoted messages
  let authorNumber;
  if (quotedMsg.from && quotedMsg.from.includes("@lid")) {
    console.log("🔧 [processQuotedMessage] @lid detected in quoted message");
    if (client) {
      try {
        // For quoted messages, we might not be able to get the chat/contact directly
        // Try to extract from the quoted message's from field pattern
        authorNumber = "+" + quotedMsg.from.split("@")[0];
        console.log(
          "✅ [processQuotedMessage] Extracted quoted author (fallback):",
          authorNumber
        );
      } catch (error) {
        console.error(
          "❌ [processQuotedMessage] Error extracting quoted author:",
          error
        );
        authorNumber = quotedMsg.from; // Use as-is as fallback
      }
    } else {
      authorNumber = quotedMsg.from; // Use as-is as fallback
    }
  } else {
    authorNumber = "+" + quotedMsg.from.split("@")[0];
  }

  const authorData = await getContactDataFromDatabaseByPhone(
    authorNumber,
    idSubstring
  );
  let authorName = authorData ? authorData.contactName : authorNumber;
  if (quotedMsg.fromMe) {
    authorName = "Me";
  }

  return {
    quoted_content: {
      body: quotedMsg.body,
    },
    quoted_author: authorName,
    message_id: quotedMsg.id._serialized,
    message_type: quotedMsg.type,
  };
}

async function processOrderMessage(msg) {
  if (msg.type !== "order") {
    return null;
  }

  return {
    order_id: msg?.orderId,
    token: msg?.token,
    seller_jid: msg?._data?.sellerJid,
    item_count: msg?._data?.itemCount,
    order_title: msg?._data?.orderTitle,
    total_amount: msg?._data?.totalAmount1000,
    total_currency_code: msg?._data?.totalCurrencyCode,
    thumbnail: msg?._data?.thumbnail,
  };
}

async function prepareMessageData(msg, idSubstring, phoneIndex) {
  const basicInfo = await extractBasicMessageInfo(msg);

  const messageData = {
    chat_id: basicInfo.chatId,
    from: basicInfo.from,
    from_me: basicInfo.fromMe,
    id: basicInfo.id,
    source: basicInfo.deviceType,
    status: "delivered",
    text: {
      body: basicInfo.body,
    },
    timestamp: basicInfo.timestamp,
    type: basicInfo.type,
    phone_index: phoneIndex,
  };

  // Process media if present
  if (msg.hasMedia) {
    const mediaData = await processMessageMedia(msg);
    if (mediaData) {
      messageData[msg.type] = mediaData;
    }
  }

  // Process audio separately
  const audioData = await processAudioMessage(msg);
  if (audioData) {
    messageData.audio = audioData;
  }

  // Process location
  const locationData = await processLocationMessage(msg);
  if (locationData) {
    messageData.location = locationData;
  }

  // Process quoted message
  const quotedData = await processQuotedMessage(msg, idSubstring);
  if (quotedData) {
    messageData.text.context = quotedData;
  }

  // Process order message
  const orderData = await processOrderMessage(msg);
  if (orderData) {
    messageData.order = orderData;
  }

  // Handle group messages
  if (basicInfo.from.includes("@g.us") && basicInfo.author) {
    const authorData = await getContactDataFromDatabaseByPhone(
      basicInfo.author,
      idSubstring
    );
    messageData.author = authorData ? authorData.name : basicInfo.author;
  }

  return messageData;
}

async function transcribeAudio(audioData) {
  try {
    const formData = new FormData();
    formData.append("file", Buffer.from(audioData, "base64"), {
      filename: "audio.ogg",
      contentType: "audio/ogg",
    });
    formData.append("model", "whisper-1");
    formData.append("response_format", "json");

    const response = await axios.post(
      "https://api.openai.com/v1/audio/transcriptions",
      formData,
      {
        headers: {
          ...formData.getHeaders(),
          Authorization: `Bearer ${process.env.OPENAIKEY}`,
        },
      }
    );

    return response.data.text;
  } catch (error) {
    console.error("Error transcribing audio:", error);
    return "";
  }
}

async function storeMediaData(mediaData, filename, mimeType) {
  try {
    const buffer = Buffer.from(mediaData, "base64");
    const stream = Readable.from(buffer);

    // Try to determine mimeType and extension if not provided
    if (!mimeType) {
      // Try to guess from filename
      if (filename) {
        mimeType = mime.lookup(filename) || "application/octet-stream";
      } else {
        mimeType = "application/octet-stream";
      }
    }

    // If filename is missing or has no extension, generate one from mimeType
    if (!filename || !filename.includes(".")) {
      const ext = mime.extension(mimeType) || "bin";
      filename = `document-${Date.now()}.${ext}`;
    }

    const formData = new FormData();
    formData.append("file", stream, {
      filename: filename,
      contentType: mimeType,
      knownLength: buffer.length,
    });

    const response = await axios.post(
      `${process.env.URL}/api/upload-media`,
      formData,
      {
        headers: formData.getHeaders(),
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
      }
    );

    return response.data.url;
  } catch (error) {
    console.error("Error uploading document:", error);
    throw error;
  }
}

app.delete("/api/auth/user", async (req, res) => {
  const { email } = req.body;

  if (!email) {
    return res.status(400).json({ error: "Email is required in request body" });
  }

  try {
    // Get the user by email
    const userRecord = await admin.auth().getUserByEmail(email);

    // Delete the user
    await admin.auth().deleteUser(userRecord.uid);

    // Also delete the user's data from Firestore if needed
    await db.collection("user").doc(email).delete();

    // console.log(`Successfully deleted user with email: ${email}`);
    res.json({ success: true, message: "User deleted successfully" });
  } catch (error) {
    console.error("Error deleting user:", error);

    if (error.code === "auth/user-not-found") {
      return res.status(404).json({ error: "User not found" });
    }

    res.status(500).json({
      error: "Failed to delete user",
      code: error.code,
      message: error.message,
    });
  }
});

async function saveContactWithRateLimit(
  botName,
  contact,
  chat,
  phoneIndex,
  retryCount = 0
) {
  try {
    let phoneNumber = contact.number;
    let contactID = contact.id._serialized;
    const msg = chat.lastMessage || {};
    if (Object.keys(msg).length === 0) {
      return; // Skip if there's no last message
    }

    let idsuffix = chat.isGroup ? "@g.us" : "@c.us";
    if (chat.isGroup) {
      phoneNumber = contactID.split("@")[0];
    }

    if (contactID === "0@c.us" || phoneNumber === "status") {
      return; // Skip system contacts
    }

    const extractedNumber = "+" + contactID.split("@")[0];
    //console.log(`Saving contact: ${extractedNumber} with contactID: ${contactID}`);

    // Fetch existing contact data
    const existingContact = await getContactDataFromDatabaseByPhone(
      extractedNumber,
      botName
    );
    let tags = existingContact?.tags || ["stop bot"];

    let type =
      msg.type === "chat"
        ? "text"
        : msg.type === "e2e_notification" ||
          msg.type === "notification_template"
        ? null
        : msg.type;

    if (!type) return; // Skip if message type is not valid

    const contactData = {
      additionalEmails: [],
      address1: null,
      assignedTo: null,
      businessId: null,
      phone: extractedNumber,
      tags: tags,
      chat: {
        contact_id: "+" + phoneNumber,
        id: contactID || contact.id.user + idsuffix,
        name: contact.name || contact.pushname || chat.name || phoneNumber,
        not_spam: true,
        tags: tags,
        timestamp: chat.timestamp || Date.now(),
        type: "contact",
        unreadCount: chat.unreadCount || 0,
        last_message: {
          chat_id: contact.id.user + idsuffix,
          from: msg.from || contact.id.user + idsuffix,
          from_me: msg.fromMe || false,
          id: msg._data?.id?.id || "",
          source: chat.deviceType || "",
          status: "delivered",
          text: {
            body: msg.body || "",
          },
          timestamp: chat.timestamp || Date.now(),
          type: type,
        },
      },
      chat_id: contact.id.user + idsuffix,
      city: null,
      companyName: null,
      contactName: contact.name || contact.pushname || chat.name || phoneNumber,
      unreadCount: chat.unreadCount || 0,
      threadid: "",
      phoneIndex: phoneIndex,
      last_message: {
        chat_id: contact.id.user + idsuffix,
        from: msg.from || contact.id.user + idsuffix,
        from_me: msg.fromMe || false,
        id: msg._data?.id?.id || "",
        source: chat.deviceType || "",
        status: "delivered",
        text: {
          body: msg.body || "",
        },
        timestamp: chat.timestamp || Date.now(),
        type: type,
      },
    };

    // Fetch profile picture URL
    try {
      contactData.profilePicUrl = (await getProfilePicUrl(contact)) || "";
    } catch (error) {
      console.error(
        `Error getting profile picture URL for ${contact.id.user}:`,
        error
      );
      contactData.profilePicUrl = "";
    }

    // Save contact data
    const contactRef = db
      .collection("companies")
      .doc(botName)
      .collection("contacts")
      .doc(extractedNumber);
    await contactRef.set(contactData, { merge: true });

    // Fetch and save messages
    const messages = await chat.fetchMessages({ limit: 20 });
    if (messages && messages.length > 0) {
      // console.log("SAVING MESSAGES")
      await saveMessages(botName, extractedNumber, messages, chat.isGroup);
    }

    // console.log(`Successfully saved contact ${extractedNumber} for bot ${botName}`);
  } catch (error) {
    console.error(`Error saving contact for bot ${botName}:`, error);
    if (retryCount < 3) {
      // console.log(`Retrying... (Attempt ${retryCount + 1})`);
      await new Promise((resolve) => setTimeout(resolve, 1000(retryCount + 1)));
      await saveContactWithRateLimit(
        botName,
        contact,
        chat,
        phoneIndex,
        retryCount + 1
      );
    } else {
      //console.error(`Failed to save contact after 3 attempts`);
    }
  }
}

async function saveMessages(botName, phoneNumber, messages, isGroup) {
  const contactRef = db
    .collection("companies")
    .doc(botName)
    .collection("contacts")
    .doc(phoneNumber);
  const messagesRef = contactRef.collection("messages");
  const sortedMessages = messages.sort(
    (a, b) => (a.timestamp || 0) - (b.timestamp || 0)
  );

  let batch = db.batch();
  let count = 0;

  for (const message of sortedMessages) {
    const type = message.type === "chat" ? "text" : message.type;

    const messageData = {
      chat_id: message.from,
      from: message.from ?? "",
      from_me: message.fromMe ?? false,
      id: message.id._serialized ?? "",
      source: message.deviceType ?? "",
      status: "delivered",
      timestamp: message.timestamp ?? 0,
      type: type,
      ack: message.ack ?? 0,
    };

    if (isGroup && message.author) {
      messageData.author = message.author;
    }

    // Handle different message types
    if (type === "text") {
      messageData.text = { body: message.body ?? "" };
    } else if (
      ["image", "video", "document"].includes(type) &&
      message.hasMedia
    ) {
      try {
        const media = await message.downloadMedia();
        if (media) {
          const url = await saveMediaLocally(
            media.data,
            media.mimetype,
            media.filename || `${type}.${media.mimetype.split("/")[1]}`
          );
          messageData[type] = {
            mimetype: media.mimetype,
            url: url,
            filename: media.filename ?? "",
            caption: message.body ?? "",
          };
          if (type === "image") {
            messageData[type].width = message._data.width;
            messageData[type].height = message._data.height;
          }
        } else {
          messageData.text = { body: "Media not available" };
        }
      } catch (error) {
        console.error(
          `Error handling media for message ${message.id._serialized}:`,
          error
        );
        messageData.text = { body: "Error handling media" };
      }
    } else {
      messageData.text = { body: message.body ?? "" };
    }

    const messageDoc = messagesRef.doc(message.id._serialized);
    batch.set(messageDoc, messageData, { merge: true });

    count++;
    if (count >= 500) {
      await batch.commit();
      batch = db.batch();
      count = 0;
    }

    broadcastProgress(
      botName,
      "saving_messages",
      count / sortedMessages.length
    );
  }

  if (count > 0) {
    await batch.commit();
  }

  // console.log(`Saved ${sortedMessages.length} messages for contact ${phoneNumber}`);
  broadcastProgress(botName, "saving_messages", 1);
}

const delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// ... existing code ...

// Enhanced database connection with better error handling
async function getContactDataFromDatabaseByPhone(phoneNumber, idSubstring) {
  const maxRetries = 3;
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      if (!phoneNumber) {
        throw new Error("Phone number is undefined or null");
      }

      // Use direct SQL query with timeout
      const result = await Promise.race([
        sql`
          SELECT * FROM public.contacts
          WHERE phone = ${phoneNumber} AND company_id = ${idSubstring}
          LIMIT 1
        `,
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error("Database query timeout")), 10000)
        ),
      ]);

      if (result.length === 0) {
        return null;
      } else {
        const contactData = result[0];
        const contactName = contactData.name || contactData.contact_name;
        const threadID = contactData.thread_id;

        return {
          ...contactData,
          contactName,
          threadID,
        };
      }
    } catch (error) {
      lastError = error;
      console.error(
        `Database attempt ${attempt}/${maxRetries} failed:`,
        error.message
      );

      if (attempt < maxRetries) {
        // Wait before retry with exponential backoff
        await new Promise((resolve) =>
          setTimeout(resolve, Math.pow(2, attempt) * 1000)
        );
      }
    }
  }

  // If all retries failed, log the error but don't throw
  console.error("All database retry attempts failed:", lastError);
  return null; // Return null instead of throwing
}

setInterval(() => {
  console.log("Pool status:", {
    total: pool.totalCount,
    idle: pool.idleCount,
    waiting: pool.waitingCount,
  });
}, 120000);

async function processChats(client, botName, phoneIndex) {
  try {
    const chats = await client.getChats();
    const totalChats = chats.length;
    let processedChats = 0;

    for (const chat of chats) {
      if (chat.isGroup) {
        processedChats++;
        continue;
      }
      const contact = await chat.getContact();
      await saveContactWithRateLimit(botName, contact, chat, phoneIndex);
      processedChats++;

      broadcastProgress(
        botName,
        "processing_chats",
        processedChats / totalChats,
        phoneIndex
      );
    }
    console.log(
      `Finished saving contacts for bot ${botName} Phone ${phoneIndex + 1}`
    );
  } catch (error) {
    // console.error(`Error processing chats for bot ${botName} Phone ${phoneIndex + 1}:`, error);
  }
}

app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;
  console.log("Login attempt:", { email }); // Removed password logging for security

  try {
    // Get user data from database
    const userData = await sqlDb.getRow(
      "SELECT * FROM users WHERE email = $1 AND password = $2",
      [email, password]
    );

    if (!userData) {
      console.log("Invalid credentials for email:", email);
      return res.status(401).json({ error: "Invalid email or password" });
    }

    // Success
    console.log("Login successful for:", email);
    res.json({
      success: true,
      user: {
        email: userData.email,
        name: userData.name,
        role: userData.role,
      },
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// List all tags for a company
app.get("/api/companies/:companyId/tags", async (req, res) => {
  const { companyId } = req.params;
  try {
    const result = await sqlDb.query(
      "SELECT id, name FROM company_tags WHERE company_id = $1 ORDER BY name ASC",
      [companyId]
    );
    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching tags:", error);
    res.status(500).json({ error: "Failed to fetch tags" });
  }
});

// Add a new tag for a company
app.post("/api/companies/:companyId/tags", async (req, res) => {
  const { companyId } = req.params;
  const { name } = req.body;
  if (!name) return res.status(400).json({ error: "Tag name is required" });
  try {
    const result = await sqlDb.query(
      "INSERT INTO company_tags (company_id, name) VALUES ($1, $2) RETURNING id, name",
      [companyId, name]
    );
    res.json(result.rows[0]);
  } catch (error) {
    if (error.code === "23505") {
      // unique_violation
      return res.status(409).json({ error: "Tag already exists" });
    }
    console.error("Error adding tag:", error);
    res.status(500).json({ error: "Failed to add tag" });
  }
});

// Update a tag's name
app.put("/api/companies/:companyId/tags/:tagId", async (req, res) => {
  const { companyId, tagId } = req.params;
  const { name } = req.body;
  if (!name) return res.status(400).json({ error: "Tag name is required" });
  try {
    const result = await sqlDb.query(
      "UPDATE company_tags SET name = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2 AND company_id = $3 RETURNING id, name",
      [name, tagId, companyId]
    );
    if (result.rows.length === 0)
      return res.status(404).json({ error: "Tag not found" });
    res.json(result.rows[0]);
  } catch (error) {
    if (error.code === "23505") {
      // unique_violation
      return res.status(409).json({ error: "Tag already exists" });
    }
    console.error("Error updating tag:", error);
    res.status(500).json({ error: "Failed to update tag" });
  }
});

// Delete a tag
app.delete("/api/companies/:companyId/tags/:tagId", async (req, res) => {
  const { companyId, tagId } = req.params;
  try {
    const result = await sqlDb.query(
      "DELETE FROM company_tags WHERE id = $1 AND company_id = $2 RETURNING id",
      [tagId, companyId]
    );
    if (result.rows.length === 0)
      return res.status(404).json({ error: "Tag not found" });
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting tag:", error);
    res.status(500).json({ error: "Failed to delete tag" });
  }
});

// Get user config
app.get("/api/user/config", async (req, res) => {
  try {
    const userEmail = req.query.email; // Changed from req.body to req.query
    const user = await sqlDb.getRow("SELECT * FROM users WHERE email = $1", [
      userEmail,
    ]);

    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }
    console.log("User object:", user);
    console.log("User selected_phone:", user.selected_phone);

    res.json({
      name: user.name,
      company_id: user.company_id,
      role: user.role,
      email: user.email,
      phone: user.selected_phone,
    });
  } catch (error) {
    console.error("Error fetching user config:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Get company data
app.get("/api/companies/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const company = await sqlDb.getRow(
      "SELECT * FROM companies WHERE company_id = $1",
      [companyId]
    );

    if (!company) {
      return res.status(404).json({ error: "Company not found" });
    }

    // Convert snake_case to camelCase
    const toCamel = (str) =>
      str.replace(/_([a-z])/g, (g) => g[1].toUpperCase());

    const camelCompany = {};
    for (const key in company) {
      camelCompany[toCamel(key)] = company[key];
    }

    res.json(camelCompany);
  } catch (error) {
    console.error("Error fetching company data:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Get contacts with replies
app.get("/api/companies/:companyId/replies", async (req, res) => {
  try {
    const { companyId } = req.params;

    // SQL query to count contacts with replies
    const result = await sqlDb.getRow(
      `
      SELECT COUNT(DISTINCT c.id) as contacts_with_replies
      FROM contacts c
      LEFT JOIN messages m ON c.id = m.contact_id
      WHERE c.company_id = $1 
      AND c.type != 'group'
      AND m.id IS NOT NULL
    `,
      [companyId]
    );

    res.json({
      contactsWithReplies: parseInt(result.contacts_with_replies) || 0,
    });
  } catch (error) {
    console.error("Error fetching replies data:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/api/companies/:companyId/contacts/multi-phone", async (req, res) => {
  try {
    const { email, phoneIndex } = req.query;
    const { companyId } = req.params;

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    if (phoneIndex === undefined || phoneIndex === null) {
      return res.status(400).json({ error: "phoneIndex is required" });
    }

    // Get user email from session
    const userEmail = email;

    // Verify user belongs to company
    const userData = await sqlDb.getRow(
      "SELECT role, name FROM users WHERE email = $1 AND company_id = $2 AND active = true",
      [userEmail, companyId]
    );

    if (!userData) {
      return res
        .status(403)
        .json({ error: "Forbidden - User not authorized for this company" });
    }

    // Fetch contacts with their latest message for the specific phone_index
    const contacts = await sqlDb.getRows(
      `
      SELECT 
        c.id,
        c.contact_id,
        c.name,
        c.contact_name,
        c.phone,
        c.email,
        c.chat_id,
        c.profile,
        c.profile_pic_url,
        c.tags,
        c.created_at,
        c.last_updated,
        c.phone_indexes,
        c.unread_count,
        c.custom_fields,
        CASE 
          WHEN c.chat_id LIKE '%@c.us' THEN true 
          ELSE false 
        END as is_individual,
        (
          SELECT jsonb_agg(e.name)
          FROM assignments a
          JOIN employees e ON a.employee_id = e.employee_id
          WHERE a.contact_id = c.contact_id 
          AND a.company_id = c.company_id
          AND a.status = 'active'
        ) as assigned_to,
        (
          SELECT jsonb_build_object(
            'chat_id', m.chat_id,
            'from', m.chat_id,
            'from_me', m.from_me,
            'id', m.message_id,
            'source', '',
            'status', m.status,
            'text', jsonb_build_object('body', m.content),
            'timestamp', EXTRACT(EPOCH FROM m.timestamp)::bigint,
            'type', m.message_type,
            'name', m.author,
            'phone_index', m.phone_index
          )
          FROM messages m
          WHERE m.contact_id = c.contact_id
          AND m.company_id = c.company_id
          AND m.phone_index = $2
          ORDER BY m.timestamp DESC
          LIMIT 1
        ) as last_message,
        (
          SELECT m.phone_index
          FROM messages m
          WHERE m.contact_id = c.contact_id
          AND m.company_id = c.company_id
          AND m.phone_index = $2
          ORDER BY m.timestamp DESC
          LIMIT 1
        ) as phoneIndex
      FROM contacts c
      WHERE c.company_id = $1
      AND EXISTS (
        SELECT 1 FROM messages m2 
        WHERE m2.contact_id = c.contact_id 
        AND m2.company_id = c.company_id 
        AND m2.phone_index = $2
      )
      ORDER BY (
        SELECT m.timestamp
        FROM messages m
        WHERE m.contact_id = c.contact_id
        AND m.company_id = c.company_id
        AND m.phone_index = $2
        ORDER BY m.timestamp DESC
        LIMIT 1
      ) DESC NULLS LAST
    `,
      [companyId, phoneIndex]
    );

    // Process contacts to match frontend expectations
    const processedContacts = contacts.map((contact) => {
      // Parse tags from JSONB if they are a string, or use empty array if null/undefined
      let tags = contact.tags;
      try {
        if (typeof tags === "string") {
          tags = JSON.parse(tags);
        }
        // Ensure tags is an array and filter out empty values
        tags = Array.isArray(tags) ? tags.filter((tag) => tag) : [];
      } catch (error) {
        console.error("Error parsing tags:", error);
        tags = [];
      }

      // Parse phone_indexes from JSONB if they are a string, or use empty array if null/undefined
      let phoneIndexes = contact.phone_indexes;
      try {
        if (typeof phoneIndexes === "string") {
          phoneIndexes = JSON.parse(phoneIndexes);
        }
        phoneIndexes = Array.isArray(phoneIndexes)
          ? phoneIndexes.filter((v) => v !== undefined && v !== null)
          : [];
      } catch (error) {
        console.error("Error parsing phone_indexes:", error);
        phoneIndexes = [];
      }

      // Parse assigned_to from JSONB if it exists
      let assignedTo = contact.assigned_to;
      try {
        if (typeof assignedTo === "string") {
          assignedTo = JSON.parse(assignedTo);
        }
        // Ensure assignedTo is an array
        assignedTo = Array.isArray(assignedTo) ? assignedTo : [];
      } catch (error) {
        console.error("Error parsing assigned_to:", error);
        assignedTo = [];
      }

      return {
        id: contact.id,
        contact_id: contact.contact_id,
        name: contact.name || contact.contact_name || "",
        phone: contact.phone || "",
        email: contact.email || "",
        chat_id: contact.chat_id || "",
        profileUrl: contact.profile_pic_url || "",
        profile: contact.profile || {},
        tags: tags,
        phoneIndexes: phoneIndexes,
        phoneIndex: parseInt(phoneIndex), // Current phone index for this contact's latest message
        assignedTo: assignedTo,
        createdAt: contact.created_at,
        lastUpdated: contact.last_updated,
        isIndividual: contact.is_individual,
        last_message: contact.last_message || null,
        unreadCount: contact.unread_count || 0,
        customFields: contact.custom_fields || {},
      };
    });

    // Filter contacts based on user role
    const filteredContacts = filterContactsByUserRole(
      processedContacts,
      userData.role,
      userData.name
    );

    res.json({
      success: true,
      total: filteredContacts.length,
      contacts: filteredContacts,
      phoneIndex: parseInt(phoneIndex),
    });
  } catch (error) {
    console.error("Error fetching multi-phone contacts:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch contacts",
      message: error.message,
    });
  }
});

async function obiliterateAllJobs() {
  try {
    console.log("Starting obliterate of all queues...");

    // Clear the global message queue if present
    try {
      await messageQueue.obliterate({ force: true });
      console.log("Global messageQueue obliterated");
    } catch (err) {
      console.error("Error obliterating global messageQueue:", err);
    }

    // Clear per-bot queues and stop workers gracefully
    for (const [botId, queue] of botQueues.entries()) {
      try {
        const worker = botWorkers.get(botId);
        if (worker) {
          try {
            await worker.close();
            console.log(`Worker closed for bot ${botId}`);
          } catch (werr) {
            console.error(`Error closing worker for bot ${botId}:`, werr);
          }
        }

        try {
          await queue.obliterate({ force: true });
          console.log(`Queue obliterated for bot ${botId}`);
        } catch (qerr) {
          console.error(`Error obliterating queue for bot ${botId}:`, qerr);
        }
      } catch (err) {
        console.error(`Error during cleanup for bot ${botId}:`, err);
      }
    }

    console.log("All queues cleared successfully");
  } catch (error) {
    console.error("Error in obiliterateAllJobs:", error);
  }
}

async function main(reinitialize = false) {
  console.log("Initialization starting...");

  // 1. Fetch companies in parallel with other initialization tasks
  // const companiesPromise = sqlDb.query(
  //   "SELECT * FROM companies WHERE company_id = $1",
  //   ["0145"]
  // );
  // const companiesPromise = sqlDb.query(
  //   "SELECT * FROM companies WHERE company_id = $1",
  //   ["0150"]
  // );

  // WHEN WANT TO INITIALIZE ALL BOTS
  // const companiesPromise = sqlDb.query(
  //   "SELECT * FROM companies WHERE api_url = $1",
  //   ["https://bisnesgpt.jutateknologi.com"]
  // );
  //const companyIds = ['0145'];
  const companyIds = [
    "0101",
    "0107",
    '128137',
    "0149",
    "0156",
    "0160",
    "0161",
    "0210",
    "621275",
    "0245",
    "0342",
    "0377",
    "049815",
    "058666",
    "063",
    "079",
    "088",
    "092",
    "296245",
    "325117",
    "399849",
    '920072',
    "458752",
    "728219",
    "765943",
    "621275",
    "946386",
    "wellness_unlimited",
    'premium_pure',
  ];
  const placeholders = companyIds.map((_, i) => `$${i + 1}`).join(", ");
  const query = `SELECT * FROM companies WHERE company_id IN (${placeholders})`;
  const companiesPromise = sqlDb.query(query, companyIds);

  // 2. If reinitializing, start cleanup early
  const cleanupPromise = reinitialize
    ? (async () => {
        console.log("Reinitializing, clearing existing bot instances...");
        await Promise.all(
          [...botMap.entries()].map(async ([_, botData]) => {
            if (Array.isArray(botData)) {
              await Promise.all(
                botData.map(async (clientData) => {
                  if (clientData.client) await clientData.client.destroy();
                })
              );
            } else if (botData?.client) {
              await botData.client.destroy();
            }
          })
        );
        botMap.clear();
      })()
    : Promise.resolve();

  // 3. Start job cleanup in parallel
  const jobCleanupPromise = obiliterateAllJobs();

  // 4. Wait for initial setup tasks
  const [companiesResult] = await Promise.all([
    companiesPromise,
    cleanupPromise,
    jobCleanupPromise,
  ]);

  // 5. Process company data and sort naturally
  const botConfigs = companiesResult.rows
    .map((row) => {
      const phoneNumbers = row.phone_numbers || [];
      const phoneCount = row.phone_count || phoneNumbers.length || 0;

      return {
        botName: row.company_id,
        phoneCount: phoneCount,
      };
    })
    // Add natural sorting for botName
    .sort((a, b) => {
      // Convert botNames to numbers if possible for proper numeric sorting
      const aNum = parseFloat(a.botName);
      const bNum = parseFloat(b.botName);

      if (!isNaN(aNum) && !isNaN(bNum)) {
        return aNum - bNum;
      }
      // Fallback to string comparison if not numbers
      return a.botName.localeCompare(b.botName, undefined, {
        numeric: true,
        sensitivity: "base",
      });
    });

  console.log(
    `Found ${botConfigs.length} bots to initialize (excluding EC2 instances)`
  );

  // 6. Initialize bots in sequential clusters
  const initializeBotsWithDelay = async (botConfigs) => {
    if (!botConfigs || botConfigs.length === 0) {
      console.log("No bot configurations found");
      return;
    }

    const MAX_CONCURRENT = 10;
    const BOT_TIMEOUT = 120000;
    const RETRY_DELAY = 5000;
    const MAX_RETRIES = 3;
    const STATUS_CHECK_INTERVAL = 10000;

    // Create individual phone tasks from all bot configurations
    const createPhoneTasks = (configs) => {
      const phoneTasks = [];

      configs.forEach((config) => {
        const phoneCount = config.phoneCount || 1;
        for (let phoneIndex = 0; phoneIndex < phoneCount; phoneIndex++) {
          phoneTasks.push({
            botName: config.botName,
            phoneIndex: phoneIndex,
            totalPhones: phoneCount,
            isLastPhone: phoneIndex === phoneCount - 1,
            originalConfig: config,
          });
        }
      });

      return phoneTasks;
    };

    const allPhoneTasks = createPhoneTasks(botConfigs);
    console.log(
      `Starting phone-based initialization: ${allPhoneTasks.length} total phones from ${botConfigs.length} bots with max ${MAX_CONCURRENT} concurrent phone initializations...`
    );

    // Group phone tasks by company for tracking
    const phoneTasksByBot = {};
    allPhoneTasks.forEach((task) => {
      if (!phoneTasksByBot[task.botName]) {
        phoneTasksByBot[task.botName] = [];
      }
      phoneTasksByBot[task.botName].push(task);
    }); // Function to initialize mtdcSpreadsheet when bot 0380 is ready

    // Enhanced function to get bot status from multiple sources
    const getBotStatus = async (botName) => {
      try {
        // Check botMap first
        const botData = botMap.get(botName);
        if (botData && Array.isArray(botData)) {
          const statuses = botData.map((phone) => phone?.status || "unknown");
          const validStatuses = statuses.filter((s) => s && s !== "unknown");

          // Count status occurrences
          const statusCounts = {
            ready: statuses.filter((s) => s === "ready").length,
            qr: statuses.filter((s) => s === "qr").length,
            authenticated: statuses.filter((s) => s === "authenticated").length,
            initializing: statuses.filter((s) => s === "initializing").length,
            error: statuses.filter((s) => s === "error").length,
            disconnected: statuses.filter((s) => s === "disconnected").length,
            unknown: statuses.filter((s) => !s || s === "unknown").length,
          };

          const totalPhones = botData.length;
          const finalStatePhones = statusCounts.ready + statusCounts.qr; // End states
          const processingPhones =
            statusCounts.initializing + statusCounts.authenticated; // Still processing

          console.log(
            `📊 Bot ${botName} phones: ${statusCounts.ready}R/${statusCounts.qr}Q/${statusCounts.authenticated}A/${statusCounts.initializing}I (${finalStatePhones}/${totalPhones} in final state)`
          );

          // Wait for ALL phones to reach final states (ready or qr)
          if (finalStatePhones === totalPhones) {
            // All phones are in final states
            if (statusCounts.ready > 0) {
              // Has at least one ready phone - can proceed with post-init
              return "ready";
            } else if (statusCounts.qr === totalPhones) {
              // All phones are showing QR - pure QR state
              return "qr";
            }
          }

          // If phones are still processing (initializing/authenticated), keep waiting
          if (processingPhones > 0) {
            return "initializing";
          }

          // If we have errors or unknown states, handle appropriately
          if (statusCounts.error > 0) {
            return "error";
          }

          // Return the most common valid status as fallback
          return validStatuses[0] || "unknown";
        }

        // Check database as fallback
        const result = await sqlDb.query(
          "SELECT status FROM phone_status WHERE company_id = $1 ORDER BY phone_index LIMIT 1",
          [botName]
        );
        return result.rows.length > 0 ? result.rows[0].status : "unknown";
      } catch (error) {
        console.error(`Error getting status for bot ${botName}:`, error);
        return "unknown";
      }
    };

    // Function to check if bot should proceed with post-initialization tasks
    const shouldProceedWithPostInit = async (botName) => {
      const status = await getBotStatus(botName);
      const botData = botMap.get(botName);

      if (botData && Array.isArray(botData)) {
        const statusCounts = {
          ready: botData.filter((phone) => phone?.status === "ready").length,
          qr: botData.filter((phone) => phone?.status === "qr").length,
          initializing: botData.filter(
            (phone) => phone?.status === "initializing"
          ).length,
          authenticated: botData.filter(
            (phone) => phone?.status === "authenticated"
          ).length,
        };

        const totalPhones = botData.length;
        const finalStatePhones = statusCounts.ready + statusCounts.qr;
        const allInFinalState = finalStatePhones === totalPhones;

        // Only proceed if ALL phones are in final state AND at least one is ready
        return allInFinalState && statusCounts.ready > 0;
      }

      return status === "ready";
    };

    // Function to initialize a single phone with enhanced timeout and status tracking
    const initializeSinglePhoneWithTimeout = async (
      phoneTask,
      retryCount = 0
    ) => {
      const { botName, phoneIndex, totalPhones, isLastPhone, originalConfig } =
        phoneTask;
      const startTime = Date.now();
      let statusCheckInterval;
      let lastStatus = "unknown";

      // Fixed timeout per phone (not dependent on total phone count since we're doing them individually)
      const phoneTimeout = BOT_TIMEOUT;

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(
          () =>
            reject(new Error(`Phone timeout after ${phoneTimeout / 1000}s`)),
          phoneTimeout
        )
      );

      // Status monitoring promise for individual phone
      const statusMonitorPromise = new Promise((resolve, reject) => {
        statusCheckInterval = setInterval(async () => {
          try {
            const botData = botMap.get(botName);
            let phoneStatus = "unknown";
            let phoneStatusDetails = "";

            if (botData && Array.isArray(botData) && botData[phoneIndex]) {
              phoneStatus = botData[phoneIndex].status || "unknown";

              // Get overall bot status for context
              const statusCounts = {
                ready: botData.filter((p) => p?.status === "ready").length,
                qr: botData.filter((p) => p?.status === "qr").length,
                authenticated: botData.filter(
                  (p) => p?.status === "authenticated"
                ).length,
                initializing: botData.filter(
                  (p) => p?.status === "initializing"
                ).length,
                error: botData.filter((p) => p?.status === "error").length,
              };

              const completedPhones = statusCounts.ready + statusCounts.qr;
              phoneStatusDetails = ` (Bot ${botName}: ${completedPhones}/${totalPhones} phones done - P${
                phoneIndex + 1
              }: ${phoneStatus})`;
            }

            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

            if (phoneStatus !== lastStatus) {
              console.log(
                `🔄 Phone ${botName}-P${
                  phoneIndex + 1
                } status: ${lastStatus} → ${phoneStatus}${phoneStatusDetails} (${elapsed}s)`
              );
              lastStatus = phoneStatus;
            }

            // Check if this specific phone reached a final state
            if (phoneStatus === "ready") {
              clearInterval(statusCheckInterval);
              console.log(
                `✅ Phone ${botName}-P${
                  phoneIndex + 1
                } ready${phoneStatusDetails} (${elapsed}s)`
              );
              resolve({
                status: "ready",
                shouldProceedWithPostInit: isLastPhone,
              });
            } else if (phoneStatus === "qr") {
              clearInterval(statusCheckInterval);
              console.log(
                `📱 Phone ${botName}-P${
                  phoneIndex + 1
                } showing QR${phoneStatusDetails} (${elapsed}s)`
              );
              resolve({ status: "qr", shouldProceedWithPostInit: false });
            } else if (phoneStatus === "error") {
              clearInterval(statusCheckInterval);
              console.log(
                `❌ Phone ${botName}-P${
                  phoneIndex + 1
                } error${phoneStatusDetails} (${elapsed}s)`
              );
              reject(new Error(`Phone ${phoneIndex + 1} error`));
            }

            // Check for stuck initialization
            if (phoneStatus === "initializing" && elapsed > 60) {
              console.warn(
                `⚠️ Phone ${botName}-P${
                  phoneIndex + 1
                } still initializing after ${elapsed}s${phoneStatusDetails}`
              );
            }
          } catch (error) {
            console.error(
              `Error monitoring phone ${botName}-P${phoneIndex + 1}:`,
              error
            );
          }
        }, STATUS_CHECK_INTERVAL);
      });

      const initPromise = (async () => {
        console.log(
          `🚀 Initializing phone ${botName}-P${
            phoneIndex + 1
          }/${totalPhones}...`
        );

        // Initialize the phone (this will create the bot entry if it doesn't exist)
        if (phoneIndex === 0) {
          // First phone initializes the whole bot
          initializeBot(botName, totalPhones);
        }

        // Wait for this specific phone's status resolution
        const result = await Promise.race([
          statusMonitorPromise,
          timeoutPromise,
        ]);

        console.log(
          `✅ Phone ${botName}-P${
            phoneIndex + 1
          } initialization completed with status: ${result.status}`
        );

        // Only proceed with post-init tasks if this is the last phone and bot is ready
        if (result.shouldProceedWithPostInit && isLastPhone) {
          console.log(
            `📅 Starting post-initialization tasks for bot ${botName} (all phones complete)`
          );

          scheduleAllMessages(botName);

          // Schedule daily reports for this bot (automated per-bot scheduling)
          await scheduleDailyReportForBot(botName);

          // After successful initialization, sync messages and handle auto-replies
          await syncMessagesAndHandleAutoReplies(botName, totalPhones);

          console.log(`🎉 All tasks completed for bot ${botName}`);
        }

        return result;
      })();

      try {
        const result = await Promise.race([initPromise, timeoutPromise]);
        clearInterval(statusCheckInterval);
        return {
          success: true,
          phoneTask,
          retryCount,
          status: result.status,
          completedPostInit: result.shouldProceedWithPostInit,
        };
      } catch (error) {
        clearInterval(statusCheckInterval);
        console.error(
          `❌ Phone ${botName}-P${phoneIndex + 1} failed (attempt ${
            retryCount + 1
          }/${MAX_RETRIES + 1}):`,
          error.message
        );

        // Check if phone got stuck and attempt cleanup
        const botData = botMap.get(botName);
        if (botData && botData[phoneIndex]?.status === "initializing") {
          console.log(
            `🧹 Attempting cleanup for stuck phone ${botName}-P${
              phoneIndex + 1
            }`
          );
          try {
            await safeCleanup(botName, phoneIndex);
          } catch (cleanupError) {
            console.error(
              `Error during cleanup for ${botName}-P${phoneIndex + 1}:`,
              cleanupError
            );
          }
        }

        return {
          success: false,
          phoneTask,
          error: error.message,
          retryCount,
          status:
            botData && botData[phoneIndex]
              ? botData[phoneIndex].status
              : "unknown",
        };
      }
    };

    // Function to initialize a single bot with enhanced timeout and status tracking (kept for compatibility)
    const initializeSingleBotWithTimeout = async (config, retryCount = 0) => {
      const startTime = Date.now();
      let statusCheckInterval;
      let lastStatus = "unknown";

      // Dynamic timeout based on phone count - multi-phone bots need more time
      const dynamicTimeout =
        config.phoneCount > 1
          ? BOT_TIMEOUT + config.phoneCount * 15000 // Extra 15s per additional phone
          : BOT_TIMEOUT;

      const timeoutPromise = new Promise((_, reject) =>
        setTimeout(
          () => reject(new Error(`Timeout after ${dynamicTimeout / 1000}s`)),
          dynamicTimeout
        )
      );

      // Status monitoring promise
      const statusMonitorPromise = new Promise((resolve, reject) => {
        statusCheckInterval = setInterval(async () => {
          try {
            const currentStatus = await getBotStatus(config.botName);
            const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

            // Get detailed phone status for multi-phone bots
            const botData = botMap.get(config.botName);
            let phoneStatusDetails = "";
            let allPhonesInFinalState = false;

            if (botData && Array.isArray(botData)) {
              const statusCounts = {
                ready: botData.filter((p) => p?.status === "ready").length,
                qr: botData.filter((p) => p?.status === "qr").length,
                authenticated: botData.filter(
                  (p) => p?.status === "authenticated"
                ).length,
                initializing: botData.filter(
                  (p) => p?.status === "initializing"
                ).length,
                error: botData.filter((p) => p?.status === "error").length,
              };

              const totalPhones = botData.length;
              const finalStatePhones = statusCounts.ready + statusCounts.qr;
              allPhonesInFinalState = finalStatePhones === totalPhones;

              phoneStatusDetails = ` (${statusCounts.ready}R/${statusCounts.qr}Q/${statusCounts.authenticated}A/${statusCounts.initializing}I/${statusCounts.error}E - ${finalStatePhones}/${totalPhones} final)`;
            }

            if (currentStatus !== lastStatus) {
              console.log(
                `🔄 Bot ${config.botName} status changed: ${lastStatus} → ${currentStatus}${phoneStatusDetails} (${elapsed}s)`
              );
              lastStatus = currentStatus;
            }

            // Only resolve when ALL phones have reached final states (ready or qr)
            if (currentStatus === "ready" && allPhonesInFinalState) {
              clearInterval(statusCheckInterval);
              console.log(
                `✅ Bot ${config.botName} all phones in final state, has ready phones - proceeding with setup${phoneStatusDetails}`
              );
              resolve({ status: "ready", shouldProceedWithPostInit: true });
            } else if (currentStatus === "qr" && allPhonesInFinalState) {
              clearInterval(statusCheckInterval);
              console.log(
                `📱 Bot ${config.botName} all phones in final state, all showing QR - no post-init tasks${phoneStatusDetails}`
              );
              resolve({ status: "qr", shouldProceedWithPostInit: false });
            }

            // Check for stuck initialization - but be more lenient for multi-phone bots
            const maxWaitTime =
              config.phoneCount && config.phoneCount > 1 ? 75 : 60; // Extra time for multi-phone
            if (currentStatus === "initializing" && elapsed > maxWaitTime) {
              console.warn(
                `⚠️ Bot ${config.botName} still initializing after ${elapsed}s${phoneStatusDetails}`
              );
              // Don't reject here, let timeout handle it
            }

            // Progress logging for multi-phone bots
            if (
              botData &&
              botData.length > 1 &&
              elapsed % 20 < STATUS_CHECK_INTERVAL / 1000
            ) {
              console.log(
                `⏳ Bot ${config.botName} progress${phoneStatusDetails} (${elapsed}s)`
              );
            }
          } catch (error) {
            console.error(
              `Error monitoring status for ${config.botName}:`,
              error
            );
          }
        }, STATUS_CHECK_INTERVAL);
      });

      const initPromise = (async () => {
        console.log(`🚀 Initializing bot ${config.botName}...`);

        initializeBot(config.botName, config.phoneCount);

        // Wait for either status resolution OR initialization completion, whichever comes first
        const result = await Promise.race([
          statusMonitorPromise,
          timeoutPromise,
        ]);

        console.log(
          `✅ Bot ${config.botName} initialization completed with status: ${result.status}`
        );

        // Only proceed with post-init tasks if bot is ready
        if (result.shouldProceedWithPostInit) {
          console.log(
            `📅 Starting post-initialization tasks for bot ${config.botName}`
          );

          if (config.botName === "0380") {
            initializeMtdcSpreadsheet();
          }

          scheduleAllMessages(config.botName);

          // Schedule daily reports for this bot (automated per-bot scheduling)
          await scheduleDailyReportForBot(config.botName);

          // After successful initialization, sync messages and handle auto-replies
          await syncMessagesAndHandleAutoReplies(
            config.botName,
            config.phoneCount
          );

          console.log(`🎉 All tasks completed for bot ${config.botName}`);
        } else {
          console.log(
            `📱 Bot ${config.botName} is in ${result.status} state, skipping post-initialization tasks`
          );
        }

        return result;
      })();

      try {
        const result = await Promise.race([initPromise, timeoutPromise]);
        clearInterval(statusCheckInterval);
        return {
          success: true,
          config,
          retryCount,
          status: result.status,
          completedPostInit: result.shouldProceedWithPostInit,
        };
      } catch (error) {
        clearInterval(statusCheckInterval);
        console.error(
          `❌ Bot ${config.botName} failed (attempt ${retryCount + 1}/${
            MAX_RETRIES + 1
          }):`,
          error.message
        );

        // Check if bot got stuck and attempt cleanup
        const currentStatus = await getBotStatus(config.botName);
        if (currentStatus === "initializing") {
          console.log(`🧹 Attempting cleanup for stuck bot ${config.botName}`);
          try {
            await safeCleanup(config.botName, 0); // Cleanup first phone
          } catch (cleanupError) {
            console.error(
              `Error during cleanup for ${config.botName}:`,
              cleanupError
            );
          }
        }

        return {
          success: false,
          config,
          error: error.message,
          retryCount,
          status: currentStatus,
        };
      }
    };

    try {
      const completedBots = new Set();
      const qrBots = new Set();
      const failedBots = new Set();
      const completedPhones = new Map(); // Track completed phones per bot
      const failedPhones = new Map(); // Track failed phones per bot
      let activePhones = new Map(); // Track currently initializing phones

      // Initialize tracking maps
      Object.keys(phoneTasksByBot).forEach((botName) => {
        completedPhones.set(botName, []);
        failedPhones.set(botName, []);
      });

      const pendingPhones = [
        ...allPhoneTasks.map((task) => ({ ...task, retryCount: 0 })),
      ];

      while (pendingPhones.length > 0 || activePhones.size > 0) {
        // Start new phones up to the concurrent limit
        while (activePhones.size < MAX_CONCURRENT && pendingPhones.length > 0) {
          const phoneTask = pendingPhones.shift();
          const phoneId = `${phoneTask.botName}-P${phoneTask.phoneIndex + 1}`;
          console.log(
            `🚀 Starting phone ${phoneId} (${
              activePhones.size + 1
            }/${MAX_CONCURRENT} concurrent, ${
              pendingPhones.length
            } phones remaining)`
          );

          const phonePromise = initializeSinglePhoneWithTimeout(
            phoneTask,
            phoneTask.retryCount
          );
          activePhones.set(phoneId, {
            promise: phonePromise,
            task: phoneTask,
            startTime: Date.now(),
          });
        }

        // Wait for at least one phone to complete
        if (activePhones.size > 0) {
          const activePromises = Array.from(activePhones.entries()).map(
            ([phoneId, phoneData]) =>
              phoneData.promise.then((result) => ({ phoneId, result }))
          );

          const { phoneId, result } = await Promise.race(activePromises);
          const completionTime = (
            (Date.now() - activePhones.get(phoneId).startTime) /
            1000
          ).toFixed(1);
          const phoneTask = activePhones.get(phoneId).task;
          const { botName, phoneIndex, totalPhones, isLastPhone } = phoneTask;

          // Remove completed phone from active tracking
          activePhones.delete(phoneId);

          if (result.success) {
            // Track completed phone
            completedPhones.get(botName).push(phoneTask);

            const completedCount = completedPhones.get(botName).length;
            console.log(
              `✅ Phone ${phoneId} completed with status ${result.status} in ${completionTime}s (Bot ${botName}: ${completedCount}/${totalPhones} phones done)`
            );

            // Check if this bot is now complete (all phones processed)
            if (completedCount === totalPhones) {
              const botPhones = completedPhones.get(botName);
              const readyPhones = botPhones.filter((p) => {
                const botData = botMap.get(p.botName);
                return (
                  botData &&
                  botData[p.phoneIndex] &&
                  botData[p.phoneIndex].status === "ready"
                );
              }).length;

              const qrPhones = botPhones.filter((p) => {
                const botData = botMap.get(p.botName);
                return (
                  botData &&
                  botData[p.phoneIndex] &&
                  botData[p.phoneIndex].status === "qr"
                );
              }).length;

              if (readyPhones > 0) {
                completedBots.add(botName);
                console.log(
                  `🎉 Bot ${botName} ALL PHONES COMPLETE: ${readyPhones} ready, ${qrPhones} QR - bot operational (${completedBots.size}/${botConfigs.length} bots complete)`
                );
              } else if (qrPhones === totalPhones) {
                qrBots.add(botName);
                console.log(
                  `📱 Bot ${botName} ALL PHONES SHOWING QR: ${qrPhones}/${totalPhones} phones need pairing (${qrBots.size} bots showing QR)`
                );
              }
            }
          } else {
            // Handle failed phone - send to back of queue for retry
            if (result.retryCount < MAX_RETRIES) {
              const retryTask = {
                ...phoneTask,
                retryCount: result.retryCount + 1,
              };
              console.log(
                `🔄 Phone ${phoneId} failed (status: ${
                  result.status || "unknown"
                }), retry attempt ${retryTask.retryCount + 1}/${
                  MAX_RETRIES + 1
                }`
              );

              // Add failed phone to the back of the queue
              pendingPhones.push(retryTask);
            } else {
              // Track permanently failed phone
              failedPhones.get(botName).push(phoneTask);
              const failedCount = failedPhones.get(botName).length;
              console.log(
                `❌ Phone ${phoneId} permanently failed after ${
                  MAX_RETRIES + 1
                } attempts (Bot ${botName}: ${failedCount}/${totalPhones} phones failed)`
              );

              // Check if bot should be marked as failed (all phones processed, none successful)
              const completedCount = completedPhones.get(botName).length;
              const totalProcessed = completedCount + failedCount;

              if (totalProcessed === totalPhones && completedCount === 0) {
                failedBots.add(botName);
                console.log(
                  `💥 Bot ${botName} COMPLETELY FAILED: all ${totalPhones} phones failed (${failedBots.size} bots failed)`
                );
              }
            }
          }
        }
      }

      // Final summary
      console.log(`\n🎉 Phone-based bot initialization completed!`);
      console.log(`✅ Ready bots: ${completedBots.size}/${botConfigs.length}`);
      console.log(
        `📱 QR bots (awaiting pairing): ${qrBots.size}/${botConfigs.length}`
      );
      console.log(
        `🟢 Total successful: ${completedBots.size + qrBots.size}/${
          botConfigs.length
        }`
      );

      if (failedBots.size > 0) {
        console.log(`❌ Failed bots: ${Array.from(failedBots).join(", ")}`);
      }

      if (qrBots.size > 0) {
        console.log(
          `📱 QR bots (scan QR codes to complete setup): ${Array.from(
            qrBots
          ).join(", ")}`
        );
      }

      // Detailed phone breakdown
      console.log(`\n📊 Phone breakdown:`);
      Object.keys(phoneTasksByBot).forEach((botName) => {
        const totalPhones = phoneTasksByBot[botName].length;
        const completed = completedPhones.get(botName).length;
        const failed = failedPhones.get(botName).length;
        const status = failedBots.has(botName)
          ? "❌ FAILED"
          : qrBots.has(botName)
          ? "📱 QR"
          : completedBots.has(botName)
          ? "✅ READY"
          : "⏳ PROCESSING";
        console.log(
          `  Bot ${botName}: ${completed}/${totalPhones} phones completed, ${failed} failed - ${status}`
        );
      });

      return {
        ready: completedBots.size,
        qr: qrBots.size,
        failed: failedBots.size,
        total: botConfigs.length,
        successful: completedBots.size + qrBots.size,
        readyBots: Array.from(completedBots),
        qrBots: Array.from(qrBots),
        failedBots: Array.from(failedBots),
      };
    } catch (error) {
      console.error("Error during bot cluster initializations:", error.message);
      throw error;
    }
  };

  await initializeBotsWithDelay(botConfigs);
  setupNeonWebhooks(app, botMap);

  // Start the bot monitoring system
  startBotMonitoringSystem();

  console.log("Initialization complete");
  if (process.send) process.send("ready");
}

// Enhanced bot monitoring system to detect and handle stuck/failed bots
function startBotMonitoringSystem() {
  const MONITORING_INTERVAL = 30000;
  const STUCK_THRESHOLD = 120000;

  console.log("🔍 Starting bot monitoring system...");

  setInterval(async () => {
    try {
      // Get all bots from botMap
      for (const [botName, botData] of botMap.entries()) {
        if (!Array.isArray(botData)) continue;

        for (let phoneIndex = 0; phoneIndex < botData.length; phoneIndex++) {
          const phone = botData[phoneIndex];
          if (!phone) continue;

          const currentTime = Date.now();
          const status = phone.status;
          const initStartTime = phone.initializationStartTime;

          // Check for stuck initialization
          if (status === "initializing" && initStartTime) {
            const stuckDuration = currentTime - initStartTime;

            if (stuckDuration > STUCK_THRESHOLD) {
              console.warn(
                `⚠️ Bot ${botName} Phone ${
                  phoneIndex + 1
                } stuck in initializing for ${(stuckDuration / 1000).toFixed(
                  1
                )}s - attempting recovery`
              );

              try {
                // Update status to indicate recovery attempt
                botData[phoneIndex].status = "recovering";
                botMap.set(botName, botData);
                await updatePhoneStatus(botName, phoneIndex, "recovering");

                // Attempt cleanup and reinitialization
                await safeCleanup(botName, phoneIndex);

                // Small delay before reinitializing
                await new Promise((resolve) => setTimeout(resolve, 5000));

                // Reinitialize this specific phone
                console.log(
                  `🔄 Attempting to reinitialize stuck bot ${botName} Phone ${
                    phoneIndex + 1
                  }`
                );
                await initializeBot(botName, 1, phoneIndex);
              } catch (recoveryError) {
                console.error(
                  `❌ Failed to recover stuck bot ${botName} Phone ${
                    phoneIndex + 1
                  }:`,
                  recoveryError
                );
                botData[phoneIndex].status = "error";
                botData[
                  phoneIndex
                ].error = `Recovery failed: ${recoveryError.message}`;
                botMap.set(botName, botData);
                await updatePhoneStatus(botName, phoneIndex, "error", {
                  error: recoveryError.message,
                  recoveryAttempted: true,
                });
              }
            }
          }
        }
      }

      // Optional: Log monitoring summary every 5 minutes
      if (Date.now() % 300000 < MONITORING_INTERVAL) {
        logBotStatusSummary();
      }
    } catch (monitoringError) {
      console.error("Error in bot monitoring system:", monitoringError);
    }
  }, MONITORING_INTERVAL);
}

// Helper function to log bot status summary
function logBotStatusSummary() {
  const summary = {
    ready: 0,
    qr: 0,
    initializing: 0,
    authenticated: 0,
    disconnected: 0,
    error: 0,
    recovering: 0,
    unknown: 0,
  };

  let totalBots = 0;

  for (const [botName, botData] of botMap.entries()) {
    if (!Array.isArray(botData)) continue;

    for (const phone of botData) {
      if (!phone) continue;
      totalBots++;
      const status = phone.status || "unknown";
      summary[status] = (summary[status] || 0) + 1;
    }
  }

  console.log(
    `📊 Bot Status Summary (${totalBots} total phones):`,
    Object.entries(summary)
      .filter(([_, count]) => count > 0)
      .map(([status, count]) => `${status}: ${count}`)
      .join(", ")
  );
}

// Define the function to initialize automations
function initializeAutomations(botMap) {
  return [
    // scheduleAllMessages(),
    // automationInstances.bhqSpreadsheet.initialize(),
    // automationInstances.constantcoSpreadsheet.initialize(),
    // automationInstances.skcSpreadsheet.initialize(),
    // checkAndScheduleDailyReport(),
    // initializeDailyReports(),
  ];
}

// Schedule daily report for a specific bot
async function scheduleDailyReportForBot(companyId) {
  try {
    console.log(`[${companyId}] Setting up daily report...`);

    const sqlClient = await pool.connect();

    try {
      // Check if this company should be handled by this server instance
      const companyQuery = `
        SELECT api_url 
        FROM public.companies 
        WHERE company_id = $1
      `;

      const companyResult = await sqlClient.query(companyQuery, [companyId]);

      if (companyResult.rows.length === 0) {
        console.log(
          `[${companyId}] Company not found, skipping daily report setup`
        );
        return;
      }

      const apiUrl = companyResult.rows[0].api_url;

      if (apiUrl !== process.env.URL) {
        console.log(
          `[${companyId}] Company belongs to different server (${apiUrl}), skipping`
        );
        return;
      }

      const settingsQuery = `
        SELECT setting_value 
        FROM public.settings 
        WHERE company_id = $1 
        AND setting_type = 'reporting' 
        AND setting_key = 'dailyReport'
      `;

      const settingsResult = await sqlClient.query(settingsQuery, [companyId]);
      const settings =
        settingsResult.rows.length > 0
          ? settingsResult.rows[0].setting_value
          : null;

      if (settings?.enabled) {
        const reportTime = settings.time || "09:00";
        const groupId = settings.groupId;
        const lastRun = settings.lastRun ? new Date(settings.lastRun) : null;
        const [hours, minutes] = reportTime.split(":");

        const cronJobName = `dailyReport_${companyId}`;

        // Cancel existing job if any
        if (schedule.scheduledJobs[cronJobName]) {
          schedule.scheduledJobs[cronJobName].cancel();
          console.log(`[${companyId}] Cancelled existing daily report job`);
        }

        const now = moment().tz("Asia/Kuala_Lumpur");
        const wasRunToday =
          lastRun && moment(lastRun).tz("Asia/Kuala_Lumpur").isSame(now, "day");

        // Check if we need to send the report immediately (if it's past scheduled time and not sent today)
        if (
          !wasRunToday &&
          now.hours() >= parseInt(hours) &&
          now.minutes() >= parseInt(minutes)
        ) {
          console.log(
            `[${companyId}] Daily report not sent yet today and it's past scheduled time. Sending now...`
          );

          const botData = botMap.get(companyId);
          if (botData && botData[0]?.client) {
            await sendDailyContactReport(botData[0].client, companyId);

            const updateQuery = `
              UPDATE public.settings 
              SET setting_value = jsonb_set(setting_value, '{lastRun}', to_jsonb($1::text))
              WHERE company_id = $2 
              AND setting_type = 'reporting' 
              AND setting_key = 'dailyReport'
            `;

            await sqlClient.query(updateQuery, [now.toISOString(), companyId]);
          } else {
            console.log(
              `[${companyId}] No WhatsApp client found for immediate report`
            );
          }
        }

        // Schedule the recurring daily report
        console.log(`[${companyId}] Scheduling daily report for ${reportTime}`);

        schedule.scheduleJob(
          cronJobName,
          {
            rule: `0 ${minutes} ${hours} * * *`,
            tz: "Asia/Kuala_Lumpur",
          },
          async function () {
            console.log(`[${companyId}] Running scheduled daily report`);

            const botData = botMap.get(companyId);
            if (botData && botData[0]?.client) {
              await sendDailyContactReport(botData[0].client, companyId);

              const sqlClientForCron = await pool.connect();
              try {
                await sqlClientForCron.query("BEGIN");
                const updateQuery = `
                  UPDATE public.settings 
                  SET setting_value = jsonb_set(setting_value, '{lastRun}', to_jsonb($1::text))
                  WHERE company_id = $2 
                  AND setting_type = 'reporting' 
                  AND setting_key = 'dailyReport'
                `;

                await sqlClientForCron.query(updateQuery, [
                  moment().tz("Asia/Kuala_Lumpur").toISOString(),
                  companyId,
                ]);
                await sqlClientForCron.query("COMMIT");
              } catch (cronError) {
                await sqlClientForCron.query("ROLLBACK");
                console.error(
                  `[${companyId}] Error updating lastRun after scheduled report:`,
                  cronError
                );
              } finally {
                sqlClientForCron.release();
              }
            } else {
              console.log(
                `[${companyId}] No WhatsApp client found for scheduled report`
              );
            }
          }
        );

        console.log(`[${companyId}] Daily report scheduled successfully`);

        // Schedule weekly summary report (every Sunday at 18:00)
        const weeklyJobName = `weeklyReport_${companyId}`;

        // Cancel existing weekly job if any
        if (schedule.scheduledJobs[weeklyJobName]) {
          schedule.scheduledJobs[weeklyJobName].cancel();
          console.log(`[${companyId}] Cancelled existing weekly report job`);
        }

        schedule.scheduleJob(
          weeklyJobName,
          {
            rule: "0 0 18 * * 0", // Every Sunday at 18:00 (6 PM)
            tz: "Asia/Kuala_Lumpur",
          },
          async function () {
            console.log(
              `[${companyId}] Running scheduled weekly summary report`
            );

            const botData = botMap.get(companyId);
            if (botData && botData[0]?.client) {
              await sendWeeklySummaryReport(botData[0].client, companyId);
            } else {
              console.log(
                `[${companyId}] No WhatsApp client found for weekly report`
              );
            }
          }
        );

        console.log(
          `[${companyId}] Weekly report scheduled successfully for Sundays at 18:00`
        );
      } else {
        console.log(`[${companyId}] Daily reporting not enabled, skipping`);
      }
    } finally {
      await safeRelease(sqlClient);
    }
  } catch (error) {
    console.error(`[${companyId}] Error setting up daily report:`, error);
  }
}

async function checkAndScheduleDailyReport() {
  try {
    const sqlClient = await pool.connect();

    try {
      await sqlClient.query("BEGIN");

      const companiesQuery = `
        SELECT company_id , api_url
        FROM public.companies
      `;

      const companiesResult = await sqlClient.query(companiesQuery);
      const companies = companiesResult.rows;

      console.log(
        `Found ${companies.length} companies to check for daily reports`
      );

      for (const company of companies) {
        const companyId = company.company_id;
        const apiUrl = company.api_url;

        if (apiUrl !== process.env.URL) {
          continue;
        }

        await scheduleDailyReportForBot(companyId);
      }

      await sqlClient.query("COMMIT");
      console.log("All daily reports have been set up successfully");
    } catch (error) {
      await safeRollback(sqlClient);
      console.error(`Error in checkAndScheduleDailyReport:`, error);
    } finally {
      await safeRelease(sqlClient);
    }
  } catch (connectionError) {
    console.error(`Database connection error:`, connectionError);
  }
}

async function sendDailyContactReport(client, idSubstring, targetDate = null) {
  const sqlClient = await pool.connect();

  try {
    const { count, contacts } = await getContactsAddedToday(
      idSubstring,
      targetDate
    );

    // Format new contacts details
    const newContactsDetails = contacts.map((contact) => ({
      name: contact.contactName || "No Name",
      phone: contact.phoneNumber,
      addedAt: moment(contact.createdAt).format("h:mm A"),
      tags: Array.isArray(contact.tags) ? contact.tags.join(", ") : "",
    }));

    // If targetDate is provided, use it; otherwise use current date
    const reportDate = targetDate
      ? moment(targetDate).tz("Asia/Kuala_Lumpur")
      : moment().tz("Asia/Kuala_Lumpur");

    // Get engagement metrics for today
    const dateStr = reportDate.format("YYYY-MM-DD");

    // Get reply rate and conversation stats
    const replyRateQuery = await sqlClient.query(
      `
      SELECT
        COUNT(DISTINCT CASE WHEN from_me = false THEN contact_id END) as replied_count,
        COUNT(DISTINCT CASE WHEN from_me = true THEN contact_id END) as total_contacted
      FROM messages
      WHERE company_id = $1
      AND DATE(timestamp AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Kuala_Lumpur') = $2
    `,
      [idSubstring, dateStr]
    );

    const replyStats = replyRateQuery.rows[0];
    const replyRate =
      replyStats.total_contacted > 0
        ? Math.round(
            (replyStats.replied_count / replyStats.total_contacted) * 100
          )
        : 0;

    // Get total AI conversations today
    const conversationQuery = await sqlClient.query(
      `
      SELECT COUNT(*) as count
      FROM messages
      WHERE company_id = $1
      AND DATE(timestamp AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Kuala_Lumpur') = $2
    `,
      [idSubstring, dateStr]
    );

    const totalMessages = parseInt(conversationQuery.rows[0].count) || 0;

    // Find contacts with no reply in 48-72 hours (cold leads needing follow-up)
    const coldLeadsQuery = await sqlClient.query(
      `
      SELECT
        c.name as contact_name,
        c.phone,
        MAX(m.timestamp) as last_message_time
      FROM contacts c
      LEFT JOIN messages m ON c.contact_id = m.contact_id AND c.company_id = m.company_id
      WHERE c.company_id = $1
      AND c.created_at > NOW() - INTERVAL '7 days'
      GROUP BY c.contact_id, c.name, c.phone
      HAVING MAX(m.timestamp) < NOW() - INTERVAL '48 hours'
         OR MAX(m.timestamp) IS NULL
      ORDER BY last_message_time ASC NULLS FIRST
      LIMIT 5
    `,
      [idSubstring]
    );

    const coldLeads = coldLeadsQuery.rows;

    // Get closed contacts today
    const closedTodayQuery = await sqlClient.query(
      `
      SELECT COUNT(*) as count
      FROM contacts
      WHERE company_id = $1
      AND tags ? 'closed'
      AND DATE(created_at AT TIME ZONE 'Asia/Kuala_Lumpur') = $2
    `,
      [idSubstring, dateStr]
    );
    const closedToday = parseInt(closedTodayQuery.rows[0].count) || 0;

    // Get yesterday's stats for comparison
    const yesterdayStr = moment(reportDate)
      .subtract(1, "day")
      .format("YYYY-MM-DD");
    const yesterdayQuery = await sqlClient.query(
      `
      SELECT
        COUNT(DISTINCT contact_id) as leads_yesterday,
        COUNT(DISTINCT CASE WHEN from_me = false THEN contact_id END) as replied_yesterday
      FROM messages
      WHERE company_id = $1
      AND DATE(timestamp AT TIME ZONE 'Asia/Kuala_Lumpur') = $2
    `,
      [idSubstring, yesterdayStr]
    );

    const leadsYesterday =
      parseInt(yesterdayQuery.rows[0].leads_yesterday) || 0;
    const repliedYesterday =
      parseInt(yesterdayQuery.rows[0].replied_yesterday) || 0;

    // Calculate trends
    const leadsTrend =
      leadsYesterday > 0
        ? Math.round(((count - leadsYesterday) / leadsYesterday) * 100)
        : 0;
    const leadsTrendArrow = leadsTrend > 0 ? "↑" : leadsTrend < 0 ? "↓" : "→";
    const leadsTrendText =
      leadsTrend !== 0
        ? ` ${leadsTrendArrow} ${leadsTrend > 0 ? "+" : ""}${leadsTrend}%`
        : "";

    const repliedToday = parseInt(replyStats.replied_count) || 0;
    const repliesTrend =
      repliedYesterday > 0
        ? Math.round(
            ((repliedToday - repliedYesterday) / repliedYesterday) * 100
          )
        : 0;
    const repliesTrendArrow =
      repliesTrend > 0 ? "↑" : repliesTrend < 0 ? "↓" : "→";
    const repliesTrendText =
      repliesTrend !== 0
        ? ` ${repliesTrendArrow} ${repliesTrend > 0 ? "+" : ""}${repliesTrend}%`
        : "";

    // Format cold leads details
    const coldLeadsDetails = coldLeads.map((lead) => ({
      name: lead.contact_name || "No Name",
      phone: lead.phone,
      lastContact: lead.last_message_time
        ? moment(lead.last_message_time).fromNow()
        : "No messages yet",
      daysSinceLastContact: lead.last_message_time
        ? Math.ceil(
            moment
              .duration(moment().diff(moment(lead.last_message_time)))
              .asDays()
          )
        : Math.ceil(
            moment
              .duration(moment().diff(moment(lead.contact_created)))
              .asDays()
          ),
      messageCount: lead.total_messages || 0,
    }));

    // Get 7-day context for motivation
    const sevenDaysAgo = moment(reportDate)
      .subtract(7, "days")
      .format("YYYY-MM-DD");
    const weeklyContextQuery = await sqlClient.query(
      `
      SELECT COUNT(DISTINCT contact_id) as total_leads_7d
      FROM contacts
      WHERE company_id = $1
      AND DATE(created_at AT TIME ZONE 'Asia/Kuala_Lumpur') >= $2
    `,
      [idSubstring, sevenDaysAgo]
    );
    const totalLeads7d =
      parseInt(weeklyContextQuery.rows[0].total_leads_7d) || 0;

    // Generate personalized encouragement/motivation
    let motivationalMessage = "";
    if (count > leadsYesterday && count > 0) {
      motivationalMessage = `🔥 You're on fire! ${count} leads today is ${
        leadsTrendText.includes("+")
          ? "your best this week"
          : "momentum building"
      }!`;
    } else if (closedToday > 0) {
      motivationalMessage = `🎯 ${closedToday} deal${
        closedToday > 1 ? "s" : ""
      } closed today — great work converting!`;
    } else if (replyRate > 60) {
      motivationalMessage = `💪 ${replyRate}% response rate — your messaging is working!`;
    } else if (count > 0) {
      motivationalMessage = `🚀 Keep it up — consistency = conversions.`;
    } else {
      motivationalMessage = `💡 Tip: Engage your existing leads while waiting for new ones.`;
    }

    // Actionable alert with context
    let actionableAlert = "";
    if (coldLeads.length > 0) {
      actionableAlert = `⚠️ ${coldLeads.length} lead${
        coldLeads.length > 1 ? "s" : ""
      } ${
        coldLeads.length > 1 ? "haven't" : "hasn't"
      } been followed up in 48h. Try re-engaging them today 💪\n\n`;
    } else if (repliedToday > 0 && closedToday === 0) {
      actionableAlert = `💡 You have ${repliedToday} engaged lead${
        repliedToday > 1 ? "s" : ""
      } — follow up to convert them!\n\n`;
    }

    // Format new contacts section for the message
    let newContactsSection = "";
    if (newContactsDetails && newContactsDetails.length > 0) {
      newContactsSection =
        `\n📌 *New Leads (${count})*:\n` +
        newContactsDetails
          .map(
            (contact, index) =>
              `${index + 1}. ${contact.name} (${contact.phone}) - ${
                contact.addedAt
              }` + (contact.tags ? `\n   🏷️ Tags: ${contact.tags}` : "")
          )
          .join("\n") +
        "\n\n";
    }

    // Format cold leads details for the message
    let coldLeadsSection = "";
    if (coldLeadsDetails.length > 0) {
      coldLeadsSection =
        `\n❄️ *Cold Leads (${coldLeadsDetails.length}) - Needs Follow-up*:\n` +
        coldLeadsDetails
          .map(
            (lead, index) =>
              `${index + 1}. ${lead.name} (${
                lead.phone
              })\n   ⏱️ Last contact: ${lead.lastContact} (${
                lead.daysSinceLastContact
              } days ago)\n` + `   💬 Messages: ${lead.messageCount}`
          )
          .join("\n") +
        "\n\n";
    }

    const message =
      `📊 *Daily Summary – ${reportDate.format("DD MMM YYYY")}*\n\n` +
      `👥 New Leads Today: *${count}*${leadsTrendText}\n` +
      `💬 Replies Received: *${repliedToday}*${repliesTrendText}\n` +
      `✅ Closed Contacts: *${closedToday}*\n` +
      `📈 Response Rate: *${replyRate}%*\n\n` +
      (newContactsSection || "") +
      (coldLeadsSection || "") +
      (actionableAlert || "");

    const settingsQuery = `
      SELECT setting_value->>'groupId' as group_id
      FROM public.settings
      WHERE company_id = $1
      AND setting_type = 'reporting'
      AND setting_key = 'dailyReport'
    `;

    const settingsResult = await sqlClient.query(settingsQuery, [idSubstring]);
    const groupId =
      settingsResult.rows.length > 0 ? settingsResult.rows[0].group_id : null;

    if (groupId) {
      await client.sendMessage(groupId, message);
      console.log(
        `Daily report sent to group ${groupId} for company ${idSubstring} for date ${reportDate.format(
          "DD/MM/YYYY"
        )}`
      );
    } else {
      console.log(
        `No group ID configured for daily report for company ${idSubstring}`
      );
    }

    return { success: true, message: "Report sent successfully" };
  } catch (error) {
    console.error(
      `Error sending daily contact report for ${idSubstring}:`,
      error
    );
    return { success: false, error: error.message };
  } finally {
    await safeRelease(sqlClient);
  }
}

// Generate data-driven AI insights from actual conversation patterns
async function generateDailyAIInsight(companyId, sqlClient) {
  try {
    const today = moment().tz("Asia/Kuala_Lumpur").format("YYYY-MM-DD");
    const yesterday = moment()
      .tz("Asia/Kuala_Lumpur")
      .subtract(1, "day")
      .format("YYYY-MM-DD");
    const sevenDaysAgo = moment()
      .tz("Asia/Kuala_Lumpur")
      .subtract(7, "days")
      .format("YYYY-MM-DD");

    // Get real conversation insights
    const insightData = await sqlClient.query(
      `
      WITH today_stats AS (
        SELECT
          COUNT(DISTINCT contact_id) as contacts_today,
          COUNT(*) as messages_today,
          COUNT(DISTINCT CASE WHEN from_me = false THEN contact_id END) as replied_today
        FROM messages
        WHERE company_id = $1
        AND DATE(timestamp AT TIME ZONE 'Asia/Kuala_Lumpur') = $2
      ),
      yesterday_stats AS (
        SELECT
          COUNT(DISTINCT contact_id) as contacts_yesterday,
          COUNT(*) as messages_yesterday,
          COUNT(DISTINCT CASE WHEN from_me = false THEN contact_id END) as replied_yesterday
        FROM messages
        WHERE company_id = $1
        AND DATE(timestamp AT TIME ZONE 'Asia/Kuala_Lumpur') = $3
      ),
      week_stats AS (
        SELECT
          COUNT(DISTINCT contact_id) as contacts_week,
          AVG(CASE WHEN from_me = false THEN 1 ELSE 0 END) as avg_reply_rate_week,
          COUNT(DISTINCT CASE WHEN from_me = false THEN contact_id END)::float /
            NULLIF(COUNT(DISTINCT CASE WHEN from_me = true THEN contact_id END), 0) as engagement_rate_week
        FROM messages
        WHERE company_id = $1
        AND DATE(timestamp AT TIME ZONE 'Asia/Kuala_Lumpur') >= $4
      ),
      recent_conversation_samples AS (
        SELECT
          c.name,
          c.phone,
          COUNT(m.message_id) as message_count,
          MAX(CASE WHEN m.from_me = false THEN 1 ELSE 0 END) as has_reply,
          STRING_AGG(
            CASE WHEN m.from_me = true THEN SUBSTRING(m.content, 1, 100) ELSE NULL END,
            ' | '
          ) as bot_messages_sample
        FROM contacts c
        LEFT JOIN messages m ON c.contact_id = m.contact_id AND c.company_id = m.company_id
        WHERE c.company_id = $1
        AND DATE(c.created_at AT TIME ZONE 'Asia/Kuala_Lumpur') >= $3
        GROUP BY c.contact_id, c.name, c.phone
        ORDER BY c.created_at DESC
        LIMIT 5
      ),
      closed_today AS (
        SELECT COUNT(*) as closed_count
        FROM contacts
        WHERE company_id = $1
        AND 'closed' = ANY(tags)
        AND DATE(created_at AT TIME ZONE 'Asia/Kuala_Lumpur') = $2
      )
      SELECT
        t.contacts_today,
        t.messages_today,
        t.replied_today,
        y.contacts_yesterday,
        y.messages_yesterday,
        y.replied_yesterday,
        w.contacts_week,
        w.avg_reply_rate_week,
        w.engagement_rate_week,
        ct.closed_count,
        (SELECT JSON_AGG(row_to_json(recent_conversation_samples.*)) FROM recent_conversation_samples) as conversation_samples
      FROM today_stats t, yesterday_stats y, week_stats w, closed_today ct
    `,
      [companyId, today, yesterday, sevenDaysAgo]
    );

    const data = insightData.rows[0];

    // Calculate trends
    const leadTrend =
      data.contacts_yesterday > 0
        ? Math.round(
            ((data.contacts_today - data.contacts_yesterday) /
              data.contacts_yesterday) *
              100
          )
        : 0;
    const replyRateToday =
      data.contacts_today > 0
        ? Math.round((data.replied_today / data.contacts_today) * 100)
        : 0;
    const replyRateYesterday =
      data.contacts_yesterday > 0
        ? Math.round((data.replied_yesterday / data.contacts_yesterday) * 100)
        : 0;

    // Extract conversation pattern insights
    const conversationSamples = data.conversation_samples || [];
    const noReplyContacts = conversationSamples.filter(
      (c) => c.has_reply === 0
    );
    const avgMessagesPerContact =
      conversationSamples.length > 0
        ? Math.round(
            conversationSamples.reduce((sum, c) => sum + c.message_count, 0) /
              conversationSamples.length
          )
        : 0;

    const prompt = `You are a WhatsApp sales performance analyst. Analyze these REAL conversation metrics and provide ONE specific, actionable insight (max 2 sentences).

REAL DATA FROM TODAY:
- New leads today: ${data.contacts_today} (${
      leadTrend > 0 ? "+" : ""
    }${leadTrend}% vs yesterday)
- Reply rate today: ${replyRateToday}% (yesterday: ${replyRateYesterday}%)
- Total messages exchanged: ${data.messages_today}
- Deals closed today: ${data.closed_count || 0}
- Average messages per conversation: ${avgMessagesPerContact}
- Leads not responding: ${noReplyContacts.length} out of ${
      conversationSamples.length
    } recent

7-DAY TREND:
- Weekly engagement rate: ${Math.round((data.engagement_rate_week || 0) * 100)}%
- Total leads this week: ${data.contacts_week}

PRIORITY INSIGHTS (choose the MOST important one):
1. If reply rate dropped >10%: Identify what changed in messaging approach
2. If leads increasing but replies flat: Message quality or timing issue
3. If no deals closed but high engagement: Suggest stronger call-to-action
4. If >50% not responding: Opening message may be weak
5. If avg messages high but no close: May need better qualification

Return ONLY ONE specific actionable insight based on the actual numbers above. Reference the specific metrics. No generic advice.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-5-mini",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 120,
      temperature: 0.6,
    });

    return completion.choices[0].message.content.trim();
  } catch (error) {
    console.error("Error generating AI insight:", error);
    return null; // Return null instead of generic advice
  }
}

async function generateAIWeeklyTip(stats) {
  try {
    const totalLeads = parseInt(stats.total_leads) || 0;
    const engagedLeads = parseInt(stats.engaged_leads) || 0;
    const totalMessages = parseInt(stats.total_messages) || 0;
    const qualifiedLeads = parseInt(stats.qualified_leads) || 0;
    const engagementRate =
      totalLeads > 0 ? Math.round((engagedLeads / totalLeads) * 100) : 0;
    const dailyAvg = Math.round(totalLeads / 7);

    const prompt = `You are a sales performance AI consultant. Based on these WhatsApp lead generation metrics for the past week, provide ONE actionable tip (2-3 sentences max) to improve their sales performance.

Weekly Metrics:
- Total Leads: ${totalLeads}
- Daily Average: ${dailyAvg} leads/day
- Engaged Leads: ${engagedLeads}
- Engagement Rate: ${engagementRate}%
- Total Conversations: ${totalMessages}
- Qualified Leads: ${qualifiedLeads}

Focus on:
1. If engagement rate is low (<40%): suggest better opening messages or follow-up timing
2. If qualified leads are low: suggest better lead qualification questions
3. If daily average is declining: suggest lead generation strategies
4. If engagement is high: suggest how to convert engaged leads to sales

Return ONLY the tip as plain text, no formatting, no bullet points. Start directly with actionable advice.`;

    const completion = await openai.chat.completions.create({
      model: "gpt-5-mini",
      messages: [{ role: "user", content: prompt }],
      max_tokens: 150,
      temperature: 0.7,
    });

    return completion.choices[0].message.content.trim();
  } catch (error) {
    console.error("Error generating AI tip:", error);
    // Fallback tips based on simple logic
    const engagementRate =
      parseInt(stats.total_leads) > 0
        ? Math.round(
            (parseInt(stats.engaged_leads) / parseInt(stats.total_leads)) * 100
          )
        : 0;

    if (engagementRate < 40) {
      return "Your engagement rate could be improved. Try personalizing your opening messages with the lead's name and reference their specific needs. Response rates increase 3x with personalized outreach.";
    } else if (
      parseInt(stats.qualified_leads) <
      parseInt(stats.engaged_leads) * 0.3
    ) {
      return "Focus on qualifying leads earlier in the conversation. Ask specific questions about budget, timeline, and decision-making authority within the first 3 messages to save time and improve conversion rates.";
    } else {
      return "Great engagement! Now focus on speed - leads who receive follow-ups within 5 minutes are 21x more likely to convert. Set up instant auto-replies for common questions to maintain momentum.";
    }
  }
}

async function sendWeeklySummaryReport(client, idSubstring) {
  const sqlClient = await pool.connect();

  try {
    const endDate = moment().tz("Asia/Kuala_Lumpur");
    const startDate = moment(endDate).subtract(7, "days");
    const prevWeekStart = moment(startDate).subtract(7, "days");

    console.log(
      `[${idSubstring}] Generating weekly summary for ${startDate.format(
        "DD/MM"
      )} - ${endDate.format("DD/MM/YYYY")}`
    );

    // Get this week's metrics
    const weeklyQuery = await sqlClient.query(
      `
      SELECT
        COUNT(DISTINCT c.contact_id) as total_leads,
        COUNT(DISTINCT CASE WHEN m.from_me = false THEN c.contact_id END) as engaged_leads,
        COUNT(DISTINCT CASE WHEN c.tags ? 'closed' THEN c.contact_id END) as closed_deals,
        COUNT(m.message_id) as total_messages
      FROM contacts c
      LEFT JOIN messages m ON c.contact_id = m.contact_id AND c.company_id = m.company_id
      WHERE c.company_id = $1
      AND c.created_at >= $2::timestamp AND c.created_at < $3::timestamp
    `,
      [idSubstring, startDate.toISOString(), endDate.toISOString()]
    );

    // Get last week's metrics for comparison
    const lastWeekQuery = await sqlClient.query(
      `
      SELECT
        COUNT(DISTINCT c.contact_id) as total_leads,
        COUNT(DISTINCT CASE WHEN m.from_me = false THEN c.contact_id END) as engaged_leads,
        COUNT(DISTINCT CASE WHEN c.tags ? 'closed' THEN c.contact_id END) as closed_deals
      FROM contacts c
      LEFT JOIN messages m ON c.contact_id = m.contact_id AND c.company_id = m.company_id
      WHERE c.company_id = $1
      AND c.created_at >= $2::timestamp AND c.created_at < $3::timestamp
    `,
      [idSubstring, prevWeekStart.toISOString(), startDate.toISOString()]
    );

    const thisWeek = weeklyQuery.rows[0];
    const lastWeek = lastWeekQuery.rows[0];

    const totalLeads = parseInt(thisWeek.total_leads) || 0;
    const engagedLeads = parseInt(thisWeek.engaged_leads) || 0;
    const closedDeals = parseInt(thisWeek.closed_deals) || 0;
    const totalMessages = parseInt(thisWeek.total_messages) || 0;

    const lastWeekLeads = parseInt(lastWeek.total_leads) || 0;
    const lastWeekEngaged = parseInt(lastWeek.engaged_leads) || 0;
    const lastWeekClosed = parseInt(lastWeek.closed_deals) || 0;

    // Calculate trends
    const leadsTrend =
      lastWeekLeads > 0
        ? Math.round(((totalLeads - lastWeekLeads) / lastWeekLeads) * 100)
        : 0;
    const engagedTrend =
      lastWeekEngaged > 0
        ? Math.round(((engagedLeads - lastWeekEngaged) / lastWeekEngaged) * 100)
        : 0;
    const closedTrend =
      lastWeekClosed > 0
        ? Math.round(((closedDeals - lastWeekClosed) / lastWeekClosed) * 100)
        : 0;

    const responseRate =
      totalLeads > 0 ? Math.round((engagedLeads / totalLeads) * 100) : 0;

    // Engagement insights - best performing day
    const dailyPerformanceQuery = await sqlClient.query(
      `
      SELECT
        TO_CHAR(DATE(c.created_at AT TIME ZONE 'Asia/Kuala_Lumpur'), 'Day') as day_name,
        COUNT(DISTINCT c.contact_id) as leads_count,
        COUNT(DISTINCT CASE WHEN m.from_me = false THEN c.contact_id END) as replied_count
      FROM contacts c
      LEFT JOIN messages m ON c.contact_id = m.contact_id AND c.company_id = m.company_id
      WHERE c.company_id = $1
      AND c.created_at >= $2 AND c.created_at < $3
      GROUP BY day_name, DATE(c.created_at AT TIME ZONE 'Asia/Kuala_Lumpur')
      ORDER BY replied_count DESC
      LIMIT 1
    `,
      [idSubstring, startDate.toISOString(), endDate.toISOString()]
    );

    const bestDay = dailyPerformanceQuery.rows[0];
    const bestDayName = bestDay ? bestDay.day_name.trim() : "N/A";
    const bestDayRate =
      bestDay && parseInt(bestDay.leads_count) > 0
        ? Math.round(
            (parseInt(bestDay.replied_count) / parseInt(bestDay.leads_count)) *
              100
          )
        : 0;

    // Cold leads that need re-engagement
    const coldLeadsQuery = await sqlClient.query(
      `
      SELECT COUNT(DISTINCT c.contact_id) as cold_count
      FROM contacts c
      LEFT JOIN messages m ON c.contact_id = m.contact_id AND c.company_id = m.company_id
      WHERE c.company_id = $1
      AND c.created_at >= $2::timestamp
      AND c.created_at < $3::timestamp
      GROUP BY c.contact_id
      HAVING MAX(m.timestamp) < NOW() - INTERVAL '48 hours'
         OR MAX(m.timestamp) IS NULL
    `,
      [idSubstring, startDate.toISOString(), endDate.toISOString()]
    );

    const coldLeadsCount = coldLeadsQuery.rows.length || 0;

    // Performance badges
    let topMetric = "";
    if (closedTrend > 0 && closedTrend >= leadsTrend) {
      topMetric = `🏆 Top Metric: +${closedTrend}% higher conversion this week!`;
    } else if (leadsTrend > 10) {
      topMetric = `🏆 Top Metric: +${leadsTrend}% more leads this week!`;
    } else if (responseRate > 60) {
      topMetric = `🏆 Top Metric: ${responseRate}% response rate — excellent engagement!`;
    } else {
      topMetric = `🏆 Consistency Score: You're building momentum week over week!`;
    }

    // Generate AI-powered insight
    console.log(`[${idSubstring}] Generating AI insight for weekly report...`);
    const stats = {
      total_leads: totalLeads,
      engaged_leads: engagedLeads,
      total_messages: totalMessages,
      qualified_leads: closedDeals,
      leadsTrend,
      engagedTrend,
      closedTrend,
    };
    const aiInsight = await generateAIWeeklyTip(stats);

    // Action suggestions
    let actionSuggestions = `🎯 *Recommended Actions:*\n`;
    if (coldLeadsCount > 0) {
      actionSuggestions += `Re-engage ${coldLeadsCount} cold lead${
        coldLeadsCount > 1 ? "s" : ""
      } from this week.\n`;
    }

    const message =
      `📅 *Weekly Report (${startDate.format("DD MMM")}–${endDate.format(
        "DD MMM YYYY"
      )})*\n\n` +
      `👥 Total Leads: *${totalLeads}*  (${
        leadsTrend > 0 ? "↑" : leadsTrend < 0 ? "↓" : "→"
      } ${leadsTrend > 0 ? "+" : ""}${leadsTrend}% from last week)\n` +
      `💬 Replies: *${engagedLeads}*  (${
        engagedTrend > 0 ? "↑" : engagedTrend < 0 ? "↓" : "→"
      } ${engagedTrend > 0 ? "+" : ""}${engagedTrend}%)\n` +
      `✅ Closed Deals: *${closedDeals}*  (${
        closedTrend > 0 ? "↑" : closedTrend < 0 ? "↓" : "→"
      } ${closedTrend > 0 ? "+" : ""}${closedTrend}%)\n` +
      `⚡ Response Rate: *${responseRate}%*\n\n` +
      `━━━━━━━━━━━━━━━━━━━━\n` +
      `📈 *Engagement Insights*\n` +
      (bestDayName !== "N/A"
        ? `• Fastest Response Day: ${bestDayName} (${bestDayRate}% reply rate)\n`
        : "") +
      `• Total Conversations: ${totalMessages}\n\n` +
      `🤖 *AI Insight:*\n${aiInsight}\n\n` +
      `━━━━━━━━━━━━━━━━━━━━\n` +
      topMetric +
      `\n\n` +
      `━━━━━━━━━━━━━━━━━━━━\n` +
      actionSuggestions +
      `\n` +
      `━━━━━━━━━━━━━━━━━━━━\n`;

    // Get group ID from settings (use weeklyReport or fallback to dailyReport)
    const settingsQuery = `
      SELECT setting_value->>'groupId' as group_id
      FROM public.settings
      WHERE company_id = $1
      AND setting_type = 'reporting'
      AND (setting_key = 'weeklyReport' OR setting_key = 'dailyReport')
      ORDER BY CASE WHEN setting_key = 'weeklyReport' THEN 0 ELSE 1 END
      LIMIT 1
    `;

    const settingsResult = await sqlClient.query(settingsQuery, [idSubstring]);
    const groupId =
      settingsResult.rows.length > 0 ? settingsResult.rows[0].group_id : null;

    if (groupId) {
      await client.sendMessage(groupId, message);
      console.log(
        `Weekly summary sent to group ${groupId} for company ${idSubstring}`
      );
    } else {
      console.log(
        `No group ID configured for weekly report for company ${idSubstring}`
      );
    }

    return { success: true, message: "Weekly report sent successfully" };
  } catch (error) {
    console.error(`Error sending weekly summary for ${idSubstring}:`, error);
    return { success: false, error: error.message };
  } finally {
    await safeRelease(sqlClient);
  }
}

async function getContactsAddedToday(idSubstring, targetDate = null) {
  try {
    // If targetDate is provided, use it; otherwise use today
    const date = targetDate
      ? moment(targetDate)
          .tz("Asia/Kuala_Lumpur")
          .startOf("day")
          .format("YYYY-MM-DD")
      : moment().tz("Asia/Kuala_Lumpur").startOf("day").format("YYYY-MM-DD");

    const result = await sql`
      SELECT
        phone as "phoneNumber",
        name as "contactName",
        created_at as "createdAt",
        tags
      FROM public.contacts
      WHERE company_id = ${idSubstring}
      AND DATE(created_at AT TIME ZONE 'UTC' AT TIME ZONE 'Asia/Kuala_Lumpur') = ${date}
    `;

    const contacts = result.map((contact) => ({
      phoneNumber: contact.phoneNumber,
      contactName: contact.contactName || "Unknown",
      createdAt: contact.createdAt.toISOString(),
      tags: contact.tags || [],
    }));

    return {
      count: contacts.length,
      contacts: contacts,
    };
  } catch (error) {
    console.error("Error getting contacts added today:", error);
    return { count: 0, contacts: [], error: error.message };
  }
}

app.get("/api/phone-status/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const result = await sqlDb.query(
      "SELECT phone_number, status, last_seen, metadata, updated_at FROM phone_status WHERE company_id = $1 ORDER BY phone_number ASC",
      [companyId]
    );
    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching phone statuses:", error);
    res.status(500).json({ error: "Failed to fetch phone statuses" });
  }
});

app.get("/api/instruction-templates", async (req, res) => {
  try {
    const { companyId } = req.query;
    if (!companyId) {
      return res
        .status(400)
        .json({ success: false, message: "Missing companyId" });
    }

    const result = await sqlDb.query(
      `SELECT id, name, instructions, created_at FROM instruction_templates WHERE company_id = $1 ORDER BY created_at DESC`,
      [companyId]
    );

    res.json({
      success: true,
      templates: result.rows,
    });
  } catch (error) {
    console.error("Error fetching instruction templates:", error);
    res.status(500).json({
      success: false,
      message: "Failed to fetch templates",
      details: error.message,
    });
  }
});

app.post("/api/instruction-templates", async (req, res) => {
  try {
    const { companyId, name, instructions } = req.body;

    if (!companyId || !name || !instructions) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, name, instructions)",
      });
    }

    const result = await sqlDb.query(
      `INSERT INTO instruction_templates (company_id, name, instructions)
       VALUES ($1, $2, $3)
       RETURNING id`,
      [companyId, name, instructions]
    );

    res.json({
      success: true,
      id: result.rows[0].id,
      message: "Template saved successfully",
    });
  } catch (error) {
    console.error("Error saving instruction template:", error);
    res.status(500).json({
      success: false,
      message: "Failed to save template",
      details: error.message,
    });
  }
});

async function fetchCompanyConfigSql(companyId) {
  try {
    const companyQuery = `
      SELECT 
      assistant_ids, 
      name, 
      phone_count, 
      phone_numbers
      FROM companies 
      WHERE company_id = $1
    `;
    const companyResult = await sqlDb.query(companyQuery, [companyId]);
    const companyData = companyResult.rows[0];

    if (!companyData) {
      return null;
    }

    let phoneNames = [];
    if (companyData.phone_numbers) {
      console.log("Parsing phone numbers:", companyData.phone_numbers);
      try {
        if (Array.isArray(companyData.phone_numbers)) {
          phoneNames = companyData.phone_numbers.map((phone) => phone.trim());
        } else if (typeof companyData.phone_numbers === "string") {
          phoneNames = companyData.phone_numbers
            .split(",")
            .map((phone) => phone.trim());
        } else {
          phoneNames = [];
        }
      } catch (e) {
        phoneNames = [];
      }
    }
    // Set phone1, phone2, phone3, phone4 from phoneNames array
    const phone1 = phoneNames[0] || null;
    const phone2 = phoneNames[1] || null;
    const phone3 = phoneNames[2] || null;
    const phone4 = phoneNames[3] || null;

    // Parse assistant_ids as array and set assistantId1, assistantId2, etc.
    let assistantIds = [];
    if (companyData.assistant_ids) {
      console.log("Parsing assistant IDs:", companyData.assistant_ids);
      try {
        if (Array.isArray(companyData.assistant_ids)) {
          assistantIds = companyData.assistant_ids.map((id) => id.trim());
        } else if (typeof companyData.assistant_ids === "string") {
          assistantIds = companyData.assistant_ids
            .split(",")
            .map((id) => id.trim());
        } else {
          assistantIds = [];
        }
      } catch (e) {
        assistantIds = [];
      }
    }
    const assistantId1 = assistantIds[0] || null;
    const assistantId2 = assistantIds[1] || null;
    const assistantId3 = assistantIds[2] || null;
    const assistantId4 = assistantIds[3] || null;

    // Get daily report settings from settings table
    const settingsQuery = `
      SELECT setting_value 
      FROM public.settings 
      WHERE company_id = $1 
      AND setting_type = 'reporting' 
      AND setting_key = 'dailyReport'
    `;
    const settingsResult = await sqlDb.query(settingsQuery, [companyId]);
    const dailyReportSettings =
      settingsResult.rows.length > 0
        ? settingsResult.rows[0].setting_value
        : null;

    const openaiTokenQuery =
      "SELECT config_value FROM system_config WHERE config_key = $1";
    const openaiTokenResult = await sqlDb.query(openaiTokenQuery, [
      "openai_api_key",
    ]);
    const openaiToken = openaiTokenResult.rows[0]?.config_value;

    return {
      companyData: {
        assistantId: assistantId1,
        assistantId2,
        assistantId3,
        assistantId4,
        name: companyData.name,
        phoneCount: parseInt(companyData.phone_count || "1"),
        phone1,
        phone2,
        phone3,
        phone4,
        ghl_accessToken: companyData.ghl_access_token,
        apiUrl: companyData.api_url,
        aiDelay: parseInt(companyData.ai_delay || "0"),
        aiAutoResponse: companyData.ai_auto_response === "true",
        dailyReport: dailyReportSettings,
      },
      openaiApiKey: openaiToken,
    };
  } catch (error) {
    console.error("Error fetching company config from SQL:", error);
    return null;
  }
}

async function fetchUserDataSql(email) {
  try {
    const query = "SELECT company_id, role FROM users WHERE email = $1";
    const { rows } = await sqlDb.query(query, [email]);
    return rows[0] || null; // Returns user data or null if not found
  } catch (error) {
    console.error(`Error fetching user data from SQL for ${email}:`, error);
    return null;
  }
}

app.get("/api/user-data/:email", async (req, res) => {
  try {
    const { email } = req.params;
    const userData = await fetchUserDataSql(email);
    if (userData) {
      res.json(userData);
    } else {
      res.status(404).json({ error: "User not found" });
    }
  } catch (error) {
    console.error("Error fetching user data:", error);
    res.status(500).json({ error: "Failed to fetch user data" });
  }
});

// PUT endpoint to update user data (specifically company_id)
app.put("/api/user-data/:userEmail", async (req, res) => {
  try {
    const { userEmail } = req.params;
    const { company_id } = req.body;

    if (!userEmail) {
      return res.status(400).json({ error: "User email is required" });
    }

    if (!company_id) {
      return res.status(400).json({ error: "Company ID is required" });
    }

    // Start transaction
    const client = await pool.connect();
    try {
      await client.query("BEGIN");

      // Update users table
      const userUpdateQuery = `
        UPDATE users 
        SET company_id = $1, last_updated = CURRENT_TIMESTAMP
        WHERE email = $2
        RETURNING email, company_id
      `;

      const userResult = await client.query(userUpdateQuery, [
        company_id,
        userEmail,
      ]);

      if (userResult.rows.length === 0) {
        await client.query("ROLLBACK");
        return res.status(404).json({ error: "User not found" });
      }

      // Update employees table if the user exists there
      const employeeUpdateQuery = `
        UPDATE employees 
        SET company_id = $1, last_updated = CURRENT_TIMESTAMP
        WHERE email = $2
      `;

      await client.query(employeeUpdateQuery, [company_id, userEmail]);

      await client.query("COMMIT");

      res.json({
        success: true,
        message: "User company ID updated successfully",
        data: {
          email: userResult.rows[0].email,
          company_id: userResult.rows[0].company_id,
        },
      });
    } catch (error) {
      await client.query("ROLLBACK");
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error updating user company ID:", error);
    res.status(500).json({ error: "Failed to update user company ID" });
  }
});

// New API endpoint to fetch employees data
app.get("/api/employees-data/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const employees = await fetchEmployeesDataSql(companyId);
    res.json(employees);
  } catch (error) {
    console.error("Error fetching employees data:", error);
    res.status(500).json({ error: "Failed to fetch employees data" });
  }
});

app.get("/api/company-config/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const config = await fetchCompanyConfigSql(companyId);

    if (config) {
      res.json(config);
    } else {
      res.status(404).json({ error: "Company configuration not found" });
    }
  } catch (error) {
    console.error("Error fetching company configuration:", error);
    res.status(500).json({ error: "Failed to fetch company configuration" });
  }
});
// Create an API endpoint to initialize automations
app.post("/api/initialize-automations", async (req, res) => {
  try {
    const automationPromises = initializeAutomations(botMap);
    await Promise.all(automationPromises);
    res.json({
      success: true,
      message: "Automations initialized successfully",
    });
  } catch (error) {
    console.error("Error initializing automations:", error);
    res.status(500).json({ error: "Failed to initialize automations" });
  }
});

async function fetchEmployeesDataSql(companyId) {
  try {
    const query =
      'SELECT id, employee_id, name, email, phone_number AS "phoneNumber", role FROM employees WHERE company_id = $1';
    const { rows } = await sqlDb.query(query, [companyId]);
    return rows;
  } catch (error) {
    console.error(
      `Error fetching employees data from SQL for company ${companyId}:`,
      error
    );
    return [];
  }
}

// New function to update monthly assignments in SQL
async function updateMonthlyAssignmentsSql(
  companyId,
  employeeName,
  incrementValue,
  contactId = null,
  assignmentType = "manual"
) {
  const client = await pool.connect(); // Get a client from the pool
  try {
    await client.query("BEGIN"); // Start transaction

    // 1. Get the employee's internal UUID 'id' and update assigned_contacts
    // We use 'name' for lookup because that's what 'employeeName' from Firebase 'doc.id' corresponds to.
    const employeeUpdateQuery = `
      UPDATE employees
      SET assigned_contacts = assigned_contacts + $1
      WHERE company_id = $2 AND name = $3
      RETURNING id;
    `;
    const employeeResult = await client.query(employeeUpdateQuery, [
      incrementValue,
      companyId,
      employeeName,
    ]);

    if (employeeResult.rows.length === 0) {
      throw new Error(
        `Employee '${employeeName}' not found for company '${companyId}'`
      );
    }

    const employeeId = employeeResult.rows[0].id; // This is the UUID 'id' from employees table

    // 2. Create assignment record if contactId is provided and incrementValue is positive
    if (contactId && incrementValue > 0) {
      const currentDate = new Date();
      const currentMonthKey = `${currentDate.getFullYear()}-${(
        currentDate.getMonth() + 1
      )
        .toString()
        .padStart(2, "0")}`;

      const assignmentId = `${companyId}-${contactId}-${employeeId}-${Date.now()}`;

      const assignmentInsertQuery = `
        INSERT INTO assignments (
          assignment_id, company_id, employee_id, contact_id, 
          assigned_at, status, month_key, assignment_type, 
          phone_index, weightage_used
        ) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, 'active', $5, $6, 0, 1)
      `;

      await client.query(assignmentInsertQuery, [
        assignmentId,
        companyId,
        employeeId,
        contactId,
        currentMonthKey,
        assignmentType,
      ]);
    }

    // 3. Update or insert monthly assignments
    const currentDate = new Date();
    const currentMonthKey = `${currentDate.getFullYear()}-${(
      currentDate.getMonth() + 1
    )
      .toString()
      .padStart(2, "0")}`;

    const monthlyAssignmentUpsertQuery = `
      INSERT INTO employee_monthly_assignments (employee_id, company_id, month_key, assignments_count, last_updated)
      VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP)
      ON CONFLICT (employee_id, month_key) DO UPDATE
      SET assignments_count = employee_monthly_assignments.assignments_count + $4,
          last_updated = CURRENT_TIMESTAMP;
    `;
    await client.query(monthlyAssignmentUpsertQuery, [
      employeeId,
      companyId,
      currentMonthKey,
      incrementValue,
    ]);

    await client.query("COMMIT"); // Commit transaction
    return { success: true };
  } catch (error) {
    await safeRollback(client); // Rollback on error
    console.error("Error in updateMonthlyAssignmentsSql transaction:", error);
    throw error; // Re-throw to be caught by the API endpoint
  } finally {
    await safeRelease(client); // Release client back to the pool
  }
}

// New API endpoint to update monthly assignments
app.post("/api/employees/update-monthly-assignments", async (req, res) => {
  try {
    const { companyId, employeeName, incrementValue } = req.body;
    await updateMonthlyAssignmentsSql(companyId, employeeName, incrementValue);
    res.json({
      success: true,
      message: "Monthly assignments updated successfully",
    });
  } catch (error) {
    console.error("Error updating monthly assignments:", error);
    res.status(500).json({ error: "Failed to update monthly assignments" });
  }
});

async function countContactsWithReplies(companyId) {
  try {
    // Find unique contact_ids for this company where there is at least one message from the contact (from_me = false)
    const query = `
      SELECT COUNT(DISTINCT contact_id) AS contacts_with_replies
      FROM messages
      WHERE company_id = $1 AND from_me = false
    `;
    const { rows } = await sqlDb.query(query, [companyId]);
    return rows[0]?.contacts_with_replies || 0;
  } catch (error) {
    console.error("Error counting contacts with replies:", error);
    return 0;
  }
}

// Function to get scheduled messages summary
async function getScheduledMessagesSummary(companyId) {
  const query = `
    SELECT 
      to_char(scheduled_time, 'Mon YYYY') AS month_key,
      status,
      COUNT(*) AS count
    FROM scheduled_messages
    WHERE company_id = $1
    GROUP BY month_key, status
    ORDER BY min(scheduled_time)
  `;
  const { rows } = await sqlDb.query(query, [companyId]);
  return rows;
}

app.get(
  "/api/companies/:companyId/scheduled-messages-summary",
  async (req, res) => {
    try {
      const { companyId } = req.params;
      const summary = await getScheduledMessagesSummary(companyId);
      res.json({ summary });
    } catch (error) {
      console.error("Error fetching scheduled messages summary:", error);
      res
        .status(500)
        .json({ error: "Failed to fetch scheduled messages summary" });
    }
  }
);

async function getMonthlyUsage(companyId) {
  const query = `
    SELECT 
      to_char(date, 'YYYY-MM') AS month,
      SUM(COALESCE((usage_count::int), 0)) AS total_tokens
    FROM usage_logs
    WHERE company_id = $1
    GROUP BY month
    ORDER BY month
  `;
  const { rows } = await sqlDb.query(query, [companyId]);
  return rows;
}

// Helper: Get employee stats from SQL
async function getEmployeeStats(companyId, employeeId) {
  // conversationsAssigned: assigned_contacts from employees
  // outgoingMessagesSent: count of messages from this employee (from_me = true, author = employee's email or id)
  // averageResponseTime: (optional, needs more logic)
  // closedContacts: count of contacts assigned to this employee with tag 'closed'
  // You may need to adjust queries based on your schema!

  // 1. Get employee info
  const empRes = await sqlDb.query(
    "SELECT id, email, assigned_contacts FROM employees WHERE company_id = $1 AND id = $2",
    [companyId, employeeId]
  );
  if (!empRes.rows.length) return null;
  const employee = empRes.rows[0];

  // 2. Outgoing messages sent
  const msgRes = await sqlDb.query(
    "SELECT COUNT(*) FROM messages WHERE company_id = $1 AND from_me = true AND author = $2",
    [companyId, employee.email]
  );
  const outgoingMessagesSent = parseInt(msgRes.rows[0].count, 10);

  // 3. Closed contacts (contacts assigned to this employee with tag 'closed')
  const closedRes = await sqlDb.query(
    `SELECT COUNT(*) FROM contacts 
    WHERE company_id = $1 
      AND tags::jsonb ? $2 
      AND tags::jsonb ? 'closed'`,
    [companyId, employee.name]
  );
  const closedContacts = parseInt(closedRes.rows[0].count, 10);

  // 4. (Optional) Average response time (not implemented here)
  const averageResponseTime = 0;

  return {
    conversationsAssigned: employee.assigned_contacts || 0,
    outgoingMessagesSent,
    averageResponseTime,
    closedContacts,
  };
}

app.get(
  "/api/companies/:companyId/employee-stats/:employeeId",
  async (req, res) => {
    try {
      const { companyId, employeeId } = req.params;
      const stats = await getEmployeeStats(companyId, employeeId);
      if (!stats) return res.status(404).json({ error: "Employee not found" });
      res.json(stats);
    } catch (error) {
      console.error("Error fetching employee stats:", error);
      res.status(500).json({ error: "Failed to fetch employee stats" });
    }
  }
);

app.delete(
  "/api/schedule-message/:companyId/contact/:contactId",
  async (req, res) => {
    try {
      const { companyId, contactId } = req.params;

      if (!companyId || !contactId) {
        return res.status(400).json({
          success: false,
          message: "Missing required fields (companyId, contactId)",
        });
      }

      // Delete scheduled messages for this contact in this company
      const result = await sqlDb.query(
        `DELETE FROM scheduled_messages WHERE company_id = $1 AND contact_id = $2 RETURNING id`,
        [companyId, contactId]
      );

      res.json({
        success: true,
        deletedCount: result.rowCount,
        message: `Deleted ${result.rowCount} scheduled message(s) for contact`,
      });
    } catch (error) {
      console.error("Error deleting scheduled messages for contact:", error);
      res.status(500).json({
        success: false,
        message: "Failed to delete scheduled messages",
        details: error.message,
      });
    }
  }
);

app.post("/api/contacts/bulk", async (req, res) => {
  try {
    const { contacts } = req.body;
    if (!Array.isArray(contacts) || contacts.length === 0) {
      return res
        .status(400)
        .json({ success: false, message: "No contacts provided" });
    }

    // Deduplicate contacts based on contact_id and company_id combination
    const uniqueContacts = [];
    const seenCombinations = new Set();

    for (const contact of contacts) {
      const key = `${contact.contact_id}-${contact.companyId}`;
      if (!seenCombinations.has(key)) {
        seenCombinations.add(key);
        uniqueContacts.push(contact);
      } else {
        console.log(
          `Skipping duplicate contact: ${contact.contact_id} for company: ${contact.companyId}`
        );
      }
    }

    if (uniqueContacts.length === 0) {
      return res.status(400).json({
        success: false,
        message: "No unique contacts to import after deduplication",
      });
    }

    console.log(
      `Original contacts: ${contacts.length}, Unique contacts: ${uniqueContacts.length}`
    );

    // Process contacts individually to avoid constraint violations
    const results = [];
    const errors = [];

    for (const contact of uniqueContacts) {
      try {
        const query = `
          INSERT INTO contacts (
            contact_id, company_id, name, last_name, email, phone, address1, company, location_id,
            created_at, unread_count, points, branch, expiry_date, vehicle_number, ic, chat_id, notes, custom_fields, tags
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20)
          ON CONFLICT (contact_id, company_id) DO UPDATE SET
            name = EXCLUDED.name,
            last_name = EXCLUDED.last_name,
            email = EXCLUDED.email,
            phone = EXCLUDED.phone,
            address1 = EXCLUDED.address1,
            company = EXCLUDED.company,
            location_id = EXCLUDED.location_id,
            unread_count = EXCLUDED.unread_count,
            points = EXCLUDED.points,
            branch = EXCLUDED.branch,
            expiry_date = EXCLUDED.expiry_date,
            vehicle_number = EXCLUDED.vehicle_number,
            ic = EXCLUDED.ic,
            chat_id = EXCLUDED.chat_id,
            notes = EXCLUDED.notes,
            custom_fields = EXCLUDED.custom_fields,
            tags = EXCLUDED.tags,
            updated_at = CURRENT_TIMESTAMP
          RETURNING contact_id
        `;

        const values = [
          contact.contact_id,
          contact.companyId,
          contact.name || contact.contactName || null,
          contact.last_name || contact.lastName || null,
          contact.email || null,
          contact.phone || null,
          contact.address1 || null,
          contact.companyName || null,
          contact.locationId || null,
          contact.dateAdded || new Date().toISOString(),
          contact.unreadCount || 0,
          contact.points || 0,
          contact.branch || null,
          contact.expiryDate || null,
          contact.vehicleNumber || null,
          contact.ic || null,
          contact.chat_id || null,
          contact.notes || null,
          // Handle customFields properly
          (() => {
            if (contact.customFields) {
              // If customFields is already an object, stringify it
              if (
                typeof contact.customFields === "object" &&
                contact.customFields !== null
              ) {
                return JSON.stringify(contact.customFields);
              } else if (typeof contact.customFields === "string") {
                // If it's already a string, use it as is
                return contact.customFields;
              }
            }
            return null;
          })(),
          contact.tags ? JSON.stringify(contact.tags) : null,
        ];

        const result = await sqlDb.query(query, values);
        results.push(result.rows[0].contact_id);
      } catch (error) {
        console.error(`Error importing contact ${contact.contact_id}:`, error);
        errors.push({
          contact_id: contact.contact_id,
          error: error.message,
        });
      }
    }

    res.json({
      success: true,
      imported: results.length,
      contact_ids: results,
      original_count: contacts.length,
      unique_count: uniqueContacts.length,
      duplicates_removed: contacts.length - uniqueContacts.length,
      errors: errors.length > 0 ? errors : undefined,
    });
  } catch (error) {
    console.error("Error importing contacts in bulk:", error);
    res.status(500).json({
      success: false,
      message: "Failed to import contacts",
      details: error.message,
    });
  }
});

app.put("/api/contacts/:contact_id", async (req, res) => {
  try {
    const { contact_id } = req.params;
    const {
      companyId,
      name,
      lastName,
      email,
      phone,
      address1,
      city,
      state,
      postalCode,
      website,
      dnd,
      dndSettings,
      tags,
      source,
      country,
      companyName,
      branch,
      expiryDate,
      vehicleNumber,
      points,
      IC,
      assistantId,
      threadid,
      notes,
      customFields, // This should be an object if present
    } = req.body;
    console.log("req.body:", req.body);
    if (!companyId || !contact_id) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, contact_id)",
      });
    }

    // Build the update query dynamically
    const setFields = [];
    const setValues = [];
    let idx = 1;

    // Standard fields
    const fieldMap = {
      name: name, // <-- changed from contact_name to name
      last_name: lastName,
      email,
      phone,
      address1,
      city,
      state,
      postal_code: postalCode,
      website,
      dnd,
      dnd_settings: dndSettings,
      tags: tags ? JSON.stringify(tags) : undefined,
      source,
      country,
      company: companyName,
      branch,
      expiry_date: expiryDate,
      vehicle_number: vehicleNumber,
      points,
      ic: IC,
      assistant_id: assistantId,
      threadid,
      notes,
    };

    for (const [col, val] of Object.entries(fieldMap)) {
      if (val !== undefined) {
        setFields.push(`${col} = $${idx++}`);
        setValues.push(val);
      }
    }

    // Custom fields
    if (customFields && Object.keys(customFields).length > 0) {
      setFields.push(`custom_fields = $${idx++}`);
      setValues.push(JSON.stringify(customFields));
    }

    setFields.push(`updated_at = CURRENT_TIMESTAMP`);

    // Add WHERE values at the end
    setValues.push(contact_id); // $idx
    setValues.push(companyId); // $idx+1

    const query = `
      UPDATE contacts
      SET ${setFields.join(", ")}
      WHERE contact_id = $${idx++} AND company_id = $${idx}
      RETURNING contact_id
    `;

    const result = await sqlDb.query(query, setValues);

    if (result.rows.length === 0) {
      return res
        .status(404)
        .json({ success: false, message: "Contact not found" });
    }

    res.json({
      success: true,
      contact_id: result.rows[0].contact_id,
      message: "Contact updated successfully",
    });
  } catch (error) {
    console.error("Error updating contact:", error);
    res.status(500).json({
      success: false,
      message: "Failed to update contact",
      details: error.message,
    });
  }
});

app.put("/api/contacts/:contact_id/pinned", async (req, res) => {
  try {
    const { contact_id } = req.params;
    const { companyId, pinned } = req.body;

    console.log("Toggle pin request:", { contact_id, companyId, pinned });

    if (!companyId || !contact_id || typeof pinned !== "boolean") {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, contact_id, pinned)",
      });
    }

    // First check if contact exists and get current pinned status
    const checkQuery = `
      SELECT contact_id, pinned FROM contacts 
      WHERE contact_id = $1 AND company_id = $2
    `;
    const checkResult = await sqlDb.query(checkQuery, [contact_id, companyId]);

    if (checkResult.rows.length === 0) {
      console.log("Contact not found:", { contact_id, companyId });
      return res.status(404).json({
        success: false,
        message: "Contact not found",
      });
    }

    console.log("Current pinned status:", checkResult.rows[0].pinned);
    console.log("New pinned status:", pinned);

    // Update the pinned status
    const updateQuery = `
      UPDATE contacts
      SET pinned = $1, updated_at = CURRENT_TIMESTAMP
      WHERE contact_id = $2 AND company_id = $3
      RETURNING contact_id, pinned, updated_at
    `;

    const result = await sqlDb.query(updateQuery, [
      pinned,
      contact_id,
      companyId,
    ]);

    if (result.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: "Contact not found",
      });
    }

    console.log("Update result:", result.rows[0]);

    // Verify the update immediately
    const verifyQuery = `
      SELECT contact_id, pinned, updated_at FROM contacts 
      WHERE contact_id = $1 AND company_id = $2
    `;
    const verifyResult = await sqlDb.query(verifyQuery, [
      contact_id,
      companyId,
    ]);

    console.log("After update verification:", verifyResult.rows[0]);

    res.json({
      success: true,
      contact_id: verifyResult.rows[0].contact_id,
      pinned: verifyResult.rows[0].pinned,
      updated_at: verifyResult.rows[0].updated_at,
      message: "Pinned status updated successfully",
    });
  } catch (error) {
    console.error("Error updating pinned status:", error);
    res.status(500).json({
      success: false,
      message: "Failed to update pinned status",
      details: error.message,
    });
  }
});

// Mass delete contacts endpoint
app.delete("/api/contacts/mass-delete", async (req, res) => {
  try {
    const { contactIds, companyId } = req.body;

    if (
      !companyId ||
      !contactIds ||
      !Array.isArray(contactIds) ||
      contactIds.length === 0
    ) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, contactIds array)",
        debug: {
          companyId: !!companyId,
          contactIds: !!contactIds,
          isArray: Array.isArray(contactIds),
          length: contactIds ? contactIds.length : 0,
          receivedBody: req.body,
        },
      });
    }

    const client = await getDatabaseConnection();
    if (!client) {
      return res.status(500).json({
        success: false,
        message: "Failed to get database connection",
      });
    }

    let deletedCount = 0;
    const failures = [];

    try {
      await client.query("BEGIN");

      for (const contactId of contactIds) {
        try {
          // First, verify the contact exists
          const contactCheck = await client.query(
            `SELECT contact_id, phone, tags FROM contacts WHERE contact_id = $1 AND company_id = $2`,
            [contactId, companyId]
          );

          if (contactCheck.rows.length === 0) {
            failures.push({ contactId, reason: "Contact not found" });
            continue;
          }

          const contact = contactCheck.rows[0];

          // Get all assignments for this contact to update employee counts
          const assignmentsResult = await client.query(
            `SELECT DISTINCT employee_id FROM assignments WHERE company_id = $1 AND contact_id = $2`,
            [companyId, contactId]
          );

          // Update employees' assigned_contacts count
          for (const assignment of assignmentsResult.rows) {
            await client.query(
              `UPDATE employees 
               SET assigned_contacts = GREATEST(assigned_contacts - 1, 0)
               WHERE company_id = $1 AND employee_id = $2`,
              [companyId, assignment.employee_id]
            );
          }

          // Delete all assignments for this contact
          await client.query(
            `DELETE FROM assignments WHERE company_id = $1 AND contact_id = $2`,
            [companyId, contactId]
          );

          // Delete all messages for this contact
          await client.query(
            `DELETE FROM messages WHERE company_id = $1 AND contact_id = $2`,
            [companyId, contactId]
          );

          // Delete all scheduled messages for this contact
          await client.query(
            `DELETE FROM scheduled_messages WHERE company_id = $1 AND contact_id = $2`,
            [companyId, contactId]
          );

          // Delete the contact
          const contactDeleted = await client.query(
            `DELETE FROM contacts WHERE contact_id = $1 AND company_id = $2 RETURNING contact_id`,
            [contactId, companyId]
          );

          if (contactDeleted.rowCount > 0) {
            deletedCount++;
          } else {
            failures.push({ contactId, reason: "Failed to delete contact" });
          }
        } catch (contactError) {
          console.error(`Error deleting contact ${contactId}:`, contactError);
          failures.push({ contactId, reason: contactError.message });
        }
      }

      await client.query("COMMIT");

      res.json({
        success: true,
        message: `Mass deletion completed. ${deletedCount} contacts deleted successfully.`,
        deletedCount,
        totalRequested: contactIds.length,
        failures: failures.length > 0 ? failures : undefined,
      });
    } catch (error) {
      await safeRollback(client);
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error in mass delete contacts:", error);
    res.status(500).json({
      success: false,
      message: "Failed to mass delete contacts",
      details: error.message,
    });
  }
});

app.delete("/api/contacts/:contact_id", async (req, res) => {
  try {
    const { contact_id } = req.params;
    const { companyId } = req.query;

    if (!companyId || !contact_id) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, contact_id)",
      });
    }

    // Check if contact has any assignments that would prevent deletion
    const assignmentsCheck = await sqlDb.query(
      `SELECT COUNT(*) as assignment_count FROM assignments WHERE contact_id = $1 AND company_id = $2`,
      [contact_id, companyId]
    );

    if (parseInt(assignmentsCheck.rows[0].assignment_count) > 0) {
      return res.status(409).json({
        success: false,
        message:
          "Cannot delete contact: Contact has active assignments. Use /api/assignments/contact/{contactId} to remove assignments first, or use /api/contacts/{contactId}/force for force deletion.",
        details: {
          assignmentCount: parseInt(assignmentsCheck.rows[0].assignment_count),
          suggestion:
            "Use DELETE /api/assignments/contact/{contactId}?companyId={companyId} to remove assignments first",
        },
      });
    }

    // Check if contact has any messages
    const messagesCheck = await sqlDb.query(
      `SELECT COUNT(*) as message_count FROM messages WHERE contact_id = $1 AND company_id = $2`,
      [contact_id, companyId]
    );

    if (parseInt(messagesCheck.rows[0].message_count) > 0) {
      return res.status(409).json({
        success: false,
        message:
          "Cannot delete contact: Contact has associated messages. Use /api/contacts/{contactId}/force for force deletion.",
        details: {
          messageCount: parseInt(messagesCheck.rows[0].message_count),
          suggestion:
            "Use DELETE /api/contacts/{contactId}/force?companyId={companyId} for force deletion",
        },
      });
    }

    // Delete scheduled messages for this contact
    await sqlDb.query(
      `DELETE FROM scheduled_messages WHERE company_id = $1 AND contact_id = $2`,
      [companyId, contact_id]
    );

    // Delete the contact
    const result = await sqlDb.query(
      `DELETE FROM contacts WHERE contact_id = $1 AND company_id = $2 RETURNING contact_id`,
      [contact_id, companyId]
    );

    if (result.rows.length === 0) {
      return res
        .status(404)
        .json({ success: false, message: "Contact not found" });
    }

    res.json({
      success: true,
      contact_id: result.rows[0].contact_id,
      message: "Contact deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting contact:", error);
    res.status(500).json({
      success: false,
      message: "Failed to delete contact",
      details: error.message,
    });
  }
});

// New endpoint: Delete all assignments for a specific contact
app.delete("/api/assignments/contact/:contactId", async (req, res) => {
  try {
    const { contactId } = req.params;
    const { companyId } = req.query;

    if (!companyId || !contactId) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, contactId)",
      });
    }

    const client = await getDatabaseConnection();
    if (!client) {
      return res.status(500).json({
        success: false,
        message: "Failed to get database connection",
      });
    }

    try {
      await client.query("BEGIN");

      // First, verify the contact exists
      const contactCheck = await client.query(
        `SELECT contact_id, phone, tags FROM contacts WHERE contact_id = $1 AND company_id = $2`,
        [contactId, companyId]
      );

      if (contactCheck.rows.length === 0) {
        await safeRollback(client);
        return res.status(404).json({
          success: false,
          message: "Contact not found",
        });
      }

      const contact = contactCheck.rows[0];

      // Get all assignments for this contact
      const assignmentsResult = await client.query(
        `SELECT a.assignment_id, a.employee_id, e.name, e.id as employee_uuid
         FROM assignments a
         JOIN employees e ON a.employee_id = e.employee_id
         WHERE a.company_id = $1 AND a.contact_id = $2`,
        [companyId, contactId]
      );

      if (assignmentsResult.rows.length === 0) {
        await safeRollback(client);
        return res.status(404).json({
          success: false,
          message: "No assignments found for this contact",
        });
      }

      const assignments = assignmentsResult.rows;
      const employeeNames = assignments.map((emp) => emp.name);

      // Remove employee names from contact tags - handle JSON parsing safely
      let currentTags = [];
      try {
        if (contact.tags) {
          // If tags is already an array, use it directly
          if (Array.isArray(contact.tags)) {
            currentTags = contact.tags;
          } else if (typeof contact.tags === "string") {
            // If tags is a string, try to parse it as JSON
            currentTags = JSON.parse(contact.tags);
          }
        }
      } catch (parseError) {
        console.warn(
          `Failed to parse tags for contact ${contactId}:`,
          parseError
        );
        currentTags = [];
      }

      const updatedTags = currentTags.filter(
        (tag) => !employeeNames.includes(tag)
      );

      await client.query(
        `UPDATE contacts SET tags = $3 WHERE contact_id = $1 AND company_id = $2`,
        [contactId, companyId, JSON.stringify(updatedTags)]
      );

      // Update employees' assigned_contacts count
      for (const assignment of assignments) {
        await client.query(
          `UPDATE employees 
           SET assigned_contacts = GREATEST(assigned_contacts - 1, 0)
           WHERE company_id = $1 AND employee_id = $2`,
          [companyId, assignment.employee_id]
        );
      }

      // Delete all assignments for this contact
      const deleteResult = await client.query(
        `DELETE FROM assignments WHERE company_id = $1 AND contact_id = $2 RETURNING assignment_id`,
        [companyId, contactId]
      );

      await client.query("COMMIT");

      res.json({
        success: true,
        message: `Successfully removed ${deleteResult.rowCount} assignment(s) for contact`,
        deletedAssignments: deleteResult.rowCount,
        contactId: contactId,
        updatedTags: updatedTags,
      });
    } catch (error) {
      await safeRollback(client);
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error deleting contact assignments:", error);
    res.status(500).json({
      success: false,
      message: "Failed to delete contact assignments",
      details: error.message,
    });
  }
});

// New endpoint: Force delete contact with cascade deletion
app.delete("/api/contacts/:contactId/force", async (req, res) => {
  try {
    const { contactId } = req.params;
    const { companyId } = req.query;

    if (!companyId || !contactId) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, contactId)",
      });
    }

    const client = await getDatabaseConnection();
    if (!client) {
      return res.status(500).json({
        success: false,
        message: "Failed to get database connection",
      });
    }

    try {
      await client.query("BEGIN");

      // First, verify the contact exists
      const contactCheck = await client.query(
        `SELECT contact_id, phone, tags FROM contacts WHERE contact_id = $1 AND company_id = $2`,
        [contactId, companyId]
      );

      if (contactCheck.rows.length === 0) {
        await safeRollback(client);
        return res.status(404).json({
          success: false,
          message: "Contact not found",
        });
      }

      const contact = contactCheck.rows[0];

      // Get all assignments for this contact to update employee counts
      const assignmentsResult = await client.query(
        `SELECT DISTINCT employee_id FROM assignments WHERE company_id = $1 AND contact_id = $2`,
        [companyId, contactId]
      );

      // Update employees' assigned_contacts count
      for (const assignment of assignmentsResult.rows) {
        await client.query(
          `UPDATE employees 
           SET assigned_contacts = GREATEST(assigned_contacts - 1, 0)
           WHERE company_id = $1 AND employee_id = $2`,
          [companyId, assignment.employee_id]
        );
      }

      // Delete all assignments for this contact
      const assignmentsDeleted = await client.query(
        `DELETE FROM assignments WHERE company_id = $1 AND contact_id = $2`,
        [companyId, contactId]
      );

      // Delete all messages for this contact
      const messagesDeleted = await client.query(
        `DELETE FROM messages WHERE company_id = $1 AND contact_id = $2`,
        [companyId, contactId]
      );

      // Delete all scheduled messages for this contact
      const scheduledMessagesDeleted = await client.query(
        `DELETE FROM scheduled_messages WHERE company_id = $1 AND contact_id = $2`,
        [companyId, contactId]
      );

      // Delete the contact
      const contactDeleted = await client.query(
        `DELETE FROM contacts WHERE contact_id = $1 AND company_id = $2 RETURNING contact_id`,
        [contactId, companyId]
      );

      await client.query("COMMIT");

      res.json({
        success: true,
        message: "Contact force deleted successfully with all related data",
        contactId: contactId,
        deletedData: {
          assignments: assignmentsDeleted.rowCount,
          messages: messagesDeleted.rowCount,
          scheduledMessages: scheduledMessagesDeleted.rowCount,
          contact: contactDeleted.rowCount,
        },
      });
    } catch (error) {
      await safeRollback(client);
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error force deleting contact:", error);
    res.status(500).json({
      success: false,
      message: "Failed to force delete contact",
      details: error.message,
    });
  }
});

app.post("/api/contacts", async (req, res) => {
  try {
    // Extract important fields
    let {
      contact_id,
      companyId,
      contactName,
      name,
      phone,
      chat_id,
      tags,
      unreadCount,
      ...additionalFields
    } = req.body;

    // Fallbacks and normalization
    if (!contact_id && companyId && phone) {
      // If contact_id not provided, generate from companyId and phone
      const formattedPhone = phone.startsWith("+") ? phone.slice(1) : phone;
      contact_id = `${companyId}-${formattedPhone}`;
    }
    if (!companyId || !phone || !contact_id) {
      return res.status(400).json({
        success: false,
        message: "Missing required fields (companyId, phone, contact_id)",
      });
    }

    // Format phone to always have + and only digits
    let formattedPhone = phone.replace(/\D/g, "");
    if (!formattedPhone.startsWith("6")) {
      formattedPhone = "6" + formattedPhone;
    }
    formattedPhone = "+" + formattedPhone;

    // Use contactName or name or fallback to formattedPhone
    const finalName = contactName || name || formattedPhone;

    // Get all columns in the contacts table
    const tableColumnsResult = await sqlDb.query(`
      SELECT column_name FROM information_schema.columns
      WHERE table_name = 'contacts'
    `);
    const tableColumns = tableColumnsResult.rows.map((r) => r.column_name);

    // Helper to convert camelCase to snake_case
    function camelToSnake(str) {
      return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
    }

    // Prepare custom_fields object
    let customFields = {};
    let standardFields = {};

    for (const [key, value] of Object.entries(additionalFields)) {
      // Convert camelCase to snake_case for checking
      const snakeKey = camelToSnake(key);
      if (tableColumns.includes(snakeKey)) {
        standardFields[snakeKey] = value;
      } else if (tableColumns.includes(key)) {
        standardFields[key] = value;
      } else {
        // Store in custom_fields as snake_case
        customFields[snakeKey] = value;
      }
    }

    // Prepare contact data with required fields
    const contactData = {
      contact_id,
      company_id: companyId,
      name: finalName,
      phone: formattedPhone,
      chat_id: chat_id || null,
      tags: Array.isArray(tags) ? tags : [],
      unread_count: typeof unreadCount === "number" ? unreadCount : 0,
      created_at: new Date(),
      updated_at: new Date(),
      ...standardFields,
    };

    // Merge/append custom_fields if present
    if (Object.keys(customFields).length > 0) {
      contactData.custom_fields = customFields;
    }

    // Remove undefined values (so only provided fields are inserted/updated)
    Object.keys(contactData).forEach(
      (key) => contactData[key] === undefined && delete contactData[key]
    );

    // Build dynamic insert/update query for only present fields
    const fields = Object.keys(contactData);
    const values = Object.values(contactData);
    const placeholders = fields.map((_, i) => `$${i + 1}`);

    // Build ON CONFLICT update set clause
    const updateSet = fields
      .filter(
        (f) =>
          f !== "contact_id" &&
          f !== "company_id" &&
          f !== "created_at" &&
          f !== "updated_at"
      )
      .map((f) => `${f} = EXCLUDED.${f}`)
      .join(", ");

    const query = `
      INSERT INTO contacts (${fields.join(", ")})
      VALUES (${placeholders.join(", ")})
      ON CONFLICT (contact_id, company_id) DO UPDATE
      SET ${updateSet}${updateSet ? ", " : ""}updated_at = CURRENT_TIMESTAMP
      RETURNING contact_id
    `;

    const result = await sqlDb.query(query, values);

    res.json({
      success: true,
      contact_id: result.rows[0].contact_id,
      message: "Contact added successfully",
    });
  } catch (error) {
    console.error("Error adding contact:", error);
    res.status(500).json({
      success: false,
      message: "Failed to add contact",
      details: error.message,
    });
  }
});

app.get("/api/contacts-data/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const query = "SELECT id, tags FROM contacts WHERE company_id = $1";
    const { rows } = await sqlDb.query(query, [companyId]);
    res.json(rows);
  } catch (error) {
    console.error("Error fetching contacts data:", error);
    res.status(500).json({ error: "Failed to fetch contacts data" });
  }
});

app.get("/api/companies/:companyId/monthly-usage", async (req, res) => {
  try {
    const { companyId } = req.params;
    const usage = await getMonthlyUsage(companyId);
    res.json({ usage });
  } catch (error) {
    console.error("Error fetching monthly usage:", error);
    res.status(500).json({ error: "Failed to fetch monthly usage" });
  }
});

// API endpoint
app.get("/api/companies/:companyId/replies", async (req, res) => {
  try {
    const { companyId } = req.params;
    const contactsWithReplies = await countContactsWithReplies(companyId);
    res.json({ contactsWithReplies });
  } catch (error) {
    console.error("Error in /api/companies/:companyId/replies:", error);
    res.status(500).json({ error: "Failed to fetch contacts with replies" });
  }
});

app.post("/api/bots/reinitialize", async (req, res) => {
  try {
    const { botName, phoneIndex } = req.body;

    if (!botName) {
      return res.status(400).json({ error: "botName is required" });
    }

    console.log(
      `[REINITIALIZE] Request received for bot: ${botName}, phoneIndex: ${phoneIndex}`
    );

    let phoneCount = 1;
    try {
      const result = await sqlDb.query(
        `SELECT phone_count FROM companies WHERE company_id = $1`,
        [botName]
      );

      if (result.rows.length > 0) {
        phoneCount = result.rows[0].phone_count || 1;
      }
    } catch (error) {
      console.error(`Error getting phone count for ${botName}:`, error);
    }

    console.log(`[REINITIALIZE] Phone count for ${botName}: ${phoneCount}`);

    // Send immediate response to prevent frontend timeout
    res.json({
      success: true,
      message: `Reinitialization started for ${
        phoneIndex !== undefined ? `Phone ${phoneIndex + 1}` : "Bot"
      }`,
      phoneCount,
      phoneIndex,
    });

    console.log(
      `[REINITIALIZE] Response sent, starting async reinitialization...`
    );

    // Do the actual reinitialization asynchronously
    const reinitializeAsync = async () => {
      try {
        const botData = botMap.get(botName);
        let sessionsCleaned = false;

        console.log(
          `[REINITIALIZE] Starting client destruction for ${botName}`
        );

        try {
          if (botData && Array.isArray(botData)) {
            if (phoneIndex !== undefined) {
              if (botData[phoneIndex]?.client) {
                try {
                  await destroyClient(botData[phoneIndex].client);
                  botData[phoneIndex] = {
                    client: null,
                    status: "initializing",
                    qrCode: null,
                    initializationStartTime: Date.now(),
                  };
                  console.log(
                    `[REINITIALIZE] Client destroyed for ${botName} phone ${phoneIndex}`
                  );
                } catch (error) {
                  console.error(
                    `Error destroying client for ${botName} phone ${phoneIndex}:`,
                    error
                  );
                }
              }
            } else {
              await Promise.all(
                botData.map(async (data, index) => {
                  if (data?.client) {
                    try {
                      await destroyClient(data.client);
                      botData[index] = {
                        client: null,
                        status: "initializing",
                        qrCode: null,
                        initializationStartTime: Date.now(),
                      };
                      console.log(
                        `[REINITIALIZE] Client destroyed for ${botName} phone ${index}`
                      );
                    } catch (error) {
                      console.error(
                        `Error destroying client for ${botName} phone ${index}:`,
                        error
                      );
                    }
                  }
                })
              );
            }
          }

          console.log(
            `[REINITIALIZE] Waiting 2 seconds before initialization...`
          );
          await new Promise((resolve) => setTimeout(resolve, 2000));

          console.log(
            `[REINITIALIZE] Starting bot initialization for ${botName}`
          );
          if (phoneIndex !== undefined) {
            await initializeBot(botName, phoneCount, phoneIndex);
          } else {
            await initializeBot(botName, phoneCount);
          }
          console.log(
            `[REINITIALIZE] Bot initialization completed for ${botName}`
          );
        } catch (initError) {
          console.error(
            `Initial reinitialization failed for ${botName}, cleaning sessions and retrying...`,
            initError
          );

          if (phoneIndex !== undefined) {
            sessionsCleaned = await safeCleanup(botName, phoneIndex);
          } else {
            const cleanResults = await Promise.all(
              Array.from({ length: phoneCount }, (_, i) =>
                safeCleanup(botName, i)
              )
            );
            sessionsCleaned = cleanResults.some((result) => result);
          }

          console.log(
            `[REINITIALIZE] Session cleanup completed, waiting before retry...`
          );
          await new Promise((resolve) =>
            setTimeout(resolve, sessionsCleaned ? 5000 : 2000)
          );

          console.log(
            `[REINITIALIZE] Retrying bot initialization for ${botName}`
          );
          if (phoneIndex !== undefined) {
            await initializeBot(botName, phoneCount, phoneIndex);
          } else {
            await initializeBot(botName, phoneCount);
          }
          console.log(
            `[REINITIALIZE] Retry initialization completed for ${botName}`
          );
        }

        console.log(
          `[REINITIALIZE] Async reinitialization completed successfully for ${botName}`
        );
      } catch (error) {
        console.error(
          `[REINITIALIZE] Async reinitialization failed for ${botName}:`,
          error
        );
      }
    };

    // Start async reinitialization (no await)
    reinitializeAsync();
  } catch (error) {
    console.error("Error in reinitialize endpoint:", error);
    res.status(500).json({
      error: "Failed to start reinitialization",
      details: error.message,
    });
  }
});

// Disconnect phone endpoint
app.post("/api/bots/:botName/disconnect", async (req, res) => {
  try {
    const { botName } = req.params;
    const { phoneIndex } = req.body;

    if (!botName) {
      return res.status(400).json({ error: "botName is required" });
    }

    const botData = botMap.get(botName);

    if (!botData || !Array.isArray(botData)) {
      return res.status(404).json({ error: "Bot not found" });
    }

    if (phoneIndex !== undefined) {
      // Disconnect specific phone
      if (
        phoneIndex >= 0 &&
        phoneIndex < botData.length &&
        botData[phoneIndex]?.client
      ) {
        try {
          await logoutClient(botData[phoneIndex].client);
          botData[phoneIndex] = {
            client: null,
            status: "disconnected",
            qrCode: null,
            initializationStartTime: null,
          };

          // Broadcast the disconnection status
          broadcastAuthStatus(botName, "disconnected", null, phoneIndex);

          // Reinitialize the client to generate new QR code
          try {
            await initializeBot(botName, 1, phoneIndex);
          } catch (reinitError) {
            console.error(
              `Error reinitializing ${botName} phone ${phoneIndex} after logout:`,
              reinitError
            );
          }

          res.json({
            success: true,
            message: `Phone ${
              phoneIndex + 1
            } disconnected and reinitialized successfully`,
            phoneIndex,
          });
        } catch (error) {
          console.error(
            `Error disconnecting ${botName} phone ${phoneIndex}:`,
            error
          );
          res.status(500).json({
            error: "Failed to disconnect phone",
            details: error.message,
          });
        }
      } else {
        res
          .status(400)
          .json({ error: "Invalid phone index or phone not connected" });
      }
    } else {
      // Disconnect all phones
      try {
        const totalPhones = botData.length; // Get the actual phone count from botData

        await Promise.all(
          botData.map(async (data, index) => {
            if (data?.client) {
              try {
                await logoutClient(data.client);
                botData[index] = {
                  client: null,
                  status: "disconnected",
                  qrCode: null,
                  initializationStartTime: null,
                };
                broadcastAuthStatus(botName, "disconnected", null, index);
              } catch (error) {
                console.error(
                  `Error disconnecting ${botName} phone ${index}:`,
                  error
                );
              }
            }
          })
        );

        // Reinitialize all phones after disconnection
        try {
          await initializeBot(botName, totalPhones);
        } catch (reinitError) {
          console.error(
            `Error reinitializing ${botName} with ${totalPhones} phones after logout:`,
            reinitError
          );
        }

        res.json({
          success: true,
          message: `All ${totalPhones} phones disconnected and reinitialized successfully`,
        });
      } catch (error) {
        console.error(`Error disconnecting all phones for ${botName}:`, error);
        res.status(500).json({
          error: "Failed to disconnect all phones",
          details: error.message,
        });
      }
    }
  } catch (error) {
    console.error("Error in disconnect endpoint:", error);
    res.status(500).json({
      error: "Failed to disconnect bot",
      details: error.message,
    });
  }
});

// Delete company endpoint
app.delete("/api/companies/:companyId", async (req, res) => {
  let client;
  try {
    const { companyId } = req.params;

    if (!companyId) {
      return res.status(400).json({ error: "companyId is required" });
    }

    console.log(`[DELETE COMPANY] Request received for company: ${companyId}`);

    // Get database connection
    client = await pool.connect();

    // First, check if the company exists
    const checkCompanyQuery =
      "SELECT company_id, name FROM companies WHERE company_id = $1";
    const companyResult = await client.query(checkCompanyQuery, [companyId]);

    if (companyResult.rows.length === 0) {
      return res.status(404).json({
        error: "Company not found",
        companyId,
      });
    }

    const companyName = companyResult.rows[0].name;

    // Disconnect and cleanup bot data if it exists
    const botData = botMap.get(companyId);
    if (botData && Array.isArray(botData)) {
      console.log(
        `[DELETE COMPANY] Disconnecting ${botData.length} phones for company ${companyId}`
      );

      // Disconnect all phones
      await Promise.all(
        botData.map(async (data, index) => {
          if (data?.client) {
            try {
              await logoutClient(data.client);
              console.log(
                `[DELETE COMPANY] Disconnected phone ${index} for company ${companyId}`
              );
            } catch (error) {
              console.error(
                `[DELETE COMPANY] Error disconnecting phone ${index} for company ${companyId}:`,
                error
              );
            }
          }
        })
      );

      // Remove from botMap
      botMap.delete(companyId);
      console.log(`[DELETE COMPANY] Removed company ${companyId} from botMap`);
    }

    // Delete the company from database (CASCADE will handle related records)
    const deleteQuery = "DELETE FROM companies WHERE company_id = $1";
    const deleteResult = await client.query(deleteQuery, [companyId]);

    if (deleteResult.rowCount === 0) {
      return res.status(404).json({
        error: "Company not found in database",
        companyId,
      });
    }

    console.log(
      `[DELETE COMPANY] Successfully deleted company ${companyId} (${companyName}) and all related data`
    );

    res.json({
      success: true,
      message: `Company ${companyId} (${companyName}) and all related data deleted successfully`,
      companyId,
      companyName,
    });
  } catch (error) {
    console.error(
      `[DELETE COMPANY] Error deleting company ${req.params.companyId}:`,
      error
    );
    res.status(500).json({
      error: "Failed to delete company",
      details: error.message,
      companyId: req.params.companyId,
    });
  } finally {
    if (client) {
      client.release();
    }
  }
});

async function logoutClient(client) {
  if (client) {
    try {
      await client.logout();
      console.log("Client logged out successfully");
    } catch (error) {
      console.error("Error logging out client:", error);
    }
  }
}

// Get all bot statuses for status page
app.get("/api/bot-statuses", async (req, res) => {
  let client;
  try {
    client = await pool.connect();

    // Get all companies with v2 = true
    const botsQuery = `
      SELECT 
      c.company_id AS id,
      c.name,
      c.phone_count AS "phoneCount",
      c.category,
      ARRAY(
        SELECT e.email 
        FROM employees e 
        WHERE e.company_id = c.company_id AND e.email IS NOT NULL
      ) AS "employeeEmails"
      FROM companies c
      WHERE c.v2 = true
      AND c.api_url = $1
      ORDER BY c.company_id
    `;

    const companiesResult = await client.query(botsQuery, [process.env.URL]);
    console.log("Fetched companies:", companiesResult.rows.length);
    console.log("url:", process.env.URL);
    console.log("Companies result:", companiesResult);

    // Get status for each bot
    const botStatuses = await Promise.all(
      companiesResult.rows.map(async (company) => {
        const phoneCount = company.phoneCount || 1;
        const phoneStatuses = [];

        // Get status for each phone
        for (let i = 0; i < phoneCount; i++) {
          let status = "unknown";
          let phoneNumber = null;

          try {
            // Check if bot is in memory
            const botData = botMap.get(company.id);
            if (botData && Array.isArray(botData) && botData[i]) {
              status = botData[i].status || "unknown";

              // Try to get phone number from client info
              if (botData[i].client) {
                try {
                  const info = await botData[i].client.info;
                  phoneNumber = info?.wid?.user || null;
                } catch (err) {
                  // Ignore error
                }
              }
            }

            // Also check database status
            const dbStatusQuery = `
              SELECT status, phone_number 
              FROM phone_status 
              WHERE company_id = $1 AND phone_index = $2 
              ORDER BY updated_at DESC 
              LIMIT 1
            `;
            const dbResult = await client.query(dbStatusQuery, [company.id, i]);

            if (dbResult.rows.length > 0) {
              const dbStatus = dbResult.rows[0].status;
              const dbPhoneNumber = dbResult.rows[0].phone_number;

              // Use database status if more recent or if in-memory status is unknown
              if (status === "unknown" || dbStatus) {
                status = dbStatus;
              }

              if (!phoneNumber && dbPhoneNumber) {
                phoneNumber = dbPhoneNumber;
              }
            }
          } catch (error) {
            console.error(
              `Error getting status for ${company.id} phone ${i}:`,
              error
            );
          }

          phoneStatuses.push({
            phoneIndex: i,
            status: status || "unknown",
            phoneNumber: phoneNumber,
          });
        }

        return {
          botName: company.id,
          name: company.name,
          phoneCount: phoneCount,
          category: company.category || "juta",
          employeeEmails: company.employeeEmails || [],
          phones: phoneStatuses,
        };
      })
    );

    res.json(botStatuses);
  } catch (error) {
    console.error("Error fetching bot statuses:", error);
    res.status(500).json({ error: "Failed to fetch bot statuses" });
  } finally {
    if (client) {
      client.release();
    }
  }
});

async function getContactDataFromDatabaseByEmail(email) {
  const client = await pool.connect();

  try {
    if (!email) {
      throw new Error("Email is undefined or null");
    }

    const query = `
      SELECT * FROM public.users 
      WHERE email = $1`;

    const result = await client.query(query, [email]);

    if (result.rowCount === 0) {
      console.log("No matching document.");
      return null;
    } else {
      return { ...result.rows[0] };
    }
  } catch (error) {
    console.error("Error fetching document:", error);
    throw error;
  } finally {
    await safeRelease(client);
  }
}

async function saveThreadIDPostgres(email, threadID) {
  const client = await pool.connect();

  try {
    const query = `
      UPDATE public.users 
      SET thread_id = $1, last_updated = CURRENT_TIMESTAMP 
      WHERE email = $2
      RETURNING id`;

    const result = await client.query(query, [threadID, email]);

    if (result.rowCount === 0) {
      console.log(`No user found with email ${email}. Thread ID not saved.`);
    } else {
      console.log(`Thread ID saved to PostgreSQL for user with email ${email}`);
    }
  } catch (error) {
    console.error("Error saving Thread ID to PostgreSQL:", error);
  } finally {
    await safeRelease(client);
  }
}

async function createThread() {
  const thread = await openai.beta.threads.create();
  return thread;
}

async function addMessage(threadId, message) {
  const response = await openai.beta.threads.messages.create(threadId, {
    role: "user",
    content: message,
  });
  return response;
}

async function runAssistant(assistantID, threadId) {
  const response = await openai.beta.threads.runs.create(threadId, {
    assistant_id: assistantID,
  });

  const runId = response.id;

  const answer = await waitForCompletion(threadId, runId);
  return answer;
}

async function checkingStatus(threadId, runId) {
  const runObject = await openai.beta.threads.runs.retrieve(threadId, runId);
  const status = runObject.status;

  if (status === "completed") {
    const messagesList = await openai.beta.threads.messages.list(threadId);
    const latestMessage = messagesList.body.data[0].content;
    const answer = latestMessage[0].text.value;
    return answer;
  } else if (
    status === "failed" ||
    status === "cancelled" ||
    status === "expired"
  ) {
    throw new Error(
      `Assistant run ${status}: ${
        runObject.last_error?.message || "Unknown error"
      }`
    );
  }
  // For statuses: queued, in_progress, requires_action - continue polling
  return null;
}

async function waitForCompletion(threadId, runId) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      clearInterval(pollingInterval);
      reject(new Error("Assistant timeout - no response after 5 minutes"));
    }, 300000); // 5 minutes timeout

    pollingInterval = setInterval(async () => {
      try {
        const answer = await checkingStatus(threadId, runId);
        if (answer) {
          clearInterval(pollingInterval);
          clearTimeout(timeout);
          resolve(answer);
        }
      } catch (error) {
        clearInterval(pollingInterval);
        clearTimeout(timeout);
        reject(error);
      }
    }, 10000); // Changed from 1000ms to 10000ms (10 seconds)
  });
}

// Extract user data from URL parameters
async function handleOpenAIAssistant(message, threadID, assistantid) {
  const assistantId = assistantid;
  await addMessage(threadID, message);
  const answer = await runAssistant(assistantId, threadID);
  return answer;
}

app.get("/api/assistant-test/", async (req, res) => {
  try {
    const message = req.query.message;
    const email = req.query.email;
    const assistantid = req.query.assistantid;

    // Log the request
    console.log("🧪 Assistant Test Request:", {
      message: message ? message.substring(0, 100) + "..." : "No message",
      email,
      assistantid,
      messageLength: message ? message.length : 0,
    });

    // Validate required fields
    if (!message || !email || !assistantid) {
      return res.status(400).json({
        success: false,
        error: "MISSING_FIELDS",
        details: "Message, email, and assistantid are required",
      });
    }

    let threadID;
    const contactData = await getContactDataFromDatabaseByEmail(email);

    if (contactData?.thread_id) {
      threadID = contactData.thread_id;
      console.log("✅ Using existing thread ID:", threadID);
    } else {
      const thread = await createThread();
      threadID = thread.id;
      console.log("🆕 Created new thread ID:", threadID);
      await saveThreadIDPostgres(email, threadID);
      console.log("💾 Saved new thread ID to database for email:", email);
    }

    // Add user message to thread
    console.log(
      "📝 Adding user message to thread (length:",
      message.length,
      ")"
    );
    await addMessage(threadID, message);
    console.log("✅ User message added to thread");

    // Create and run the assistant
    console.log("🤖 Creating and running assistant...");
    const assistantResponse = await openai.beta.threads.runs.create(threadID, {
      assistant_id: assistantid,
    });
    console.log("✅ Assistant run created with ID:", assistantResponse.id);

    // Wait for completion with enhanced error handling
    const answer = await waitForCompletion(threadID, assistantResponse.id);
    console.log("📝 Assistant response received (length:", answer.length, ")");

    // Save the interaction to the thread for future reference
    console.log("💾 Saving interaction to thread...");
    await addMessageAssistant(
      threadID,
      `Test Request: ${message}\nResponse: ${answer}`
    );
    console.log("✅ Interaction saved to thread");

    // Send enhanced response
    console.log("📤 Sending response to client...");
    res.json({
      success: true,
      message: "Assistant replied success",
      data: {
        answer,
        threadID: threadID,
        assistantId: assistantid,
        messageLength: answer.length,
        timestamp: new Date().toISOString(),
      },
    });
    console.log("✅ Response sent successfully");
  } catch (error) {
    console.error("💥 Assistant test error:", {
      name: error.name,
      message: error.message,
      code: error.code,
      stack: error.stack,
    });
    res.status(500).json({
      success: false,
      error: error.code || error.name,
      details: error.message,
    });
  }
});

app.get("/api/assistant-test-guest/", async (req, res) => {
  const message = req.query.message;
  const sessionId = req.query.sessionId;
  const assistantid = req.query.assistantid;

  try {
    let threadID;
    const sessionData = await getSessionDataFromDatabase(sessionId);

    if (sessionData?.threadid) {
      threadID = sessionData.threadid;
    } else {
      const thread = await createThread();
      threadID = thread.id;
      await saveThreadIDForSession(sessionId, threadID);
    }

    const answer = await handleOpenAIAssistant(message, threadID, assistantid);

    // Send success response
    res.json({ message: "Assistant replied success", answer });
  } catch (error) {
    // Handle errors
    console.error("Assistant replied user:", error);
    res.status(500).json({ error: error.code });
  }
});

// New function to get session data
async function getSessionDataFromDatabase(sessionId) {
  let client;
  try {
    if (!sessionId) {
      throw new Error("Session ID is undefined or null");
    }

    client = await pool.connect();
    const query = "SELECT data FROM sessions WHERE session_id = $1";
    const result = await client.query(query, [sessionId]);

    if (result.rows.length === 0) {
      return null;
    }

    return result.rows[0].data;
  } catch (error) {
    console.error("Error fetching session data:", error);
    throw error;
  } finally {
    if (client) await safeRelease(client);
  }
}

// New function to save thread ID for session
async function saveThreadIDForSession(sessionId, threadID) {
  let client;
  try {
    client = await pool.connect();
    const query = `
      INSERT INTO sessions (session_id, data) 
      VALUES ($1, $2) 
      ON CONFLICT (session_id) 
      DO UPDATE SET data = jsonb_set(
        COALESCE(sessions.data, '{}'::jsonb), 
        '{threadid}', 
        to_jsonb($3::text),
        true
      )
    `;

    const data = {
      threadid: threadID,
      createdAt: new Date().toISOString(),
    };

    await client.query(query, [sessionId, data, threadID]);
  } catch (error) {
    console.error("Error saving Thread ID for session:", error);
    throw error;
  } finally {
    if (client) await safeRelease(client);
  }
}

app.get(
  "/api/chats/:token/:locationId/:accessToken/:userName/:userRole/:userEmail/:companyId",
  async (req, res) => {
    const {
      token,
      locationId,
      accessToken,
      userName,
      userRole,
      userEmail,
      companyId,
    } = req.params;

    let allChats = [];
    let count = 500;
    let offset = 0;
    let totalChats = 0;
    let contactsData = [];
    let fetchedChats = 0; // Track the number of fetched chats
    try {
      // Fetch user data to get notifications and pinned chats
      const userDocRef = db.collection("user").doc(userEmail);

      const notificationsRef = userDocRef.collection("notifications");
      const notificationsSnapshot = await notificationsRef.get();
      const notifications = notificationsSnapshot.docs.map((doc) => doc.data());

      const pinnedChatsRef = userDocRef.collection("pinned");
      const pinnedChatsSnapshot = await pinnedChatsRef.get();
      const pinnedChats = pinnedChatsSnapshot.docs.map((doc) => doc.data());
      let whapiToken2 = token;
      const companyDocRef = db.collection("companies").doc(companyId);
      const companyDoc = await companyDocRef.get();
      const companyData = companyDoc.data();
      whapiToken2 = companyData.whapiToken2 || token;

      // Fetch all chats from WhatsApp API
      if (token !== "none") {
        while (true) {
          // Add rate limiting for WhatsApp API calls
          if (!checkRateLimit(`whatsapp_api_${companyId}`)) {
            console.log(`Rate limit reached for WhatsApp API, waiting...`);
            await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds
            continue;
          }

          const response = await fetch(
            `https://gate.whapi.cloud/chats?count=${count}&offset=${offset}`,
            {
              headers: { Authorization: "Bearer " + token },
            }
          );
          const data = await response.json();

          if (offset === 0 && data.total) {
            totalChats = data.total;
          }
          if (data.chats.length === 0) break;
          allChats = allChats.concat(data.chats);
          fetchedChats += data.chats.length; // Update the number of fetched chats
          offset += count;

          // Add delay between API calls to prevent overwhelming the network
          await new Promise((resolve) => setTimeout(resolve, 2000)); // 2 second delay
        }
        count = 500;
        offset = 0;
        if (companyId === "018") {
          while (true) {
            // Add rate limiting for second WhatsApp API calls
            if (!checkRateLimit(`whatsapp_api2_${companyId}`)) {
              console.log(`Rate limit reached for WhatsApp API2, waiting...`);
              await new Promise((resolve) => setTimeout(resolve, 5000)); // Wait 5 seconds
              continue;
            }

            const response = await fetch(
              `https://gate.whapi.cloud/chats?count=${count}&offset=${offset}`,
              {
                headers: { Authorization: "Bearer " + whapiToken2 },
              }
            );
            const data = await response.json();
            if (offset === 0 && data.total) {
              totalChats = data.total;
            }
            if (data.chats.length === 0) break;
            allChats = allChats.concat(data.chats);
            fetchedChats += data.chats.length; // Update the number of fetched chats
            offset += count;

            // Add delay between API calls to prevent overwhelming the network
            await new Promise((resolve) => setTimeout(resolve, 2000)); // 2 second delay
          }
        }
      }
      let totalContacts = 0;
      let lastContactId = null;
      let maxContacts = 3000;
      let maxRetries = 3;
      while (totalContacts < maxContacts) {
        // Add rate limiting for contact fetching
        if (!checkRateLimit(`contact_fetch_${companyId}`)) {
          console.log(`Rate limit reached for contact fetching, waiting...`);
          await new Promise((resolve) => setTimeout(resolve, 3000)); // Wait 3 seconds
          continue;
        }

        let retries = 0;
        let contacts = []; // Initialize contacts outside the retry loop

        const params = {
          locationId: locationId,
          limit: 100,
        };

        if (lastContactId) {
          params.startAfterId = lastContactId;
        }

        const response = await axios.get(
          "https://services.leadconnectorhq.com/contacts/",
          {
            headers: {
              Authorization: `Bearer ${accessToken}`,
              Version: "2021-07-28",
            },
            params: params,
          }
        );

        const metaTotal = response.data.meta.total;
        // console.log(metaTotal);
        if (metaTotal < maxContacts) {
          maxContacts = metaTotal;
        }

        contacts = response.data.contacts;
        contactsData.push(...contacts);
        totalContacts += contacts.length;

        if (contacts.length === 0 || totalContacts >= maxContacts) break;
        lastContactId = contacts[contacts.length - 1].id;

        if (contacts.length === 0) {
          console.log("No more contacts to fetch.");
          break;
        }

        if (totalContacts >= maxContacts) break;
      }

      // Ensure the contactsData does not exceed 3000 contacts
      if (contactsData.length > maxContacts) {
        contactsData.length = maxContacts;
      }
      // Ensure the contactsData does not exceed 3000 contacts
      if (contactsData.length > maxContacts) {
        contactsData.length = maxContacts;
      }

      // Process and merge chat and contact data
      const mappedChats = allChats
        .map((chat) => {
          if (!chat.id) return null;
          const phoneNumber = `+${chat.id.split("@")[0]}`;
          const contact = contactsData.find(
            (contact) => contact.phone === phoneNumber
          );
          let unreadCount = notifications.filter(
            (notif) => notif.chat_id === chat.id && !notif.read
          ).length;

          if (contact) {
            return {
              ...chat,
              tags: contact.tags || [],
              name: contact.contactName || chat.name,
              contact_id: contact.id,
              unreadCount,
              chat_pic: chat.chat_pic || null,
              chat_pic_full: chat.chat_pic_full || null,
            };
          } else {
            return {
              ...chat,
              tags: [],
              name: chat.name,
              contact_id: "",
              unreadCount,
              chat_pic: chat.chat_pic || null,
              chat_pic_full: chat.chat_pic_full || null,
            };
          }
        })
        .filter(Boolean);

      // Merge WhatsApp contacts with existing contacts
      mappedChats.forEach((chat) => {
        const phoneNumber = `+${chat.id.split("@")[0]}`;
        const existingContact = contactsData.find(
          (contact) => contact.phone === phoneNumber
        );
        if (existingContact) {
          existingContact.chat_id = chat.id;
          existingContact.last_message =
            chat.last_message || existingContact.last_message;
          existingContact.chat = chat;
          existingContact.unreadCount =
            (existingContact.unreadCount || 0) + chat.unreadCount;
          existingContact.tags = [
            ...new Set([...existingContact.tags, ...chat.tags]),
          ];
          existingContact.chat_pic = chat.chat_pic;
          existingContact.chat_pic_full = chat.chat_pic_full;
        } else {
          contactsData.push({
            id: chat.contact_id,
            phone: phoneNumber,
            contactName: chat.name,
            chat_id: chat.id,
            last_message: chat.last_message || null,
            chat: chat,
            tags: chat.tags,
            conversation_id: chat.id,
            unreadCount: chat.unreadCount,
            chat_pic: chat.chat_pic,
            chat_pic_full: chat.chat_pic_full,
          });
        }
      });

      // Add pinned status to contactsData
      contactsData.forEach((contact) => {
        contact.pinned = pinnedChats.some(
          (pinned) => pinned.chat_id === contact.chat_id
        );
      });

      // Sort contactsData by pinned status and last_message timestamp
      contactsData.sort((a, b) => {
        if (a.pinned && !b.pinned) return -1;
        if (!a.pinned && b.pinned) return 1;
        const dateA = a.last_message?.createdAt
          ? new Date(a.last_message.createdAt)
          : a.last_message?.timestamp
          ? new Date(a.last_message.timestamp * 1000)
          : new Date(0);
        const dateB = b.last_message?.createdAt
          ? new Date(b.last_message.createdAt)
          : b.last_message?.timestamp
          ? new Date(b.last_message.timestamp * 1000)
          : new Date(0);
        return dateB - dateA;
      });

      // Filter contacts by user role if necessary
      let filteredContacts = contactsData;
      //console.log(filteredContacts.length);
      if (userRole === "2") {
        filteredContacts = contactsData.filter((contact) =>
          contact.tags.some(
            (tag) =>
              typeof tag === "string" &&
              tag.toLowerCase().includes(userName.toLowerCase())
          )
        );
        const groupChats = contactsData.filter(
          (contact) => contact.chat_id && contact.chat_id.includes("@g.us")
        );
        filteredContacts = filteredContacts.concat(groupChats);
      }

      // Include group chats regardless of the role

      // Remove duplicate contacts
      filteredContacts = filteredContacts.reduce((unique, contact) => {
        if (!unique.some((c) => c.phone === contact.phone)) {
          unique.push(contact);
        }
        return unique;
      }, []);
      // console.log(filteredContacts.length);
      res.json({ contacts: filteredContacts, totalChats });
    } catch (error) {
      console.error(error);
      res.status(500).send("Internal Server Error");
    }
  }
);

app.get("/api/dashboard/:companyId", async (req, res) => {
  const { companyId } = req.params;
  const monthKey = getCurrentMonthKey();

  try {
    const companyQuery = `SELECT name FROM companies WHERE company_id = $1`;
    const companyResult = await pool.query(companyQuery, [companyId]);
    if (companyResult.rows.length === 0) {
      return res.status(404).json({ error: "Company not found" });
    }

    const now = new Date();
    const startOfDay = new Date(now.setHours(0, 0, 0, 0));
    const startOfWeek = new Date(
      now.getFullYear(),
      now.getMonth(),
      now.getDate() - now.getDay()
    );
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

    const contactsQuery = `
      SELECT 
        contact_id,
        created_at,
        tags,
        (SELECT COUNT(*) FROM messages WHERE contact_id = c.contact_id AND company_id = c.company_id AND NOT from_me) as reply_count,
        (SELECT COUNT(*) FROM messages WHERE contact_id = c.contact_id AND company_id = c.company_id AND from_me) as outgoing_count
      FROM contacts c
      WHERE company_id = $1
    `;
    const contactsResult = await pool.query(contactsQuery, [companyId]);

    let totalContacts = 0;
    let closedContacts = 0;
    let openContacts = 0;
    let todayContacts = 0;
    let weekContacts = 0;
    let monthContacts = 0;
    let numReplies = 0;
    const employeePerformance = {};

    contactsResult.rows.forEach((contact) => {
      totalContacts++;
      const dateAdded = contact.created_at
        ? new Date(contact.created_at)
        : null;

      if (
        contact.tags &&
        contact.tags.some((tag) => tag.toLowerCase() === "closed")
      ) {
        closedContacts++;
      } else {
        openContacts++;
      }

      if (dateAdded) {
        if (dateAdded >= startOfDay) todayContacts++;
        if (dateAdded >= startOfWeek) weekContacts++;
        if (dateAdded >= startOfMonth) monthContacts++;
      }

      numReplies += parseInt(contact.reply_count) || 0;

      if (contact.tags && contact.tags.assigned_to) {
        const employeeName = contact.tags.assigned_to;
        employeePerformance[employeeName] = employeePerformance[
          employeeName
        ] || {
          assignedContacts: 0,
          outgoingMessages: 0,
          closedContacts: 0,
        };

        employeePerformance[employeeName].assignedContacts++;
        if (contact.tags.closed === true) {
          employeePerformance[employeeName].closedContacts++;
        }
        employeePerformance[employeeName].outgoingMessages +=
          parseInt(contact.outgoing_count) || 0;
      }
    });

    const responseRate =
      totalContacts > 0 ? (numReplies / totalContacts) * 100 : 0;
    const averageRepliesPerLead =
      totalContacts > 0 ? numReplies / totalContacts : 0;
    const engagementScore = responseRate * 0.4 + averageRepliesPerLead * 0.6;
    const conversionRate =
      totalContacts > 0 ? (closedContacts / totalContacts) * 100 : 0;

    const employeesQuery = `
      SELECT 
        e.employee_id,
        e.name,
        e.role,
        e.email,
        e.phone_number,
        COALESCE((
          SELECT COUNT(*) 
          FROM assignments a 
          WHERE a.employee_id = e.employee_id 
            AND a.company_id = e.company_id
            AND a.month_key = $1
        ), 0) as current_month_assignments
      FROM employees e
      WHERE e.company_id = $2
      ORDER BY current_month_assignments DESC
    `;
    const employeesResult = await pool.query(employeesQuery, [
      monthKey,
      companyId,
    ]);

    const employees = employeesResult.rows.map((employee) => ({
      ...employee,
      ...(employeePerformance[employee.name] || {
        assignedContacts: 0,
        outgoingMessages: 0,
        closedContacts: 0,
      }),
    }));

    const phoneStatsQuery = `
      SELECT 
        phone_index,
        COUNT(*) as total_assignments,
        COUNT(DISTINCT contact_id) as unique_contacts,
        COUNT(DISTINCT employee_id) as active_agents
      FROM assignments
      WHERE company_id = $1
        AND month_key = $2
      GROUP BY phone_index
      ORDER BY phone_index
    `;
    const phoneStatsResult = await pool.query(phoneStatsQuery, [
      companyId,
      monthKey,
    ]);

    const dashboardData = {
      company: companyResult.rows[0].name,
      kpi: {
        totalContacts,
        numReplies,
        closedContacts,
        openContacts,
      },
      engagementMetrics: {
        responseRate: responseRate.toFixed(2),
        averageRepliesPerLead: averageRepliesPerLead.toFixed(2),
        engagementScore: engagementScore.toFixed(2),
        conversionRate: conversionRate.toFixed(2),
      },
      leadsOverview: {
        total: totalContacts,
        today: todayContacts,
        week: weekContacts,
        month: monthContacts,
      },
      phoneLineStats: phoneStatsResult.rows.map((row) => ({
        phoneIndex: row.phone_index,
        totalAssignments: row.total_assignments,
        uniqueContacts: row.unique_contacts,
        activeAgents: row.active_agents,
      })),
      employeePerformance: employees,
    };

    res.json(dashboardData);
  } catch (error) {
    console.error("Error fetching dashboard data:", error);
    res.status(500).json({
      error: "Internal server error",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
});

app.post("/api/create-contact", async (req, res) => {
  const {
    contactName,
    lastName,
    email,
    phone,
    address1,
    companyName,
    companyId,
  } = req.body;

  const client = await pool.connect();

  try {
    if (!phone) {
      return res.status(400).json({ error: "Phone number is required." });
    }

    const formattedPhoneWithoutPlus = formatPhoneNumber(phone);
    const phoneWithPlus = `+${formattedPhoneWithoutPlus}`;
    const contact_id = `${companyId}-${formattedPhoneWithoutPlus}`;

    const checkQuery = `
      SELECT id FROM contacts 
      WHERE phone = $1 AND company_id = $2
    `;
    const checkResult = await client.query(checkQuery, [
      phoneWithPlus,
      companyId,
    ]);

    if (checkResult.rows.length > 0) {
      return res
        .status(409)
        .json({ error: "A contact with this phone number already exists." });
    }

    const contactData = {
      contact_id: contact_id,
      company_id: companyId,
      name: contactName + (lastName ? ` ${lastName}` : ""),
      contact_name: contactName,
      phone: phoneWithPlus,
      email: email,
      thread_id: null,
      company: companyName,
      address1: address1,
      created_at: new Date(),
      unread_count: 0,
      profile: {},
      tags: [],
      custom_fields: {},
      last_message: null,
      chat_data: {},
    };

    const insertQuery = `
      INSERT INTO contacts (
        contact_id, company_id, name, contact_name, phone, email, 
        thread_id, company, address1, created_at, unread_count,
        profile, tags, custom_fields, last_message, chat_data
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16
      ) RETURNING *
    `;

    const insertValues = [
      contactData.contact_id,
      contactData.company_id,
      contactData.name,
      contactData.contact_name,
      contactData.phone,
      contactData.email,
      contactData.thread_id,
      contactData.company,
      contactData.address1,
      contactData.created_at,
      contactData.unread_count,
      contactData.profile,
      contactData.tags,
      contactData.custom_fields,
      contactData.last_message,
      contactData.chat_data,
    ];

    const result = await client.query(insertQuery, insertValues);
    const insertedContact = result.rows[0];

    res.status(201).json({
      message: "Contact added successfully!",
      contact: insertedContact,
    });
  } catch (error) {
    console.error("Error adding contact:", error);
    res.status(500).json({
      error: "An error occurred while adding the contact: " + error.message,
    });
  } finally {
    await safeRelease(client);
  }
});

app.get("/api/bots", async (req, res) => {
  let client;
  try {
    client = await pool.connect();

    const botsQuery = `
      SELECT 
        c.company_id AS id,
        c.name,
        c.v2,
        c.phone_count AS "phoneCount",
        c.assistant_ids AS "assistantId",
        c.trial_end_date AS "trialEndDate",
        c.trial_start_date AS "trialStartDate",
        c.plan,
        c.category,
        c.api_url AS "apiUrl",
        c.phone_numbers AS "phoneNumbers",
        ARRAY(
          SELECT e.email 
          FROM employees e 
          WHERE e.company_id = c.company_id AND e.email IS NOT NULL
        ) AS "employeeEmails"
      FROM companies c
      WHERE c.v2 = true
      AND c.api_url = $1
    `;

    const apiUrl = process.env.URL;
    const companiesResult = await client.query(botsQuery, [apiUrl]);

    const botsPromises = companiesResult.rows.map(async (company) => {
      const botData = botMap.get(company.id);
      const phoneCount = company.phoneCount || 1;
      let phoneInfoArray = [];

      if (Array.isArray(botData)) {
        phoneInfoArray = await Promise.all(
          botData.map(async (data, index) => {
            if (data?.client) {
              try {
                const info = await data.client.info;
                return info?.wid?.user || null;
              } catch (err) {
                console.error(
                  `Error getting client info for bot ${company.id} phone ${index}:`,
                  err
                );
                return null;
              }
            }
            return null;
          })
        );
      }

      return {
        botName: company.id,
        phoneCount: phoneCount,
        name: company.name,
        v2: company.v2,
        clientPhones: phoneInfoArray,
        assistantId: company.assistantId || [],
        trialEndDate: company.trialEndDate
          ? new Date(company.trialEndDate)
          : null,
        trialStartDate: company.trialStartDate
          ? new Date(company.trialStartDate)
          : null,
        plan: company.plan || null,
        employeeEmails: company.employeeEmails || [],
        category: company.category || "juta",
        apiUrl: company.apiUrl || null,
      };
    });

    const bots = await Promise.all(botsPromises);
    res.json(bots);
  } catch (error) {
    console.error("Error fetching bots:", error);
    res.status(500).json({
      error: "Failed to fetch bots",
      details: error.message,
    });
  } finally {
    if (client) {
      await safeRelease(client);
    }
  }
});

app.put("/api/bots/:botId/category", async (req, res) => {
  const { botId } = req.params;
  const { category } = req.body;

  try {
    // Validate input
    if (!category) {
      return res.status(400).json({
        error: "Category is required in request body",
      });
    }

    // Check if company exists
    const companyExists = await sqlDb.query(
      "SELECT id FROM companies WHERE company_id = $1",
      [botId]
    );

    if (companyExists.rows.length === 0) {
      return res.status(404).json({
        error: "Company not found",
      });
    }

    // Update the category in PostgreSQL
    await sqlDb.query(
      "UPDATE companies SET category = $1 WHERE company_id = $2",
      [category, botId]
    );

    res.json({
      success: true,
      message: "Category updated successfully",
      data: {
        botId,
        category,
      },
    });
  } catch (error) {
    console.error("Error updating category:", error);
    res.status(500).json({
      error: "Failed to update category",
      details: error.message,
    });
  }
});

function broadcastBotActivity(botName, isActive) {
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(
        JSON.stringify({
          type: "bot_activity",
          botName,
          isActive,
        })
      );
    }
  });
}

// New endpoint to delete trial end date
app.delete("/api/bots/:botId/trial-end-date", async (req, res) => {
  try {
    const { botId } = req.params;

    // Check if company exists
    const companyExists = await sqlDb.query(
      "SELECT id FROM companies WHERE company_id = $1",
      [botId]
    );

    if (companyExists.rows.length === 0) {
      return res.status(404).json({ error: "Bot not found" });
    }

    // Update the trial_end_date to NULL in PostgreSQL
    await sqlDb.query(
      "UPDATE companies SET trial_end_date = NULL WHERE company_id = $1",
      [botId]
    );

    res.json({
      success: true,
      message: "Trial end date deleted successfully",
      botId,
    });
  } catch (error) {
    console.error("Error deleting trial end date:", error);
    res.status(500).json({
      error: "Failed to delete trial end date",
      details: error.message,
    });
  }
});

app.get("/api/bot-status/:companyId", async (req, res) => {
  const { companyId } = req.params;

  // Allow both localhost for development and your Vercel domain for production
  const allowedOrigins = [
    "http://localhost:5173",
    "https://juta-crm-v3.vercel.app",
  ];

  const origin = req.headers.origin;
  if (allowedOrigins.includes(origin)) {
    res.header("Access-Control-Allow-Origin", origin);
  }
  res.header(
    "Access-Control-Allow-Methods",
    "GET, POST, PUT, PATCH, DELETE, OPTIONS"
  );
  res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.header("Access-Control-Allow-Credentials", "true");

  try {
    // First get the company from database
    const companyData = await sqlDb.getRow(
      "SELECT * FROM companies WHERE company_id = $1::varchar",
      [companyId]
    );

    if (!companyData) {
      console.log("ERROR: Company not found in database");
      return res.status(404).json({ error: "Company not found" });
    }

    // Then get the bot status
    const botData = botMap.get(companyId);

    if (botData && Array.isArray(botData)) {
      if (botData.length === 1) {
        const { status, qrCode } = botData[0];

        let phoneInfo = null;

        if (botData[0]?.client) {
          try {
            const info = await botData[0].client.info;
            phoneInfo = info?.wid?.user || null;
          } catch (err) {
            console.error(
              `Error getting client info for company ${companyId}:`,
              err
            );
            console.error("Error stack:", err.stack);
          }
        } else {
          console.log("No client object found in bot data");
        }

        const response = {
          status,
          qrCode,
          phoneInfo,
          companyId,
          v2: companyData.v2,
          trialEndDate: companyData.trial_end_date,
          apiUrl: companyData.api_url,
          phoneCount: companyData.phone_count,
        };
        res.json(response);
      } else {
        const statusArray = await Promise.all(
          botData.map(async (phone, index) => {
            let phoneInfo = null;

            if (phone?.client) {
              try {
                const info = await phone.client.info;
                phoneInfo = info?.wid?.user || null;
              } catch (err) {
                console.error(
                  `Error getting client info for company ${companyId} phone ${index}:`,
                  err
                );
                console.error(`Phone ${index} error stack:`, err.stack);
              }
            } else {
              console.log(`Phone ${index} has no client object`);
            }

            const phoneResult = {
              phoneIndex: index,
              status: phone.status,
              qrCode: phone.qrCode,
              phoneInfo,
            };
            return phoneResult;
          })
        );

        const response = {
          phones: statusArray,
          companyId,
          v2: companyData.v2,
          trialEndDate: companyData.trial_end_date,
          apiUrl: companyData.api_url,
          phoneCount: companyData.phone_count,
        };
        res.json(response);
      }
    } else {
      const response = {
        status: "initializing",
        qrCode: null,
        phoneInfo: null,
        companyId,
        v2: companyData.v2,
        trialEndDate: companyData.trial_end_date,
        apiUrl: companyData.api_url,
        phoneCount: companyData.phone_count,
      };
      res.json(response);
    }
  } catch (error) {
    console.error("=== BOT STATUS REQUEST FAILED ===");
    console.error(`Error getting status for company ${companyId}:`, error);
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);
    console.error("Error name:", error.name);
    console.error("Error code:", error.code);
    res.status(500).json({ error: "Failed to get status" });
  }
});

// ======================
// PHONE MANAGEMENT ENDPOINTS
// ======================

// POST /api/companies/{companyId}/phones/add - Add a new phone to company
app.post("/api/companies/:companyId/phones/add", async (req, res) => {
  const { companyId } = req.params;
  
  console.log(`=== Add Phone Request for Company: ${companyId} ===`);

  try {
    // Get current company data
    const companyData = await sqlDb.getRow(
      "SELECT * FROM companies WHERE company_id = $1",
      [companyId]
    );

    if (!companyData) {
      return res.status(404).json({
        success: false,
        error: "Company not found"
      });
    }

    const currentPhoneCount = companyData.phone_count || 1;
    const maxPhones = getMaxPhonesByPlan(companyData.plan);

    // Validate phone count limits
    if (currentPhoneCount >= maxPhones) {
      return res.status(400).json({
        success: false,
        error: `Maximum phone limit reached for ${companyData.plan || 'free'} plan (${maxPhones} phones)`,
        currentPhoneCount,
        maxPhones,
        plan: companyData.plan
      });
    }

    const newPhoneCount = currentPhoneCount + 1;
    const newPhoneIndex = currentPhoneCount; // 0-based index

    // Update phone count in database
    await sqlDb.query(
      "UPDATE companies SET phone_count = $1, updated_at = CURRENT_TIMESTAMP WHERE company_id = $2",
      [newPhoneCount, companyId]
    );

    console.log(`Updated phone count for ${companyId}: ${currentPhoneCount} -> ${newPhoneCount}`);

    // Send immediate response
    res.json({
      success: true,
      message: `Phone ${newPhoneIndex + 1} added successfully. Initialization in progress.`,
      companyId,
      previousPhoneCount: currentPhoneCount,
      newPhoneCount,
      newPhoneIndex,
      status: "initializing"
    });

    // Initialize the new phone in background
    console.log(`Initializing new phone ${newPhoneIndex} for company ${companyId}...`);
    
    try {
      await initializeBot(companyId, newPhoneCount, newPhoneIndex);
      console.log(`Successfully initialized phone ${newPhoneIndex} for company ${companyId}`);
    } catch (initError) {
      console.error(`Error initializing new phone for ${companyId}:`, initError);
      // Don't fail the request - just log the error
    }

  } catch (error) {
    console.error(`Error adding phone for company ${companyId}:`, error);
    res.status(500).json({
      success: false,
      error: "Failed to add phone",
      details: error.message
    });
  }
});

// DELETE /api/companies/{companyId}/phones/{phoneIndex} - Remove a phone from company
app.delete("/api/companies/:companyId/phones/:phoneIndex", async (req, res) => {
  const { companyId, phoneIndex } = req.params;
  const phoneIndexNum = parseInt(phoneIndex, 10);
  
  console.log(`=== Remove Phone Request for Company: ${companyId}, Phone: ${phoneIndexNum} ===`);

  try {
    // Validate phoneIndex
    if (isNaN(phoneIndexNum) || phoneIndexNum < 0) {
      return res.status(400).json({
        success: false,
        error: "Invalid phone index"
      });
    }

    // Get current company data
    const companyData = await sqlDb.getRow(
      "SELECT * FROM companies WHERE company_id = $1",
      [companyId]
    );

    if (!companyData) {
      return res.status(404).json({
        success: false,
        error: "Company not found"
      });
    }

    const currentPhoneCount = companyData.phone_count || 1;

    // Validate removal constraints
    if (currentPhoneCount <= 1) {
      return res.status(400).json({
        success: false,
        error: "Cannot remove phone - company must have at least 1 phone",
        currentPhoneCount
      });
    }

    if (phoneIndexNum >= currentPhoneCount) {
      return res.status(400).json({
        success: false,
        error: `Phone index ${phoneIndexNum} does not exist (company has ${currentPhoneCount} phones)`,
        currentPhoneCount
      });
    }

    // Don't allow removing phone 0 to maintain consistency
    if (phoneIndexNum === 0) {
      return res.status(400).json({
        success: false,
        error: "Cannot remove primary phone (index 0). Remove other phones first.",
        suggestion: "Remove phones with higher indexes first, then recreate the company if needed."
      });
    }

    // Disconnect and destroy the phone client
    const botData = botMap.get(companyId);
    if (botData && Array.isArray(botData) && botData[phoneIndexNum]) {
      try {
        if (botData[phoneIndexNum].client) {
          await destroyClient(botData[phoneIndexNum].client);
          console.log(`Destroyed client for ${companyId} phone ${phoneIndexNum}`);
        }
        
        // Remove the phone from botMap
        botData.splice(phoneIndexNum, 1);
        botMap.set(companyId, botData);
        
      } catch (destroyError) {
        console.error(`Error destroying client for ${companyId} phone ${phoneIndexNum}:`, destroyError);
        // Continue with removal even if client destruction fails
      }
    }

    const newPhoneCount = currentPhoneCount - 1;

    // Update phone count in database
    await sqlDb.query(
      "UPDATE companies SET phone_count = $1, updated_at = CURRENT_TIMESTAMP WHERE company_id = $2",
      [newPhoneCount, companyId]
    );

    console.log(`Updated phone count for ${companyId}: ${currentPhoneCount} -> ${newPhoneCount}`);

    res.json({
      success: true,
      message: `Phone ${phoneIndexNum + 1} removed successfully`,
      companyId,
      removedPhoneIndex: phoneIndexNum,
      previousPhoneCount: currentPhoneCount,
      newPhoneCount
    });

  } catch (error) {
    console.error(`Error removing phone ${phoneIndexNum} for company ${companyId}:`, error);
    res.status(500).json({
      success: false,
      error: "Failed to remove phone",
      details: error.message
    });
  }
});

// GET /api/companies/{companyId}/phones - Get phone information for company
app.get("/api/companies/:companyId/phones", async (req, res) => {
  const { companyId } = req.params;
  
  try {
    // Get company data
    const companyData = await sqlDb.getRow(
      "SELECT * FROM companies WHERE company_id = $1",
      [companyId]
    );

    if (!companyData) {
      return res.status(404).json({
        success: false,
        error: "Company not found"
      });
    }

    const phoneCount = companyData.phone_count || 1;
    const maxPhones = getMaxPhonesByPlan(companyData.plan);
    const botData = botMap.get(companyId);

    // Build phone status array
    const phones = [];
    for (let i = 0; i < phoneCount; i++) {
      let phoneStatus = "disconnected";
      let phoneInfo = null;
      let qrCode = null;

      if (botData && botData[i]) {
        phoneStatus = botData[i].status || "unknown";
        qrCode = botData[i].qrCode;
        
        if (botData[i].client) {
          try {
            const info = await botData[i].client.info;
            phoneInfo = info?.wid?.user || null;
          } catch (err) {
            console.error(`Error getting info for ${companyId} phone ${i}:`, err);
          }
        }
      }

      phones.push({
        phoneIndex: i,
        status: phoneStatus,
        phoneInfo,
        qrCode,
        canRemove: i > 0 && phoneCount > 1 // Can't remove phone 0 or if only 1 phone
      });
    }

    res.json({
      success: true,
      companyId,
      phoneCount,
      maxPhones,
      plan: companyData.plan,
      canAddPhone: phoneCount < maxPhones,
      phones
    });

  } catch (error) {
    console.error(`Error getting phones for company ${companyId}:`, error);
    res.status(500).json({
      success: false,
      error: "Failed to get phone information",
      details: error.message
    });
  }
});

// Helper function to get max phones by plan
function getMaxPhonesByPlan(plan) {
  switch (plan?.toLowerCase()) {
    case 'free':
    case 'trial':
      return 1;
    case 'premium':
    case 'starter':
      return 3;
    case 'business':
      return 5;
    case 'enterprise':
      return 10;
    default:
      return 1; // Default to free plan limit
  }
}

// GET /api/ai-responses - Fetch all AI responses for a company
app.get("/api/ai-responses", async (req, res) => {
  console.log("=== Starting GET /api/ai-responses ===");
  console.log("Query params:", req.query);

  const { companyId, type } = req.query;

  // Validation
  if (!companyId) {
    console.error("Missing companyId");
    return res
      .status(400)
      .json({ success: false, message: "Missing companyId" });
  }

  if (
    !type ||
    !["video", "voice", "tag", "document", "image", "assign"].includes(type)
  ) {
    console.error("Invalid or missing type");
    return res.status(400).json({
      success: false,
      message:
        "Type is required and must be one of: video, voice, tag, document, image, assign",
    });
  }

  const sqlClient = await getDatabaseConnection();

  try {
    let tableName;
    switch (type) {
      case "video":
        tableName = "ai_video_responses";
        break;
      case "voice":
        tableName = "ai_voice_responses";
        break;
      case "tag":
        tableName = "ai_tag_responses";
        break;
      case "document":
        tableName = "ai_document_responses";
        break;
      case "image":
        tableName = "ai_image_responses";
        break;
      case "assign":
        tableName = "ai_assign_responses";
        break;
    }

    const query = `SELECT * FROM public.${tableName} WHERE company_id = $1 ORDER BY created_at DESC`;
    console.log("Executing query:", query);

    const result = await sqlClient.query(query, [companyId]);
    console.log(`Found ${result.rowCount} ${type} responses`);

    res.status(200).json({
      success: true,
      data: result.rows,
      count: result.rowCount,
    });
  } catch (error) {
    console.error("=== Error in GET /api/ai-responses ===");
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);

    res.status(500).json({
      success: false,
      message: `Failed to fetch ${type} responses`,
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});

app.post("/api/ai-responses", async (req, res) => {
  console.log("=== Starting POST /api/ai-responses ===");
  console.log("Request body:", JSON.stringify(req.body, null, 2));

  const { companyId, type, data } = req.body;

  // Validation
  if (!companyId) {
    console.error("Missing companyId");
    return res
      .status(400)
      .json({ success: false, message: "Missing companyId" });
  }

  if (
    !type ||
    !["video", "voice", "tag", "document", "image", "assign"].includes(type)
  ) {
    console.error("Invalid or missing type");
    return res.status(400).json({
      success: false,
      message:
        "Type is required and must be one of: video, voice, tag, document, image, assign",
    });
  }

  if (!data) {
    console.error("Missing data");
    return res
      .status(400)
      .json({ success: false, message: "Missing data for the response" });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting AI response creation"
    );
    return res
      .status(500)
      .json({ success: false, message: "Failed to create AI response" });
  }

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    const responseId = require("crypto").randomUUID();
    console.log("Generated response ID:", responseId);

    let insertQuery;
    let queryParams;
    let responseData;

    switch (type) {
      case "video":
        insertQuery = `
          INSERT INTO public.ai_video_responses (
            response_id, company_id, keywords, 
            video_urls, captions, keyword_source, status, description
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          RETURNING *
        `;
        queryParams = [
          responseId,
          companyId,
          JSON.stringify(data.keywords) || [],
          JSON.stringify(data.video_urls) || [],
          data.captions || [],
          data.keyword_source || "user",
          data.status || "active",
          data.description || "",
        ];
        break;

      case "voice":
        insertQuery = `
          INSERT INTO public.ai_voice_responses (
            response_id, company_id, keywords, voice_urls, captions,
            keyword_source, status, description
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          RETURNING *
        `;
        queryParams = [
          responseId,
          companyId,
          JSON.stringify(data.keywords) || [],
          JSON.stringify(data.voice_urls) || [],
          data.captions || [],
          data.keyword_source || "user",
          data.status || "active",
          data.description || "",
        ];
        break;

      case "tag":
        insertQuery = `
          INSERT INTO public.ai_tag_responses (
            response_id, company_id, tags,
            keywords, remove_tags, keyword_source, tag_action_mode, status, description
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          RETURNING *
        `;
        queryParams = [
          responseId,
          companyId,
          JSON.stringify(data.tags) || null,
          JSON.stringify(data.keywords) || null,
          JSON.stringify(data.remove_tags) || null,
          data.keyword_source || "user",
          data.tag_action_mode || "add",
          data.status || "active",
          data.description || "",
        ];
        break;

      case "document":
        insertQuery = `
          INSERT INTO public.ai_document_responses (
            response_id, company_id, document_urls,
            document_names, keywords, keyword_source, status, description
          ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
          RETURNING *
        `;
        queryParams = [
          responseId,
          companyId,
          JSON.stringify(data.document_urls) || [],
          JSON.stringify(data.document_names) || [],
          JSON.stringify(data.keywords) || [],
          data.keyword_source || "user",
          data.status || "active",
          data.description || "",
        ];
        break;

      case "image":
        insertQuery = `
          INSERT INTO public.ai_image_responses (
            response_id, company_id,
            keywords, image_urls, keyword_source, status, description
          ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          RETURNING *
        `;
        queryParams = [
          responseId,
          companyId,
          JSON.stringify(data.keywords) || [],
          JSON.stringify(data.image_urls) || [],
          data.keyword_source || "user",
          data.status || "active",
          data.description || "",
        ];
        break;

      case "assign":
        insertQuery = `
          INSERT INTO public.ai_assign_responses (
            response_id, company_id, keywords,
            keyword_source, assigned_employees, description, status
          ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          RETURNING *
        `;
        queryParams = [
          responseId,
          companyId,
          JSON.stringify(data.keywords) || null,
          data.keyword_source || "user",
          JSON.stringify(data.assigned_employees) || null,
          data.description || "",
          data.status || "active",
        ];
        break;
    }

    console.log("Executing insert with params:", queryParams);
    const result = await sqlClient.query(insertQuery, queryParams);
    responseData = result.rows[0];
    console.log("Response created successfully:", responseData);

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");

    res.status(201).json({
      success: true,
      message: `${type} response created successfully`,
      data: responseData,
    });
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("=== Error in POST /api/ai-responses ===");
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);

    res.status(500).json({
      success: false,
      message: `Failed to create ${type} response`,
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});

app.put("/api/ai-responses/:id", async (req, res) => {
  console.log("=== Starting PUT /api/ai-responses/:id ===");
  console.log("Request params:", req.params);
  console.log("Request body:", JSON.stringify(req.body, null, 2));

  const { id } = req.params;
  const { type, data } = req.body;

  // Validation
  if (!id) {
    console.error("Missing id");
    return res
      .status(400)
      .json({ success: false, message: "Missing response id" });
  }

  if (
    !type ||
    !["video", "voice", "tag", "document", "image", "assign"].includes(type)
  ) {
    console.error("Invalid or missing type");
    return res.status(400).json({
      success: false,
      message:
        "Type is required and must be one of: video, voice, tag, document, image, assign",
    });
  }

  if (!data) {
    console.error("Missing data");
    return res
      .status(400)
      .json({ success: false, message: "Missing update data" });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting AI response update"
    );
    return res
      .status(500)
      .json({ success: false, message: "Failed to update AI response" });
  }

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    let updateQuery;
    let queryParams = [];
    let responseData;

    switch (type) {
      case "video":
        updateQuery = `
          UPDATE public.ai_video_responses SET
            keywords = COALESCE($1, keywords),
            video_urls = COALESCE($2, video_urls),
            captions = COALESCE($3, captions),
            keyword_source = COALESCE($4, keyword_source),
            status = COALESCE($5, status),
            description = COALESCE($6, description),
            updated_at = CURRENT_TIMESTAMP
          WHERE response_id = $7
          RETURNING *
        `;
        queryParams = [
          data.keywords ? JSON.stringify(data.keywords) : null,
          data.video_urls ? JSON.stringify(data.video_urls) : null,
          data.captions || null,
          data.keyword_source || null,
          data.status || null,
          data.description || null,
          id,
        ];
        break;

      case "voice":
        updateQuery = `
          UPDATE public.ai_voice_responses SET
            keywords = COALESCE($1, keywords),
            voice_urls = COALESCE($2, voice_urls),
            captions = COALESCE($3, captions),
            keyword_source = COALESCE($4, keyword_source),
            status = COALESCE($5, status),
            description = COALESCE($6, description),
            updated_at = CURRENT_TIMESTAMP
          WHERE response_id = $7
          RETURNING *
        `;
        queryParams = [
          data.keywords ? JSON.stringify(data.keywords) : null,
          data.voice_urls ? JSON.stringify(data.voice_urls) : null,
          data.captions || null,
          data.keyword_source || null,
          data.status || null,
          data.description || null,
          id,
        ];
        break;

      case "tag":
        updateQuery = `
          UPDATE public.ai_tag_responses SET
            tags = COALESCE($1, tags),
            keywords = COALESCE($2, keywords),
            remove_tags = COALESCE($3, remove_tags),
            keyword_source = COALESCE($4, keyword_source),
            tag_action_mode = COALESCE($5, tag_action_mode),
            status = COALESCE($6, status),
            description = COALESCE($7, description),
            updated_at = CURRENT_TIMESTAMP
          WHERE response_id = $8
          RETURNING *
        `;
        queryParams = [
          data.tags ? JSON.stringify(data.tags) : null,
          data.keywords ? JSON.stringify(data.keywords) : null,
          data.remove_tags ? JSON.stringify(data.remove_tags) : null,
          data.keyword_source || null,
          data.tag_action_mode || null,
          data.status || null,
          data.description || null,
          id,
        ];
        break;

      case "document":
        updateQuery = `
          UPDATE public.ai_document_responses SET
            document_urls = COALESCE($1, document_urls),
            document_names = COALESCE($2, document_names),
            keywords = COALESCE($3, keywords),
            keyword_source = COALESCE($4, keyword_source),
            status = COALESCE($5, status),
            description = COALESCE($6, description),
            updated_at = CURRENT_TIMESTAMP
          WHERE response_id = $7
          RETURNING *
        `;
        queryParams = [
          data.document_urls ? JSON.stringify(data.document_urls) : null,
          data.document_names ? JSON.stringify(data.document_names) : null,
          data.keywords ? JSON.stringify(data.keywords) : null,
          data.keyword_source || null,
          data.status || null,
          data.description || null,
          id,
        ];
        break;

      case "image":
        updateQuery = `
          UPDATE public.ai_image_responses SET
            keywords = COALESCE($1, keywords),
            image_urls = COALESCE($2, image_urls),
            keyword_source = COALESCE($3, keyword_source),
            status = COALESCE($4, status),
            description = COALESCE($5, description),
            updated_at = CURRENT_TIMESTAMP
          WHERE response_id = $6
          RETURNING *
        `;
        queryParams = [
          data.keywords ? JSON.stringify(data.keywords) : null,
          data.image_urls ? JSON.stringify(data.image_urls) : null,
          data.keyword_source || null,
          data.status || null,
          data.description || null,
          id,
        ];
        break;

      case "assign":
        updateQuery = `
          UPDATE public.ai_assign_responses SET
            keywords = COALESCE($1, keywords),
            keyword_source = COALESCE($2, keyword_source),
            assigned_employees = COALESCE($3, assigned_employees),
            description = COALESCE($4, description),
            status = COALESCE($5, status),
            updated_at = CURRENT_TIMESTAMP
          WHERE response_id = $6
          RETURNING *
        `;
        queryParams = [
          data.keywords ? JSON.stringify(data.keywords) : null,
          data.keyword_source || null,
          data.assigned_employees
            ? JSON.stringify(data.assigned_employees)
            : null,
          data.description || null,
          data.status || null,
          id,
        ];
        break;
    }

    console.log("Executing update with params:", queryParams);
    const result = await sqlClient.query(updateQuery, queryParams);

    if (result.rowCount === 0) {
      console.error("No response found with id:", id);
      await safeRollback(sqlClient);
      return res.status(404).json({
        success: false,
        message: `${type} response not found with id: ${id}`,
      });
    }

    responseData = result.rows[0];
    console.log("Response updated successfully:", responseData);

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");

    res.status(200).json({
      success: true,
      message: `${type} response updated successfully`,
      data: responseData,
    });
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("=== Error in PUT /api/ai-responses/:id ===");
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);

    res.status(500).json({
      success: false,
      message: `Failed to update ${type} response`,
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});

app.delete("/api/ai-responses/:id", async (req, res) => {
  console.log("=== Starting DELETE /api/ai-responses/:id ===");
  console.log("Request params:", req.params);
  console.log("Query params:", req.query);

  const { id } = req.params;
  const { type } = req.query;

  // Validation
  if (!id) {
    console.error("Missing id");
    return res
      .status(400)
      .json({ success: false, message: "Missing response id" });
  }

  if (
    !type ||
    !["video", "voice", "tag", "document", "image", "assign"].includes(type)
  ) {
    console.error("Invalid or missing type");
    return res.status(400).json({
      success: false,
      message:
        "Type is required and must be one of: video, voice, tag, document, image, assign",
    });
  }

  const sqlClient = await getDatabaseConnection();

  if (!sqlClient) {
    console.error(
      "Failed to get database connection - aborting AI response deletion"
    );
    return res
      .status(500)
      .json({ success: false, message: "Failed to delete AI response" });
  }

  try {
    await sqlClient.query("BEGIN");
    console.log("Database transaction started");

    let tableName;
    switch (type) {
      case "video":
        tableName = "ai_video_responses";
        break;
      case "voice":
        tableName = "ai_voice_responses";
        break;
      case "tag":
        tableName = "ai_tag_responses";
        break;
      case "document":
        tableName = "ai_document_responses";
        break;
      case "image":
        tableName = "ai_image_responses";
        break;
      case "assign":
        tableName = "ai_assign_responses";
        break;
    }

    const deleteQuery = `DELETE FROM public.${tableName} WHERE response_id = $1 RETURNING *`;
    console.log("Executing delete query:", deleteQuery);

    const result = await sqlClient.query(deleteQuery, [id]);

    if (result.rowCount === 0) {
      console.error("No response found with id:", id);
      await safeRollback(sqlClient);
      return res.status(404).json({
        success: false,
        message: `${type} response not found with id: ${id}`,
      });
    }

    const deletedResponse = result.rows[0];
    console.log("Response deleted successfully:", deletedResponse);

    await sqlClient.query("COMMIT");
    console.log("Database transaction committed successfully");

    res.status(200).json({
      success: true,
      message: `${type} response deleted successfully`,
      data: deletedResponse,
    });
  } catch (error) {
    await safeRollback(sqlClient);
    console.error("=== Error in DELETE /api/ai-responses/:id ===");
    console.error("Error message:", error.message);
    console.error("Error stack:", error.stack);

    res.status(500).json({
      success: false,
      message: `Failed to delete ${type} response`,
      error: error.message,
    });
  } finally {
    await safeRelease(sqlClient);
    console.log("Database client released");
  }
});
// AI Response Brainstorm API with file upload support - FIXED FIELD NAME
app.post("/api/ai-response-brainstorm/", async (req, res) => {
  try {
    const userInput = req.query.message;
    const email = req.query.email;
    const { currentPrompt, currentResponses, fileUrls, companyId } = req.body;

    // Log the full request to debug
    console.log("AI Response Brainstorm Request:", {
      userInput,
      email,
      currentPrompt,
      currentResponses,
      fileUrls: fileUrls ? fileUrls.length : 0,
      companyId,
    });

    // Log all file URLs received
    if (fileUrls) {
      console.log("�� File URLs received:", fileUrls);
    }

    let threadID;
    const contactData = await getContactDataFromDatabaseByEmail(email);

    if (contactData?.thread_id) {
      threadID = contactData.thread_id;
      console.log("Using existing thread ID:", threadID);
    } else {
      const thread = await createThread();
      threadID = thread.id;
      console.log("Created new thread ID:", threadID);
      await saveThreadIDPostgres(email, threadID);
      console.log("Saved new thread ID to database for email:", email);
    }

    // Process file URLs if any
    let fileInfo = "";

    if (fileUrls && fileUrls.length > 0) {
      console.log(`📁 Processing ${fileUrls.length} file URLs...`);

      try {
        fileInfo = fileUrls
          .map((url, index) => `File ${index + 1}: ${url}`)
          .join(", ");

        console.log("📎 File URLs processed successfully:", fileInfo);
      } catch (urlError) {
        console.error("❌ Error processing file URLs:", urlError);
        return res.status(500).json({
          success: false,
          error: "FILE_URL_PROCESSING_ERROR",
          details: "Failed to process file URLs",
        });
      }
    }

    // Create the full prompt for the assistant
    const fullPrompt = `You are an AI Response Builder expert. The user wants to create automated AI responses for their business.

Your task: Help them create the perfect AI response by analyzing their request and any provided file URLs.

${
  fileUrls && fileUrls.length > 0
    ? `📎 **FILE URLS AVAILABLE:**
${fileUrls.map((url, index) => `${index + 1}. ${url}`).join("\n")}

Use these file URLs to create the appropriate AI response. If they provided image URLs, create an image response with these URLs. If they provided document URLs, create a document response with these URLs, etc.`
    : "If the user wants image/audio/document/video responses, ask them to provide the necessary file URLs first."
}

Response format:
[RESPONSE_START]
{
  "type": "tag|image|voice|document|assign|video",
  "keywords": ["keyword1", "keyword2"],
  "description": "Description of what this response does",
  "status": "active",
  "keywordSource": "user",
  "tags": ["tag1", "tag2"],
  "tagActionMode": "add|delete",
  "removeTags": ["tag3", "tag4"],
  "imageUrls": ["url1", "url2"],
  "voiceUrls": ["url1", "url2"],
  "documentUrls": ["url1", "url2"],
  "videoUrls": ["url1", "url2"],
  "assignedEmployees": ["employee1", "employee2"]
}
[RESPONSE_END]

[EXPLANATION_START]
Brief explanation of what this AI response will do and when it will trigger.
[EXPLANATION_END]

[ALTERNATIVES_START]
[
  {
    "type": "alternative_type",
    "keywords": ["alt_keyword1", "alt_keyword2"],
    "description": "Alternative response description"
  }
]
[ALTERNATIVES_END]

Rules:
- If file URLs are provided, use them in the appropriate response fields
- Determine the best response type based on the user's request AND provided file URLs
- Provide realistic keywords that would trigger this response
- Include all necessary fields for the response type
- Be specific and actionable
- Use the provided file URLs in the response configuration

User Request: ${userInput}

Help create the perfect AI response using the provided file URLs if any.`;

    // Add user message to thread
    await addMessage(threadID, fullPrompt);

    // Create and run the assistant
    const assistantResponse = await openai.beta.threads.runs.create(threadID, {
      assistant_id: process.env.ASSISTANT_ID || "asst_QfkZ8GeCw0Rbc2zRW4B86FWD",
    });

    // Wait for completion using the enhanced function that handles tool calls
    const answer = await waitForCompletionAIResponseBuilder(
      threadID,
      assistantResponse.id,
      email
    );

    // Save the interaction to the thread for future reference
    await addMessageAssistant(
      threadID,
      `AI Response Creation Request: ${userInput}\nFile URLs: ${
        fileInfo || "None"
      }\nCurrent Prompt: ${currentPrompt || "None"}\nResponse: ${answer}`
    );

    // Parse the AI response to extract structured data
    const parsedResponse = parseAIResponse(answer);

    // Enhance the response with file URL information
    if (fileUrls && fileUrls.length > 0) {
      // Update the suggested response with actual file URLs
      const responseType = parsedResponse.suggestedResponse.type;

      switch (responseType) {
        case "image":
          parsedResponse.suggestedResponse.imageUrls = fileUrls;
          break;
        case "voice":
          parsedResponse.suggestedResponse.voiceUrls = fileUrls;
          break;
        case "document":
          parsedResponse.suggestedResponse.documentUrls = fileUrls;
          break;
        case "video":
          parsedResponse.suggestedResponse.videoUrls = fileUrls;
          break;
      }

      // Update explanation to mention the files
      parsedResponse.explanation = `${parsedResponse.explanation}\n\n📎 Using your provided file URLs: ${fileUrls.length} file(s)`;
    }

    // AUTO-SAVE: Save the AI response to database if companyId is provided
    let savedResponseId = null;
    if (companyId && parsedResponse.suggestedResponse) {
      try {
        console.log("💾 Auto-saving AI response to database...");

        // Call the existing /api/ai-responses endpoint
        const responseData = {
          companyId: companyId,
          type: parsedResponse.suggestedResponse.type,
          data: {
            keywords: parsedResponse.suggestedResponse.keywords,
            description: parsedResponse.suggestedResponse.description,
            status: parsedResponse.suggestedResponse.status || "active",
            keyword_source:
              parsedResponse.suggestedResponse.keywordSource || "user",
            tags: parsedResponse.suggestedResponse.tags,
            tag_action_mode: parsedResponse.suggestedResponse.tagActionMode,
            remove_tags: parsedResponse.suggestedResponse.removeTags,
            image_urls: parsedResponse.suggestedResponse.imageUrls,
            voice_urls: parsedResponse.suggestedResponse.voiceUrls,
            document_urls: parsedResponse.suggestedResponse.documentUrls,
            video_urls: parsedResponse.suggestedResponse.videoUrls,
            assigned_employees:
              parsedResponse.suggestedResponse.assignedEmployees,
          },
        };

        // Make internal request to the API endpoint
        const axios = require("axios");
        const apiResponse = await axios.post(
          `${req.protocol}://${req.get("host")}/api/ai-responses`,
          responseData
        );

        if (apiResponse.data.success) {
          savedResponseId = apiResponse.data.data.responseId;
          console.log(
            "✅ AI response saved successfully with ID:",
            savedResponseId
          );
        } else {
          throw new Error("API returned error: " + apiResponse.data.error);
        }
      } catch (saveError) {
        console.error("❌ Failed to auto-save AI response:", saveError);
        // Don't fail the request, just log the error
      }
    }

    // Send response
    res.json({
      success: true,
      data: {
        explanation:
          parsedResponse.explanation ||
          `I'll help you create a response for your request`,
        suggestedResponse: parsedResponse.suggestedResponse,
        alternatives: parsedResponse.alternatives || [],
        threadID: threadID,
        fileUrls: fileUrls || [],
        savedResponseId: savedResponseId, // Include the saved response ID if available
        message: savedResponseId
          ? "AI response created and saved successfully!"
          : "AI response created successfully (not saved - companyId required)",
      },
    });
  } catch (error) {
    console.error("AI Response brainstorm error:", {
      name: error.name,
      message: error.message,
      code: error.code,
    });
    res.status(500).json({
      success: false,
      error: error.code,
      details: error.message,
    });
  }
});

async function waitForCompletionAIResponseBuilder(
  threadId,
  runId,
  email,
  depth = 0
) {
  const maxDepth = 5;
  const maxAttempts = 30;
  const pollingInterval = 2000;

  console.log(
    `⏳ Waiting for AI Response Builder completion (depth: ${depth}, runId: ${runId})...`
  );

  if (depth >= maxDepth) {
    console.error(`❌ Max recursion depth reached for runId: ${runId}`);
    return "I apologize, but I'm having trouble completing this task. Could you please try rephrasing your request?";
  }

  for (let attempts = 0; attempts < maxAttempts; attempts++) {
    try {
      const runObject = await openai.beta.threads.runs.retrieve(
        threadId,
        runId
      );
      console.log(
        `🔍 Run status: ${runObject.status} (attempt ${attempts + 1})`
      );

      if (runObject.status === "completed") {
        console.log("✅ AI Response Builder run completed successfully");
        const messagesList = await openai.beta.threads.messages.list(threadId);
        const latestMessage = messagesList.data[0].content[0].text.value;
        return latestMessage;
      } else if (runObject.status === "requires_action") {
        console.log(
          "🛠️ AI Response Builder run requires action, handling tool calls..."
        );
        const toolCalls =
          runObject.required_action.submit_tool_outputs.tool_calls;

        const toolOutputs = await handleToolCallsAIResponseBuilder(
          toolCalls,
          email
        );

        // Submit tool outputs back to the assistant
        await openai.beta.threads.runs.submitToolOutputs(threadId, runId, {
          tool_outputs: toolOutputs,
        });
        console.log(
          "✅ Tool outputs submitted, restarting wait for completion..."
        );

        return await waitForCompletionAIResponseBuilder(
          threadId,
          runId,
          email,
          depth + 1
        );
      } else if (
        ["failed", "cancelled", "expired"].includes(runObject.status)
      ) {
        console.error(`❌ Run ${runId} ended with status: ${runObject.status}`);
        return `I encountered an error (${runObject.status}). Please try your request again.`;
      }

      await new Promise((resolve) => setTimeout(resolve, pollingInterval));
    } catch (error) {
      console.error(
        `❌ Error in waitForCompletionAIResponseBuilder (depth: ${depth}, runId: ${runId}): ${error}`
      );
      return "I'm sorry, but I encountered an error while processing your request. Please try again.";
    }
  }

  console.error(
    `⏰ Timeout: AI Response Builder did not complete in time (depth: ${depth}, runId: ${runId})`
  );
  return "I'm sorry, but it's taking longer than expected to process your request. Please try again or rephrase your question.";
}

// Handle tool calls for AI Response Builder
// Handle tool calls for AI Response Builder
async function handleToolCallsAIResponseBuilder(toolCalls, email) {
  console.log("🛠️ Handling AI Response Builder tool calls...");
  console.log(`📋 Found ${toolCalls.length} tool calls to process`);

  const toolOutputs = [];

  for (const toolCall of toolCalls) {
    console.log(`🔧 Processing tool call: ${toolCall.function.name}`);
    console.log(`📝 Tool call arguments: ${toolCall.function.arguments}`);
    console.log(`🆔 Tool call ID: ${toolCall.id}`);

    switch (toolCall.function.name) {
      case "createAIResponse":
        try {
          console.log("💾 Processing createAIResponse tool call...");
          const args = JSON.parse(toolCall.function.arguments);

          // Get company ID from email
          const contactData = await getContactDataFromDatabaseByEmail(email);
          if (!contactData?.company_id) {
            throw new Error("Company ID not found for user");
          }

          console.log("🏢 Company ID found:", contactData.company_id);
          console.log("📊 Response data:", args);
          console.log("🎯 Response type:", args.type);

          // Use the same structure as your frontend
          const responseData = {
            companyId: contactData.company_id,
            type: args.type,
            data: {
              keywords: args.keywords || [],
              description: args.description || "",
              status: args.status || "active",
              keyword_source: args.keywordSource || "user",
              // Type-specific data based on response type
              ...(args.type === "image" && {
                image_urls: args.imageUrls || [],
                analysis_result: null,
              }),
              ...(args.type === "voice" && {
                voice_urls: args.voiceUrls || [],
                audio_url: args.voiceUrls?.[0] || "",
                captions: args.voiceUrls?.map(() => "") || [],
                transcription: "",
                language: "en",
                analysis_result: null,
              }),
              ...(args.type === "document" && {
                document_urls: args.documentUrls || [],
                document_names: [],
                document_url: args.documentUrls?.[0] || "",
                extracted_text: "",
                analysis_result: null,
              }),
              ...(args.type === "video" && {
                video_urls: args.videoUrls || [],
                captions: args.videoUrls?.map(() => "") || [],
                analysis_result: null,
              }),
              ...(args.type === "tag" && {
                tags: args.tags || [],
                tag_action_mode: args.tagActionMode || "add",
                remove_tags: args.removeTags || [],
                confidence: 0.9,
              }),
              ...(args.type === "assign" && {
                assigned_employees: args.assignedEmployees || [],
              }),
            },
          };

          console.log("💾 Using endpoint: /api/ai-responses");
          console.log("💾 Response data structure:", responseData);

          // Call the same endpoint your frontend uses
          const axios = require("axios");
          const apiResponse = await axios.post(
            `${req.protocol}://${req.get("host")}/api/ai-responses`,
            responseData
          );

          console.log("✅ API Response received:", apiResponse.data);

          if (!apiResponse.data.success) {
            throw new Error("API returned error: " + apiResponse.data.error);
          }

          const responseId =
            apiResponse.data.data.id ||
            apiResponse.data.data.response_id ||
            apiResponse.data.data.responseId;
          console.log("✅ AI response created successfully!");
          console.log("📋 Table used:", tableName);
          console.log("🆔 Response ID:", responseId);

          const result = `✅ AI response created successfully! Response ID: ${responseId}
      
      Response Details:
      • Type: ${args.type}
      • Keywords: ${args.keywords?.join(", ")}
      • Description: ${args.description}
      • Status: ${args.status || "active"}
      
      The AI response is now active and will automatically trigger when the specified keywords are detected.`;

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: result,
          });
          console.log("📤 Added createAIResponse result to tool outputs");
        } catch (error) {
          console.error("❌ Error in createAIResponse:", error);
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break;
      case "askForImage":
        try {
          console.log("��️ Processing askForImage tool call...");
          const args = JSON.parse(toolCall.function.arguments);

          // This tool should ask the user to upload an image
          const result = `Please upload an image for: ${
            args.purpose || "your AI response"
          }. 
          
          Supported formats: JPG, PNG, GIF
          Maximum size: 10MB
          
          Once you upload the image, I'll create the AI response configuration for you.`;

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: result,
          });
          console.log("📤 Added image request to tool outputs");
        } catch (error) {
          console.error("❌ Error in askForImage:", error);
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break;

      case "askForFile":
        try {
          console.log("📁 Processing askForFile tool call...");
          const args = JSON.parse(toolCall.function.arguments);

          const result = `Please upload a file for: ${
            args.purpose || "your AI response"
          }. 
          
          Supported formats: PDF, DOC, DOCX, TXT
          Maximum size: 20MB
          
          Once you upload the file, I'll create the AI response configuration for you.`;

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: result,
          });
          console.log("�� Added file request to tool outputs");
        } catch (error) {
          console.error("❌ Error in askForFile:", error);
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break;

      case "askForAudio":
        try {
          console.log("🎵 Processing askForAudio tool call...");
          const args = JSON.parse(toolCall.function.arguments);

          const result = `Please upload an audio file for: ${
            args.purpose || "your AI response"
          }. 
          
          Supported formats: MP3, WAV, M4A
          Maximum size: 15MB
          
          Once you upload the audio, I'll create the AI response configuration for you.`;

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: result,
          });
          console.log("📤 Added audio request to tool outputs");
        } catch (error) {
          console.error("❌ Error in askForAudio:", error);
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break;

      case "askForVideo":
        try {
          console.log("🎬 Processing askForVideo tool call...");
          const args = JSON.parse(toolCall.function.arguments);

          const result = `Please upload a video file for: ${
            args.purpose || "your AI response"
          }. 
          
          Supported formats: MP4, MOV, AVI
          Maximum size: 50MB
          
          Once you upload the video, I'll create the AI response configuration for you.`;

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: result,
          });
          console.log("📤 Added video request to tool outputs");
        } catch (error) {
          console.error("❌ Error in askForVideo:", error);
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break;

      case "searchWeb":
        try {
          console.log("🌐 Processing searchWeb tool call...");
          const args = JSON.parse(toolCall.function.arguments);
          const searchResults = await searchWeb(args.query);
          console.log("✅ Web search completed successfully");

          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: searchResults,
          });
          console.log("📤 Added search results to tool outputs");
        } catch (error) {
          console.error("❌ Error in searchWeb:", error);
          toolOutputs.push({
            tool_call_id: toolCall.id,
            output: JSON.stringify({ error: error.message }),
          });
        }
        break;

      default:
        console.log(`⚠️ Unknown tool function: ${toolCall.function.name}`);
        toolOutputs.push({
          tool_call_id: toolCall.id,
          output: JSON.stringify({
            error: `Unknown tool function: ${toolCall.function.name}`,
          }),
        });
    }
  }

  console.log(`�� Total tool outputs prepared: ${toolOutputs.length}`);
  return toolOutputs;
}

// Helper function to parse AI assistant response
// Helper function to parse AI assistant response - IMPROVED VERSION
function parseAIResponse(aiResponse) {
  try {
    console.log("�� Raw AI response:", aiResponse);

    // Extract response data from the structured format
    const responseMatch = aiResponse.match(
      /\[RESPONSE_START\]([\s\S]*?)\[RESPONSE_END\]/
    );
    const explanationMatch = aiResponse.match(
      /\[EXPLANATION_START\]([\s\S]*?)\[EXPLANATION_END\]/
    );
    const alternativesMatch = aiResponse.match(
      /\[ALTERNATIVES_START\]([\s\S]*?)\[ALTERNATIVES_END\]/
    );

    let suggestedResponse = {
      type: "tag",
      keywords: [],
      description: "",
      status: "active",
      keywordSource: "user",
    };

    let alternatives = [];
    let explanation = "AI response generated successfully";

    // Parse the main response
    if (responseMatch) {
      try {
        // Clean the response text before parsing
        let responseText = responseMatch[1].trim();

        // Remove any markdown formatting or extra characters
        responseText = responseText
          .replace(/```json/g, "")
          .replace(/```/g, "")
          .replace(/^[\s\n]*/, "") // Remove leading whitespace and newlines
          .replace(/[\s\n]*$/, ""); // Remove trailing whitespace and newlines

        console.log("🧹 Cleaned response text:", responseText);

        // Try to find valid JSON within the text
        const jsonStart = responseText.indexOf("{");
        const jsonEnd = responseText.lastIndexOf("}");

        if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
          const jsonText = responseText.substring(jsonStart, jsonEnd + 1);
          console.log("🔍 Extracted JSON text:", jsonText);

          const responseData = JSON.parse(jsonText);
          suggestedResponse = { ...suggestedResponse, ...responseData };
          console.log("✅ Successfully parsed response data");
        } else {
          console.log("⚠️ No valid JSON found, using fallback parsing");
          // Fallback: try to extract individual fields using regex
          const typeMatch = responseText.match(/"type"\s*:\s*"([^"]+)"/);
          const keywordsMatch = responseText.match(
            /"keywords"\s*:\s*\[([^\]]+)\]/
          );
          const descMatch = responseText.match(/"description"\s*:\s*"([^"]+)"/);

          if (typeMatch) suggestedResponse.type = typeMatch[1];
          if (keywordsMatch) {
            suggestedResponse.keywords = keywordsMatch[1]
              .split(",")
              .map((k) => k.trim().replace(/"/g, ""))
              .filter((k) => k.length > 0);
          }
          if (descMatch) suggestedResponse.description = descMatch[1];
        }
      } catch (e) {
        console.log("❌ Failed to parse JSON from response section:", e);
        console.log("🔍 Raw response section:", responseMatch[1]);
      }
    }

    // Parse explanation
    if (explanationMatch) {
      explanation = explanationMatch[1].trim();
    }

    // Parse alternatives
    if (alternativesMatch) {
      try {
        // Clean the alternatives text before parsing
        let alternativesText = alternativesMatch[1].trim();

        // Remove any markdown formatting
        alternativesText = alternativesText
          .replace(/```json/g, "")
          .replace(/```/g, "")
          .replace(/^[\s\n]*/, "")
          .replace(/[\s\n]*$/, "");

        // Try to find valid JSON array
        const arrayStart = alternativesText.indexOf("[");
        const arrayEnd = alternativesText.lastIndexOf("]");

        if (arrayStart !== -1 && arrayEnd !== -1 && arrayEnd > arrayStart) {
          const arrayText = alternativesText.substring(
            arrayStart,
            arrayEnd + 1
          );
          alternatives = JSON.parse(arrayText);
        }
      } catch (e) {
        console.log("❌ Failed to parse JSON from alternatives section:", e);
        console.log("🔍 Raw alternatives section:", alternativesMatch[1]);
      }
    }

    // Validate and clean the suggested response
    if (!Array.isArray(suggestedResponse.keywords)) {
      suggestedResponse.keywords = [];
    }

    if (!suggestedResponse.description) {
      suggestedResponse.description = `Automated ${suggestedResponse.type} response`;
    }

    console.log("🎯 Final parsed response:", {
      explanation,
      suggestedResponse,
      alternatives,
    });

    return {
      explanation,
      suggestedResponse,
      alternatives,
    };
  } catch (error) {
    console.error("❌ Error parsing AI response:", error);
    console.error("�� Raw AI response:", aiResponse);

    // Return a basic fallback response
    return {
      explanation: "AI response generated successfully",
      suggestedResponse: {
        type: "tag",
        keywords: [],
        description: "AI-generated response",
        status: "active",
        keywordSource: "user",
      },
      alternatives: [],
    };
  }
}

app.post("/api/v2/messages/text/:companyId/:chatId", async (req, res) => {
  console.log("\n=== New Text Message Request ===");
  const companyId = req.params.companyId;
  const chatId = req.params.chatId;
  const {
    message,
    quotedMessageId,
    phoneIndex: requestedPhoneIndex,
    userName: requestedUserName,
  } = req.body;

  console.log("Request details:", {
    companyId,
    chatId,
    messageLength: message?.length,
    hasQuotedMessage: Boolean(quotedMessageId),
    requestedPhoneIndex,
    userName: requestedUserName,
  });

  const phoneIndex =
    requestedPhoneIndex !== undefined ? parseInt(requestedPhoneIndex) : 0;
  const userName = requestedUserName !== undefined ? requestedUserName : "";
  const contactID = companyId + "-" + chatId.split("@")[0];
  const phoneNumber = "+" + chatId.split("@")[0];

  try {
    // 1. Get the client for this company from botMap
    console.log("\n=== Client Validation ===");
    const botData = botMap.get(companyId);
    console.log("Bot data found:", Boolean(botData));
    console.log(
      "Available phone indices:",
      botData ? botData.map((_, i) => i) : []
    );

    if (!botData) {
      console.error("WhatsApp client not found for company:", companyId);
      return res.status(404).send("WhatsApp client not found for this company");
    }

    const client = botData[phoneIndex]?.client;
    console.log("Client status:", {
      phoneIndex,
      hasClient: Boolean(client),
      clientInfo: client
        ? {
            info: (() => {
              try {
                return client.info;
              } catch (e) {
                return "Error getting info";
              }
            })(),
            isConnected: client.isConnected,
          }
        : null,
    });

    if (!client) {
      console.error(
        "No active WhatsApp client found for phone index:",
        phoneIndex
      );
      return res
        .status(404)
        .send("No active WhatsApp client found for this company");
    }

    // 2. Ensure the chat exists and send the message
    console.log("\n=== Sending Message ===");
    let sentMessage;

    // Try to retrieve the chat first to surface clear errors when chat data is missing
    try {
      console.log("Checking chat exists for:", chatId);
      await client.getChatById(chatId);
    } catch (chatErr) {
      console.error("Failed to get chat before sending message:", chatErr?.message);
      // Return a 404-like response so caller knows the chat is not available
      return res.status(404).json({
        success: false,
        error: "Chat not found or not available in WhatsApp client",
        details: chatErr?.message,
      });
    }

    try {
      if (quotedMessageId) {
        console.log("Sending with quoted message:", quotedMessageId);
        sentMessage = await client.sendMessage(chatId, message, {
          quotedMessageId,
        });
      } else {
        console.log("Sending regular message");
        sentMessage = await client.sendMessage(chatId, message);
      }

      console.log("Message sent successfully:", {
        messageId: sentMessage?.id?._serialized ?? "no id",
        timestamp: sentMessage?.timestamp ?? "no timestamp",
        type: sentMessage?.type ?? "no type",
      });
    } catch (sendError) {
      console.error("\n=== Message Send Error ===");
      console.error("Error Type:", sendError?.name);
      console.error("Error Message:", sendError?.message);
      console.error("Stack:", sendError?.stack);

      // Known whatsapp-web error: "Lid is missing in chat table" - surface a helpful message
      if (sendError?.message && sendError.message.includes("Lid is missing")) {
        return res.status(500).json({
          success: false,
          error: "WhatsApp internal error: Lid is missing in chat table",
          details: sendError.message,
        });
      }

      // Generic send failure
      return res.status(500).json({
        success: false,
        error: "Failed to send message",
        details: sendError?.message,
      });
    }

    // 3. Process response and save to SQL
    console.log("\n=== Saving to Database ===");

    // 4. Save to SQL
    try {
      const contactData = await getContactDataFromDatabaseByPhone(
        phoneNumber,
        companyId
      );

      // Add author username after sending message
      setTimeout(async () => {
        await findAndUpdateMessageAuthor(
          message,
          contactID,
          companyId,
          userName
        );
      }, 1000); // 500ms delay to ensure automatic message insertion completes
      // ... existing code ...
      // 5. Handle OpenAI integration for the receiver's contact
      if (contactData?.thread_id) {
        console.log("Using existing thread:", contactData.thread_id);
        await handleOpenAIMyMessage(message, contactData.thread_id);
      } else {
        console.log("Creating new OpenAI thread");
        try {
          const thread = await createThread();
          const threadID = thread.id;
          console.log("New thread created:", threadID);

          await sqlDb.query(
            `UPDATE contacts 
               SET thread_id = $1
               WHERE contact_id = $2 AND company_id = $3`,
            [threadID, contactID, companyId]
          );

          await handleOpenAIMyMessage(message, threadID);
        } catch (aiError) {
          console.error("Error creating AI thread:", aiError);
        }

        // 6. Handle bot tags for the receiver
        if (
          companyId === "020" ||
          companyId === "001" ||
          companyId === "0123" ||
          companyId === "0119"
        ) {
          console.log("Adding stop bot tag for company:", companyId);
          await sqlDb.query(
            `UPDATE contacts 
               SET tags = COALESCE(tags, '[]'::jsonb) || '"stop bot"'::jsonb
               WHERE contact_id = $1 AND company_id = $2`,
            [contactID, companyId]
          );
        }
      }

      // 7. Handle AI Responses for Own Messages
      // console.log("\n=== Processing AI Responses in Messaging API ===");
      // await fetchConfigFromDatabase(companyId);
      // const handlerParams = {
      //   client: client,
      //   msg: message,
      //   idSubstring: companyId,
      //   extractedNumber: phoneNumber,
      //   contactName:
      //     contactData?.contact_name || contactData?.name || phoneNumber,
      //   phoneIndex: phoneIndex,
      // };

      // // Process AI responses for 'own'
      // await processAIResponses({
      //   ...handlerParams,
      //   keywordSource: "own",
      //   handlers: {
      //     assign: true,
      //     tag: true,
      //     followUp: true,
      //     document: true,
      //     image: true,
      //     video: true,
      //     voice: true,
      //   },
      // });

      console.log("\n=== Message Processing Complete ===");
      res.json({
        success: true,
        messageId: sentMessage?.id?._serialized ?? "no id",
        timestamp: sentMessage?.timestamp ?? "no timestamp",
      });
    } catch (dbError) {
      console.error("\n=== Database Error ===");
      console.error("Error Type:", dbError.name);
      console.error("Error Message:", dbError.message);
      console.error("Stack:", dbError.stack);
      throw dbError;
    }
  } catch (error) {
    console.error("\n=== Request Error ===");
    console.error("Error Type:", error.name);
    console.error("Error Message:", error.message);
    console.error("Stack:", error.stack);
    res.status(500).json({
      error: "Internal Server Error",
      details: error.message,
      timestamp: new Date().toISOString(),
    });
  }
});

async function findAndUpdateMessageAuthor(
  messageContent,
  contactId,
  companyId,
  userName
) {
  console.log("Finding and updating message author based on content");

  try {
    const client = await getDatabaseConnection();
    if (!client) {
      console.error(
        "Failed to get database connection - aborting findAndUpdateMessageAuthor"
      );
      return null;
    }

    try {
      await client.query("BEGIN");

      // Search for the latest message with matching content for this contact
      const findMessageQuery = `
        SELECT id, message_id, content, author, timestamp 
        FROM public.messages 
        WHERE contact_id = $1 AND company_id = $2 AND content = $3 AND from_me = true
        ORDER BY timestamp DESC, id DESC
        LIMIT 1
        FOR UPDATE
      `;

      const messageResult = await client.query(findMessageQuery, [
        contactId,
        companyId,
        messageContent,
      ]);

      if (messageResult.rows.length === 0) {
        console.log(
          "No matching message found with content:",
          messageContent.substring(0, 50) + "..."
        );
        await safeRollback(client);
        return null;
      }

      const foundMessage = messageResult.rows[0];
      console.log(
        `Found message ID: ${foundMessage.id} with timestamp: ${foundMessage.timestamp}`
      );

      // Update the author if it's different or null
      if (!foundMessage.author || foundMessage.author !== userName) {
        const updateQuery = `
          UPDATE public.messages
          SET author = $1
          WHERE id = $2
          RETURNING id, author
        `;
        const updateResult = await client.query(updateQuery, [
          userName,
          foundMessage.id,
        ]);

        console.log(
          `Successfully updated author for message ID: ${updateResult.rows[0].id} to: ${updateResult.rows[0].author}`
        );

        await client.query("COMMIT");
        return updateResult.rows[0].id;
      } else {
        console.log("Author already set to the same value, no update needed");
        await client.query("COMMIT");
        return foundMessage.id;
      }
    } catch (error) {
      await safeRollback(client);
      console.error(
        "Error finding/updating message author in PostgreSQL:",
        error
      );
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("PostgreSQL connection error:", error);
    throw error;
  }
}

// React to message
app.post("/api/messages/react/:companyId/:messageId", async (req, res) => {
  const { companyId, messageId } = req.params;
  const { reaction, phoneIndex = 0, contactId, content } = req.body;

  try {
    // Validate the reaction
    if (reaction === undefined) {
      return res.status(400).json({ error: "Reaction emoji is required" });
    }

    // Get the bot client
    const botData = botMap.get(companyId);
    if (!botData || !botData[phoneIndex] || !botData[phoneIndex].client) {
      return res.status(404).json({ error: "WhatsApp client not found" });
    }

    const client = botData[phoneIndex].client;

    // Get the message by ID
    const message = await client.getMessageById(messageId);
    if (!message) {
      return res.status(404).json({ error: "Message not found" });
    }

    // Send the reaction
    await message.react(reaction);

    // Update reaction in PostgreSQL
    const dbClient = await getDatabaseConnection();
    if (!dbClient) {
      console.error(
        "Failed to get database connection - aborting reaction update"
      );
      return res
        .status(500)
        .json({ error: "Reaction sent but failed to update database" });
    }

    try {
      await dbClient.query("BEGIN");

      // Try to update by message_id first, then fallback to contact_id + content
      let messageUpdateQuery = `
        UPDATE public.messages 
        SET 
          reaction = $1,
          reaction_timestamp = $2
        WHERE 
          message_id = $3 AND 
          company_id = $4
        RETURNING id, contact_id
      `;

      let messageUpdateValues = [
        reaction || null,
        new Date(),
        messageId,
        companyId,
      ];

      let messageResult = await dbClient.query(
        messageUpdateQuery,
        messageUpdateValues
      );

      // If message_id not found, try to find by contact_id + content
      if (messageResult.rowCount === 0 && contactId && content) {
        console.log(
          `Message ${messageId} not found, trying contact_id + content lookup`
        );

        messageUpdateQuery = `
          UPDATE public.messages 
          SET 
            reaction = $1,
            reaction_timestamp = $2
          WHERE 
            contact_id = $3 AND 
            company_id = $4 AND
            content = $5
          RETURNING id, contact_id
        `;

        messageUpdateValues = [
          reaction || null,
          new Date(),
          contactId,
          companyId,
          content,
        ];

        messageResult = await dbClient.query(
          messageUpdateQuery,
          messageUpdateValues
        );
      }

      if (messageResult.rowCount === 0) {
        await dbClient.query("ROLLBACK");
        console.warn(
          `Message ${messageId} found in WhatsApp but not in PostgreSQL`
        );
        return res.json({
          success: true,
          message: reaction
            ? "Reaction added to WhatsApp only"
            : "Reaction removed from WhatsApp only",
          messageId,
          reaction,
        });
      }

      await dbClient.query("COMMIT");

      res.json({
        success: true,
        message: reaction
          ? "Reaction added successfully"
          : "Reaction removed successfully",
        messageId,
        reaction,
      });
    } catch (error) {
      await dbClient.query("ROLLBACK");
      console.error("Error updating reaction in PostgreSQL:", error);
      res.status(500).json({
        error: "Reaction sent but failed to update database",
        details: error.message,
      });
    } finally {
      await safeRelease(dbClient);
    }
  } catch (error) {
    console.error("Error reacting to message:", error);
    res.status(500).json({
      error: "Failed to react to message",
      details: error.message,
    });
  }
});
// Edit message route
app.put("/api/v2/messages/:companyId/:chatId/:messageId", async (req, res) => {
  console.log("Edit message");
  const { companyId, chatId, messageId } = req.params;
  const { newMessage } = req.body;

  try {
    // Get the client for this company from botMap
    const botData = botMap.get(companyId);
    if (!botData || !botData[0] || !botData[0].client) {
      return res.status(404).send("WhatsApp client not found for this company");
    }
    const client = botData[0].client;

    // Get the chat
    const chat = await client.getChatById(chatId);

    // Fetch the message
    const messages = await chat.fetchMessages({ limit: 1, id: messageId });
    if (messages.length === 0) {
      return res.status(404).send("Message not found");
    }
    const message = messages[0];

    // Edit the message
    const editedMessage = await message.edit(newMessage);

    if (editedMessage) {
      // Update the message in PostgreSQL
      const client = await getDatabaseConnection();
      if (!client) {
        console.error(
          "Failed to get database connection - aborting message edit"
        );
        return res.status(500).send("Internal Server Error");
      }

      try {
        await client.query("BEGIN");

        const updateQuery = `
          UPDATE public.messages 
          SET 
            content = $1,
            edited = true,
            edited_at = $2
          WHERE 
            message_id = $3 AND 
            company_id = $4 AND
            chat_id = $5
          RETURNING id
        `;

        const updateValues = [
          newMessage,
          new Date(),
          messageId,
          companyId,
          chatId,
        ];

        const result = await client.query(updateQuery, updateValues);

        if (result.rowCount === 0) {
          await safeRollback(client);
          return res
            .status(404)
            .json({ success: false, error: "Message not found in database" });
        }

        await client.query("COMMIT");
        res.json({ success: true, messageId: messageId });
      } catch (error) {
        await safeRollback(client);
        console.error("Error updating message in PostgreSQL:", error);
        res.status(500).send("Internal Server Error");
      } finally {
        await safeRelease(client);
      }
    } else {
      res.status(400).json({ success: false, error: "Failed to edit message" });
    }
  } catch (error) {
    console.error("Error editing message:", error);
    res.status(500).send("Internal Server Error");
  }
});

// Delete message route

app.delete(
  "/api/v2/messages/:companyId/:chatId/:messageId",
  async (req, res) => {
    console.log("Delete message - Starting");
    const { companyId, chatId, messageId } = req.params;
    const { deleteForEveryone, phoneIndex: requestedPhoneIndex } = req.body;

    console.log("Delete message - Params:", {
      companyId,
      chatId,
      messageId,
      deleteForEveryone,
      requestedPhoneIndex,
    });

    const phoneIndex =
      requestedPhoneIndex !== undefined ? parseInt(requestedPhoneIndex) : 0;

    try {
      // Get the client for this company from botMap
      console.log("Delete message - Getting bot data for company:", companyId);
      const botData = botMap.get(companyId);
      if (!botData || !botData[phoneIndex] || !botData[phoneIndex].client) {
        console.log("Delete message - Bot data not found:", {
          companyId,
          phoneIndex,
          hasBotData: !!botData,
        });
        return res
          .status(404)
          .send("WhatsApp client not found for this company");
      }
      const client = botData[phoneIndex].client;
      console.log("Delete message - Got WhatsApp client");

      // Transform chat ID to WhatsApp format
      let whatsappChatId = chatId;
      if (chatId.includes("-")) {
        // Extract phone number from format like "0210-60126268707"
        const phoneNumber = chatId.split("-")[1];
        whatsappChatId = `${phoneNumber}@c.us`;
        console.log("Delete message - Transformed chat ID:", {
          original: chatId,
          transformed: whatsappChatId,
        });
      }

      // Get the chat
      console.log("Delete message - Getting chat by ID:", whatsappChatId);
      let chat;
      try {
        chat = await client.getChatById(whatsappChatId);
        console.log("Delete message - Got chat");
      } catch (chatError) {
        console.error("Delete message - Error getting chat:", chatError);
        console.error("Delete message - Chat error details:", {
          error: chatError.message,
          stack: chatError.stack,
          originalChatId: chatId,
          whatsappChatId: whatsappChatId,
        });
        return res.status(500).json({
          success: false,
          error: "Failed to get chat",
          details: chatError.message,
        });
      }

      // Fetch the message
      console.log("Delete message - Fetching message:", messageId);
      let messages;
      try {
        messages = await chat.fetchMessages({ limit: 1, id: messageId });
        console.log(
          "Delete message - Fetched messages, count:",
          messages.length
        );
      } catch (fetchError) {
        console.error("Delete message - Error fetching messages:", fetchError);
        console.error("Delete message - Fetch error details:", {
          error: fetchError.message,
          stack: fetchError.stack,
          messageId: messageId,
        });
        return res.status(500).json({
          success: false,
          error: "Failed to fetch message",
          details: fetchError.message,
        });
      }

      if (messages.length === 0) {
        console.log("Delete message - Message not found in chat");
        return res.status(404).send("Message not found");
      }
      const message = messages[0];
      console.log("Delete message - Got message, deleting from WhatsApp");

      // Delete the message
      try {
        console.log("Delete message - Message details:", {
          fromMe: message.fromMe,
          type: message.type,
          timestamp: message.timestamp,
          id: message.id,
        });

        // Check if we can delete for everyone (only if message is from us or we're admin)
        const deleteForEveryone2 = message.fromMe && deleteForEveryone === true;
        console.log(
          "Delete message - Delete for everyone:",
          deleteForEveryone2
        );

        await message.delete(deleteForEveryone2);
        console.log("Delete message - Deleted from WhatsApp successfully");
      } catch (deleteError) {
        console.error(
          "Delete message - Error deleting from WhatsApp:",
          deleteError
        );
        console.error("Delete message - Delete error details:", {
          error: deleteError.message,
          stack: deleteError.stack,
          messageId: messageId,
          messageFromMe: message?.fromMe,
          messageType: message?.type,
        });

        // If it's a permission error, return 403 instead of 500
        if (deleteError.message && deleteError.message.includes("permission")) {
          return res.status(403).json({
            success: false,
            error: "Permission denied to delete this message",
            details: deleteError.message,
          });
        }

        return res.status(500).json({
          success: false,
          error: "Failed to delete message from WhatsApp",
          details: deleteError.message,
        });
      }

      // Delete the message from PostgreSQL
      console.log("Delete message - Getting database connection");
      const dbClient = await getDatabaseConnection();
      if (!dbClient) {
        console.error(
          "Failed to get database connection - aborting message deletion"
        );
        return res.status(500).send("Internal Server Error");
      }

      try {
        await dbClient.query("BEGIN");
        console.log("Delete message - Database transaction started");

        const deleteQuery = `
            DELETE FROM public.messages 
            WHERE 
              message_id = $1 AND 
              company_id = $2
            RETURNING id
          `;

        const deleteValues = [message.id._serialized, companyId];
        console.log(
          "Delete message - Executing database delete with values:",
          deleteValues
        );

        const result = await dbClient.query(deleteQuery, deleteValues);
        console.log(
          "Delete message - Database delete result:",
          result.rowCount
        );

        if (result.rowCount === 0) {
          await dbClient.query("ROLLBACK");
          console.log("Delete message - No rows affected, rolling back");
          return res
            .status(404)
            .json({ success: false, error: "Message not found in database" });
        }

        await dbClient.query("COMMIT");
        console.log("Delete message - Database transaction committed");
        res.json({ success: true, messageId: messageId });
      } catch (error) {
        await dbClient.query("ROLLBACK");
        console.error("Error deleting message from PostgreSQL:", error);
        res.status(500).send("Internal Server Error");
      } finally {
        await safeRelease(dbClient);
      }
    } catch (error) {
      console.error("Error deleting message:", error);
      console.error("Error stack:", error.stack);
      res.status(500).send("Internal Server Error");
    }
  }
);

app.post("/api/v2/messages/image/:companyId/:chatId", async (req, res) => {
  const companyId = req.params.companyId;
  const chatId = req.params.chatId;
  const {
    imageUrl,
    caption,
    phoneIndex: requestedPhoneIndex,
    userName: requestedUserName,
  } = req.body;
  const phoneIndex =
    requestedPhoneIndex !== undefined ? parseInt(requestedPhoneIndex) : 0;
  const userName = requestedUserName !== undefined ? requestedUserName : "";

  try {
    let client;
    // 1. Get the client for this company from botMap
    const botData = botMap.get(companyId);
    if (!botData) {
      return res.status(404).send("WhatsApp client not found for this company");
    }
    client = botData[phoneIndex].client;

    if (!client) {
      return res
        .status(404)
        .send("No active WhatsApp client found for this company");
    }
    // 2. Use wwebjs to send the image message
    const media = await MessageMedia.fromUrl(imageUrl);
    const sentMessage = await client.sendMessage(chatId, media, { caption });
    let phoneNumber = "+" + chatId.split("@")[0];

    // 3. Save the message to Firebase
    const contactData = await getContactDataFromDatabaseByPhone(
      phoneNumber,
      companyId
    );

    await addMessageToPostgres(
      sentMessage,
      companyId,
      phoneNumber,
      contactData.name || contactData.contact_name || "",
      phoneIndex,
      userName
    );

    const contactID = companyId + "-" + chatId.split("@")[0];
    if (caption) {
      await findAndUpdateMessageAuthor(caption, contactID, companyId, userName);
    }

    res.json({ success: true, messageId: sentMessage.id._serialized });
  } catch (error) {
    console.error("Error sending image message:", error);
    res.status(500).send("Internal Server Error");
  }
});

app.post("/api/v2/messages/audio/:companyId/:chatId", async (req, res) => {
  const companyId = req.params.companyId;
  const chatId = req.params.chatId;
  const {
    audioUrl,
    caption,
    phoneIndex: requestedPhoneIndex,
    userName: requestedUserName,
  } = req.body;

  const phoneIndex =
    requestedPhoneIndex !== undefined ? parseInt(requestedPhoneIndex) : 0;
  const userName = requestedUserName !== undefined ? requestedUserName : "";

  try {
    // 1. Get the client for this company from botMap
    const botData = botMap.get(companyId);
    if (!botData) {
      return res.status(404).send("WhatsApp client not found for this company");
    }
    const client = botData[phoneIndex]?.client;
    if (!client) {
      return res
        .status(404)
        .send("No active WhatsApp client found for this company");
    }
    if (!audioUrl) {
      return res.status(400).send("No audio URL provided");
    }

    // 2. Download the audio file (assume it's already in a WhatsApp-compatible format, e.g. mp3, ogg, m4a)
    const response = await axios.get(audioUrl, { responseType: "arraybuffer" });
    const buffer = Buffer.from(response.data);

    // 3. Create MessageMedia object (try to detect mimetype from url or fallback to audio/mpeg)
    let mimetype = "audio/mpeg";
    if (audioUrl.endsWith(".ogg")) mimetype = "audio/ogg";
    else if (audioUrl.endsWith(".mp3")) mimetype = "audio/mpeg";
    else if (audioUrl.endsWith(".m4a")) mimetype = "audio/mp4";
    else if (audioUrl.endsWith(".wav")) mimetype = "audio/wav";
    else if (audioUrl.endsWith(".aac")) mimetype = "audio/aac";

    const filename = `audio_${Date.now()}.${mimetype.split("/")[1]}`;
    const media = new MessageMedia(
      mimetype,
      buffer.toString("base64"),
      filename
    );

    // 4. Send the audio as a voice message, with caption if provided
    const options = { sendAudioAsVoice: true };
    if (caption) options.caption = caption;

    const sentMessage = await client.sendMessage(chatId, media, options);

    let phoneNumber = "+" + chatId.split("@")[0];

    // 5. Save the message to database
    const contactData = await getContactDataFromDatabaseByPhone(
      phoneNumber,
      companyId
    );

    await addMessageToPostgres(
      sentMessage,
      companyId,
      phoneNumber,
      contactData?.name || contactData?.contact_name || "",
      phoneIndex,
      userName
    );

    const contactID = companyId + "-" + chatId.split("@")[0];
    if (caption) {
      await findAndUpdateMessageAuthor(caption, contactID, companyId, userName);
    }

    res.json({ success: true, messageId: sentMessage.id._serialized });
  } catch (error) {
    console.error("Error sending audio message:", error);
    res.status(500).send(`Internal Server Error: ${error.message}`);
  }
});

app.post("/api/request-pairing-code/:botName", async (req, res) => {
  const { botName } = req.params;
  const { phoneNumber, phoneIndex = 0 } = req.body;

  if (!phoneNumber) {
    return res.status(400).json({ error: "Phone number is required" });
  }

  // Remove any non-digit characters from the phone number
  const cleanedPhoneNumber = phoneNumber.replace(/\D/g, "");

  // Check if the cleaned phone number starts with a '+' and remove it
  const formattedPhoneNumber = cleanedPhoneNumber.startsWith("+")
    ? cleanedPhoneNumber.slice(1)
    : cleanedPhoneNumber;

  try {
    console.log(
      `Reinitializing bot ${botName} with pairing config for phone ${formattedPhoneNumber}`
    );

    // Clean up existing client if any
    const existingBotData = botMap.get(botName);
    if (
      existingBotData &&
      existingBotData[phoneIndex] &&
      existingBotData[phoneIndex].client
    ) {
      try {
        await existingBotData[phoneIndex].client.destroy();
        console.log(
          `Destroyed existing client for ${botName} Phone ${phoneIndex + 1}`
        );
      } catch (destroyError) {
        console.warn(
          `Error destroying existing client: ${destroyError.message}`
        );
      }
    }

    // Create pairing configuration
    const pairingConfig = {
      phoneNumber: formattedPhoneNumber,
    };

    console.log(
      `Starting bot reinitialization with pairing config:`,
      pairingConfig
    );

    // Reinitialize the bot with pairing configuration
    initializeBot(botName, 1, phoneIndex, pairingConfig);

    // Wait a moment for initialization to start
    console.log(`Waiting for initialization to start...`);
    await new Promise((resolve) => setTimeout(resolve, 3000));

    // Get the new client
    const botData = botMap.get(botName);
    if (!botData || !Array.isArray(botData) || !botData[phoneIndex]) {
      console.error(
        `Failed to get bot data after reinitialization for ${botName}`
      );
      return res
        .status(500)
        .json({ error: "Failed to reinitialize bot with pairing config" });
    }

    const { client } = botData[phoneIndex];
    if (!client) {
      console.error(
        `Failed to get client after reinitialization for ${botName}`
      );
      return res
        .status(500)
        .json({
          error: "WhatsApp client not initialized after reinitialization",
        });
    }

    console.log(
      `Client reinitialized successfully for ${botName}, waiting for pairing code...`
    );

    // Wait for the pairing code to appear in the database
    const pairingCodePromise = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error("Timeout waiting for pairing code"));
      }, 10000);

      const checkForPairingCode = async () => {
        try {
          console.log(
            `Checking database for pairing code for ${botName} Phone ${
              phoneIndex + 1
            }...`
          );
          const result = await sqlDb.query(
            `SELECT status, metadata FROM phone_status
             WHERE company_id = $1 AND phone_index = $2`,
            [botName, phoneIndex.toString()]
          );

          if (result.rows.length > 0) {
            const { status, metadata } = result.rows[0];

            if (status === "pairing_code" && metadata?.pairingCode) {
              clearTimeout(timeout);
              clearInterval(pollInterval);
              resolve(metadata.pairingCode);
              return;
            }
          }
        } catch (error) {
          console.error("Error checking for pairing code in database:", error);
        }
      };

      const pollInterval = setInterval(checkForPairingCode, 1000);

      checkForPairingCode();
    });

    // Wait for the pairing code to appear in the database
    const pairingCode = await pairingCodePromise;
    console.log(
      `Successfully received pairing code for ${botName}: ${pairingCode}`
    );

    // Send the pairing code back to the client
    res.json({
      pairingCode,
      message: `Bot ${botName} reinitialized with pairing config for ${formattedPhoneNumber}`,
      success: true,
    });
  } catch (error) {
    console.error(`Error requesting pairing code for ${botName}:`, error);
    res.status(500).json({
      error: "Failed to request pairing code",
      details: error.message,
    });
  }
});

app.post("/api/messages/image/:token", async (req, res) => {
  const { chatId, imageUrl, caption } = req.body;
  const token = req.params.token;
  try {
    const response = await fetch(`https://gate.whapi.cloud/messages/image`, {
      method: "POST",
      headers: {
        Authorization: "Bearer " + token,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ to: chatId, media: imageUrl, caption }),
    });
    const data = await response.json();
    res.json(data);
  } catch (error) {
    console.error("Error sending image message:", error);
    res.status(500).send("Internal Server Error");
  }
});

app.post("/api/messages/document/:token", async (req, res) => {
  const { chatId, imageUrl, caption, mimeType, fileName } = req.body;
  const token = req.params.token;
  try {
    const response = await fetch(`https://gate.whapi.cloud/messages/document`, {
      method: "POST",
      headers: {
        Authorization: "Bearer " + token,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        to: chatId,
        media: imageUrl,
        caption,
        filename: fileName,
        mimeType: mimeType,
      }),
    });
    const data = await response.json();
    res.json(data);
  } catch (error) {
    console.error("Error sending image message:", error);
    res.status(500).send("Internal Server Error");
  }
});

app.post("/api/fetch-users", async (req, res) => {
  const { accessToken, locationId } = req.body;
  const maxRetries = 5;
  const baseDelay = 5000;

  const fetchData = async (url, retries = 0) => {
    const options = {
      method: "GET",
      url: url,
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Version: "2021-07-28",
        Accept: "application/json",
      },
      params: {
        locationId: locationId,
      },
    };
    try {
      const response = await axios.request(options);
      return response;
    } catch (error) {
      if (
        error.response &&
        error.response.status === 429 &&
        retries < maxRetries
      ) {
        const delay = baseDelay * Math.pow(2, retries);
        console.warn(`Rate limit hit, retrying in ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
        return fetchData(url, retries + 1);
      } else {
        console.error("Error during fetchData:", error);
        throw error;
      }
    }
  };

  try {
    const url = `https://services.leadconnectorhq.com/users/`;
    const response = await fetchData(url);
    res.json(response.data.users);
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).send("Error fetching users");
  }
});

app.delete("/api/contacts/:companyId/:contactId/tags", async (req, res) => {
  const { companyId, contactId } = req.params;
  let { tags } = req.body; // tags: array of tags to remove
  if (!Array.isArray(tags)) {
    return res.status(400).json({ error: "tags must be an array" });
  }

  // Normalize stop bot tags
  tags = tags.map((tag) =>
    typeof tag === "string" &&
    tag.trim().toLowerCase().replace(/\s+/g, "") === "stopbot"
      ? "stop bot"
      : tag
  );

  try {
    let phoneNumber;
    if (contactId.startsWith(`${companyId}-`)) {
      const contactIdParts = contactId.split("-");
      phoneNumber = "+" + contactIdParts[1];
    } else {
      phoneNumber = contactId;
    }

    const response = { tags: tags };
    const followupTemplate = await getFollowUpTemplates(companyId);
    await handleTagDeletion(response, phoneNumber, companyId, followupTemplate);

    res.json({ success: true, tags: tags }); // Return the tags that were removed
  } catch (error) {
    res
      .status(500)
      .json({ error: "Failed to remove tags", details: error.message });
  }
});

app.post("/api/contacts/:companyId/:contactId/tags", async (req, res) => {
  const { companyId, contactId } = req.params;
  let { tags } = req.body; // tags: array of tags to add
  if (!Array.isArray(tags)) {
    return res.status(400).json({ error: "tags must be an array" });
  }

  // Normalize stop bot tags
  tags = tags.map((tag) =>
    typeof tag === "string" &&
    tag.trim().toLowerCase().replace(/\s+/g, "") === "stopbot"
      ? "stop bot"
      : tag
  );

  try {
    let phoneNumber;
    if (contactId.startsWith(`${companyId}-`)) {
      const contactIdParts = contactId.split("-");
      phoneNumber = "+" + contactIdParts[1];
    } else {
      phoneNumber = contactId;
    }

    const response = { tags: tags };
    const followupTemplate = await getFollowUpTemplates(companyId);
    await handleTagAddition(
      response,
      phoneNumber,
      companyId,
      followupTemplate,
      null,
      0
    );
    res.json({ success: true, tags: tags });
  } catch (error) {
    res
      .status(500)
      .json({ error: "Failed to add tags", details: error.message });
  }
});

// Assign employee to contact
// ... existing code ...
// ... existing code ...

app.post(
  "/api/contacts/:companyId/:contactId/assign-employee",
  async (req, res) => {
    const { companyId, contactId } = req.params;
    const { employeeName } = req.body;

    if (!employeeName) {
      return res.status(400).json({ error: "employeeName is required" });
    }

    try {
      let phoneNumber;
      if (contactId.startsWith(`${companyId}-`)) {
        const contactIdParts = contactId.split("-");
        phoneNumber = "+" + contactIdParts[1];
      } else {
        phoneNumber = contactId;
      }

      const client = await getDatabaseConnection();
      if (!client) {
        console.error(
          "Failed to get database connection - aborting employee assignment"
        );
        return res.status(500).json({ error: "Failed to assign employee" });
      }

      try {
        await client.query("BEGIN");

        // 1. Update the contact to assign the employee
        const updateContactQuery = `
        UPDATE contacts 
        SET tags = CASE 
          WHEN tags::jsonb ? $3 THEN tags::jsonb
          ELSE COALESCE(tags::jsonb, '[]'::jsonb) || $4::jsonb
        END
        WHERE phone = $1 AND company_id = $2
        RETURNING *
      `;

        const employeeNameArray = JSON.stringify([employeeName]);
        const updateResult = await client.query(updateContactQuery, [
          phoneNumber,
          companyId,
          employeeName,
          employeeNameArray,
        ]);

        if (updateResult.rows.length === 0) {
          await safeRollback(client);
          return res.status(404).json({ error: "Contact not found" });
        }

        // 2. Update employee's assigned_contacts count
        const employeeUpdateQuery = `
        UPDATE employees
        SET assigned_contacts = assigned_contacts + 1
        WHERE company_id = $1 AND name = $2
        RETURNING id, employee_id, name, assigned_contacts
      `;

        const employeeResult = await client.query(employeeUpdateQuery, [
          companyId,
          employeeName,
        ]);

        if (employeeResult.rows.length === 0) {
          await safeRollback(client);
          return res.status(404).json({ error: "Employee not found" });
        }

        // 3. Get contact details for assignments table
        const contactQuery = `
        SELECT contact_id FROM contacts 
        WHERE phone = $1 AND company_id = $2
      `;
        const contactResult = await client.query(contactQuery, [
          phoneNumber,
          companyId,
        ]);

        if (contactResult.rows.length === 0) {
          await safeRollback(client);
          return res
            .status(404)
            .json({ error: "Contact not found in database" });
        }

        // 4. Insert into assignments table
        const currentDate = new Date();
        const currentMonthKey = `${currentDate.getFullYear()}-${(
          currentDate.getMonth() + 1
        )
          .toString()
          .padStart(2, "0")}`;

        const assignmentId = `${companyId}-${
          contactResult.rows[0].contact_id
        }-${employeeResult.rows[0].employee_id}-${Date.now()}`;

        const assignmentInsertQuery = `
        INSERT INTO assignments (
          assignment_id, company_id, employee_id, contact_id, 
          assigned_at, status, month_key, assignment_type, 
          phone_index, weightage_used
        ) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, 'active', $5, 'manual', 0, 1)
      `;

        await client.query(assignmentInsertQuery, [
          assignmentId,
          companyId,
          employeeResult.rows[0].employee_id,
          contactResult.rows[0].contact_id,
          currentMonthKey,
        ]);

        // 5. Update monthly assignments
        const monthlyAssignmentUpsertQuery = `
        INSERT INTO employee_monthly_assignments (employee_id, company_id, month_key, assignments_count, last_updated)
        VALUES ($1, $2, $3, 1, CURRENT_TIMESTAMP)
        ON CONFLICT (employee_id, month_key) DO UPDATE
        SET assignments_count = employee_monthly_assignments.assignments_count + 1,
            last_updated = CURRENT_TIMESTAMP
      `;

        await client.query(monthlyAssignmentUpsertQuery, [
          employeeResult.rows[0].id,
          companyId,
          currentMonthKey,
        ]);

        await client.query("COMMIT");

        // ... existing code ...
        // 6. Send notification message to the employee (not the contact)
        try {
          const botData = botMap.get(companyId);
          if (botData && botData[0]?.client) {
            const whatsappClient = botData[0].client;

            // Get employee's phone number for notification
            const employeePhoneQuery = `
            SELECT phone_number FROM employees 
            WHERE company_id = $1 AND name = $2
          `;
            const employeePhoneResult = await client.query(employeePhoneQuery, [
              companyId,
              employeeName,
            ]);

            if (
              employeePhoneResult.rows.length > 0 &&
              employeePhoneResult.rows[0].phone_number
            ) {
              const employeePhone = employeePhoneResult.rows[0].phone_number;
              const employeeChatId = employeePhone.replace("+", "") + "@c.us";

              // Get the last message from this contact for context
              const lastMessageQuery = `
              SELECT content, timestamp, message_type
              FROM messages 
              WHERE company_id = $1 
                AND customer_phone = $2 
                AND from_me = false
              ORDER BY timestamp DESC 
              LIMIT 1
            `;

              let lastMessageInfo = "";
              try {
                const lastMessageResult = await client.query(lastMessageQuery, [
                  companyId,
                  phoneNumber,
                ]);
                if (lastMessageResult.rows.length > 0) {
                  const lastMsg = lastMessageResult.rows[0];
                  const messageType = lastMsg.message_type || "text";
                  const messageContent = lastMsg.content || "No content";
                  const messageTime = new Date(
                    lastMsg.timestamp
                  ).toLocaleString();

                  lastMessageInfo = `\n💬 *Last Message (${messageType}):*\n"${messageContent}"\n⏰ ${messageTime}`;
                }
              } catch (msgError) {
                console.warn("Could not fetch last message:", msgError.message);
                lastMessageInfo = "\n💬 *Last Message:* Unable to retrieve";
              }

              const notificationMessage = `🎯 *New Contact Assignment*\n\nHello ${employeeName}! A new contact has been assigned to you.\n\n�� *Contact Details:*\n• Contact Number: ${phoneNumber}\n• Assigned Date: ${new Date().toLocaleDateString()}\n• Time: ${new Date().toLocaleTimeString()}${lastMessageInfo}\n\nPlease take action on this new assignment.`;

              console.log(
                `Attempting to send notification to employee ${employeeName} at ${employeeChatId}`
              );

              const sentMessage = await whatsappClient.sendMessage(
                employeeChatId,
                notificationMessage
              );

              console.log(
                `WhatsApp message sent successfully:`,
                sentMessage ? "Yes" : "No"
              );

              // Don't try to save system messages to database - they're not real WhatsApp messages
              // The addMessageToPostgres function expects actual WhatsApp message objects

              console.log(
                `Notification message sent to employee ${employeeName} (${employeePhone}) for contact assignment`
              );
            } else {
              console.warn(
                `Employee ${employeeName} does not have a phone number - skipping notification message`
              );
            }
          } else {
            console.warn(
              `WhatsApp client not available for company ${companyId} - skipping notification message`
            );
          }
        } catch (messageError) {
          console.error("Error sending notification message:", {
            error: messageError,
            message: messageError.message,
            stack: messageError.stack,
            companyId,
            employeeName,
          });
          // Don't fail the entire operation if message sending fails
        }
        // ... existing code ...

        res.json({
          success: true,
          message: "Employee assigned successfully",
          contact: updateResult.rows[0],
          employee: employeeResult.rows[0],
        });
      } catch (error) {
        await safeRollback(client);
        throw error;
      } finally {
        await safeRelease(client);
      }
    } catch (error) {
      console.error("Error assigning employee to contact:", error);
      res.status(500).json({
        error: "Failed to assign employee",
        details: error.message,
      });
    }
  }
);

// ... existing code ...

// Bulk unassign all employees from contact
app.delete(
  "/api/contacts/:companyId/:contactId/assignments",
  async (req, res) => {
    const { companyId, contactId } = req.params;

    try {
      let phoneNumber;
      if (contactId.startsWith(`${companyId}-`)) {
        const contactIdParts = contactId.split("-");
        phoneNumber = "+" + contactIdParts[1];
      } else {
        phoneNumber = contactId;
      }

      const client = await getDatabaseConnection();
      if (!client) {
        console.error(
          "Failed to get database connection - aborting bulk unassignment"
        );
        return res.status(500).json({ error: "Failed to unassign employees" });
      }

      try {
        await client.query("BEGIN");

        // 1. Get current contact and all assigned employees
        const getContactQuery = `
        SELECT tags, contact_id FROM contacts 
        WHERE phone = $1 AND company_id = $2
      `;
        const contactResult = await client.query(getContactQuery, [
          phoneNumber,
          companyId,
        ]);

        if (contactResult.rows.length === 0) {
          await safeRollback(client);
          return res.status(404).json({ error: "Contact not found" });
        }

        // 2. Get all active assignments for this contact
        const getAssignmentsQuery = `
        SELECT DISTINCT a.employee_id, e.name, e.id as employee_uuid
        FROM assignments a
        JOIN employees e ON a.employee_id = e.employee_id
        WHERE a.company_id = $1 
          AND a.contact_id = $2 
          AND a.status = 'active'
      `;

        const assignmentsResult = await client.query(getAssignmentsQuery, [
          companyId,
          contactResult.rows[0].contact_id,
        ]);

        if (assignmentsResult.rows.length === 0) {
          await safeRollback(client);
          return res
            .status(404)
            .json({ error: "No active assignments found for this contact" });
        }

        const assignedEmployees = assignmentsResult.rows;
        const employeeNames = assignedEmployees.map((emp) => emp.name);

        // 3. Remove all employee names from contact tags
        const currentTags = contactResult.rows[0].tags || [];
        const updatedTags = currentTags.filter(
          (tag) => !employeeNames.includes(tag)
        );

        const updateContactQuery = `
        UPDATE contacts 
        SET tags = $3
        WHERE phone = $1 AND company_id = $2
        RETURNING *
      `;

        const updateResult = await client.query(updateContactQuery, [
          phoneNumber,
          companyId,
          JSON.stringify(updatedTags),
        ]);

        // 4. Update all employees' assigned_contacts count
        for (const employee of assignedEmployees) {
          const employeeUpdateQuery = `
          UPDATE employees
          SET assigned_contacts = GREATEST(assigned_contacts - 1, 0)
          WHERE company_id = $1 AND employee_id = $2
        `;

          await client.query(employeeUpdateQuery, [
            companyId,
            employee.employee_id,
          ]);
        }

        // 5. Update all assignment records to 'inactive'
        const updateAssignmentsQuery = `
        UPDATE assignments 
        SET status = 'inactive', 
            updated_at = CURRENT_TIMESTAMP
        WHERE company_id = $1 
          AND contact_id = $2 
          AND status = 'active'
      `;

        await client.query(updateAssignmentsQuery, [
          companyId,
          contactResult.rows[0].contact_id,
        ]);

        // 6. Update monthly assignments for all employees
        const currentDate = new Date();
        const currentMonthKey = `${currentDate.getFullYear()}-${(
          currentDate.getMonth() + 1
        )
          .toString()
          .padStart(2, "0")}`;

        for (const employee of assignedEmployees) {
          const monthlyAssignmentUpdateQuery = `
          UPDATE employee_monthly_assignments 
          SET assignments_count = GREATEST(assignments_count - 1, 0),
              last_updated = CURRENT_TIMESTAMP
          WHERE employee_id = $1 
            AND company_id = $2 
            AND month_key = $3
        `;

          await client.query(monthlyAssignmentUpdateQuery, [
            employee.employee_uuid,
            companyId,
            currentMonthKey,
          ]);
        }

        await client.query("COMMIT");

        // 7. Send notification message to the contact about unassignment
        try {
          const botData = botMap.get(companyId);
          if (botData && botData[0]?.client) {
            const whatsappClient = botData[0].client;
            const chatId = phoneNumber.replace("+", "") + "@c.us";

            // Get the last message from this contact
            const lastMessageQuery = `
            SELECT content, timestamp, message_type
            FROM messages 
            WHERE company_id = $1 
              AND customer_phone = $2 
              AND from_me = false
            ORDER BY timestamp DESC 
            LIMIT 1
          `;

            let lastMessageInfo = "";
            try {
              const lastMessageResult = await client.query(lastMessageQuery, [
                companyId,
                phoneNumber,
              ]);
              if (lastMessageResult.rows.length > 0) {
                const lastMsg = lastMessageResult.rows[0];
                const messageType = lastMsg.message_type || "text";
                const messageContent = lastMsg.content || "No content";
                const messageTime = new Date(
                  lastMsg.timestamp
                ).toLocaleString();

                lastMessageInfo = `\n💬 *Last Message (${messageType}):*\n"${messageContent}"\n⏰ ${messageTime}`;
              }
            } catch (msgError) {
              console.warn("Could not fetch last message:", msgError.message);
              lastMessageInfo = "\n💬 *Last Message:* Unable to retrieve";
            }

            const unassignmentMessage = `🎯 *Contact Assignment Update*\n\nHello! Your contact assignments have been updated.\n\n📋 *Unassignment Details:*\n• Contact Number: ${phoneNumber}\n• Unassigned Employees: ${employeeNames.join(
              ", "
            )}\n• Updated Date: ${new Date().toLocaleDateString()}\n• Time: ${new Date().toLocaleTimeString()}${lastMessageInfo}\n\nThank you for choosing our services!`;

            const sentMessage = await whatsappClient.sendMessage(
              chatId,
              unassignmentMessage
            );

            // Save the notification message to database
            if (sentMessage) {
              await addMessageToPostgres(
                sentMessage,
                companyId,
                phoneNumber,
                updateResult.rows[0].name ||
                  updateResult.rows[0].contact_name ||
                  "",
                0, // phoneIndex
                "System" // userName
              );
            }

            console.log(
              `Unassignment notification message sent to ${phoneNumber}`
            );
          } else {
            console.warn(
              `WhatsApp client not available for company ${companyId} - skipping notification message`
            );
          }
        } catch (messageError) {
          console.error(
            "Error sending unassignment notification message:",
            messageError
          );
          // Don't fail the entire operation if message sending fails
        }

        res.json({
          success: true,
          message: `Successfully unassigned ${assignedEmployees.length} employee(s)`,
          contact: updateResult.rows[0],
          unassignedEmployees: employeeNames,
          removedTags: employeeNames,
        });
      } catch (error) {
        await safeRollback(client);
        throw error;
      } finally {
        await safeRelease(client);
      }
    } catch (error) {
      console.error("Error bulk unassigning employees from contact:", error);
      res.status(500).json({
        error: "Failed to unassign employees",
        details: error.message,
      });
    }
  }
);

// ... existing code ...
// Get all assignments for a contact
app.get("/api/contacts/:companyId/:contactId/assignments", async (req, res) => {
  const { companyId, contactId } = req.params;

  try {
    let phoneNumber;
    if (contactId.startsWith(`${companyId}-`)) {
      const contactIdParts = contactId.split("-");
      phoneNumber = "+" + contactIdParts[1];
    } else {
      phoneNumber = contactId;
    }

    const client = await getDatabaseConnection();
    if (!client) {
      console.error(
        "Failed to get database connection - aborting assignments fetch"
      );
      return res
        .status(500)
        .json({ error: "Failed to get contact assignments" });
    }

    try {
      // 1. Get contact details
      const getContactQuery = `
        SELECT contact_id, tags FROM contacts 
        WHERE phone = $1 AND company_id = $2
      `;
      const contactResult = await client.query(getContactQuery, [
        phoneNumber,
        companyId,
      ]);

      if (contactResult.rows.length === 0) {
        return res.status(404).json({ error: "Contact not found" });
      }

      // 2. Get all assignments (both active and inactive) for this contact
      const getAssignmentsQuery = `
        SELECT 
          a.assignment_id,
          a.employee_id,
          a.assigned_at,
          a.status,
          a.assignment_type,
          a.phone_index,
          a.weightage_used,
          a.employee_role,
          a.month_key,
          e.name as employee_name,
          e.email as employee_email,
          e.role as employee_role_from_employees,
          e.phone_number as employee_phone
        FROM assignments a
        JOIN employees e ON a.employee_id = e.employee_id
        WHERE a.company_id = $1 AND a.contact_id = $2
        ORDER BY a.assigned_at DESC
      `;

      const assignmentsResult = await client.query(getAssignmentsQuery, [
        companyId,
        contactResult.rows[0].contact_id,
      ]);

      // 3. Separate active and inactive assignments
      const activeAssignments = assignmentsResult.rows.filter(
        (a) => a.status === "active"
      );
      const inactiveAssignments = assignmentsResult.rows.filter(
        (a) => a.status === "inactive"
      );

      res.json({
        success: true,
        contact: {
          contact_id: contactResult.rows[0].contact_id,
          phone: phoneNumber,
          tags: contactResult.rows[0].tags,
        },
        assignments: {
          active: activeAssignments,
          inactive: inactiveAssignments,
          total: assignmentsResult.rows.length,
        },
        summary: {
          activeCount: activeAssignments.length,
          inactiveCount: inactiveAssignments.length,
          totalCount: assignmentsResult.rows.length,
        },
      });
    } catch (error) {
      throw error;
    } finally {
      await safeRelease(client);
    }
  } catch (error) {
    console.error("Error getting contact assignments:", error);
    res.status(500).json({
      error: "Failed to get contact assignments",
      details: error.message,
    });
  }
});

async function customWait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}

app.post("/api/v2/messages/video/:companyId/:chatId", async (req, res) => {
  const companyId = req.params.companyId;
  const chatId = req.params.chatId;
  const {
    videoUrl,
    caption,
    phoneIndex: requestedPhoneIndex,
    userName: requestedUserName,
  } = req.body;
  const phoneIndex =
    requestedPhoneIndex !== undefined ? parseInt(requestedPhoneIndex) : 0;
  const userName = requestedUserName !== undefined ? requestedUserName : "";

  try {
    let client;
    // 1. Get the client forl this company from botMap
    const botData = botMap.get(companyId);
    if (!botData) {
      return res.status(404).send("WhatsApp client not found for this company");
    }
    client = botData[phoneIndex].client;

    if (!client) {
      return res
        .status(404)
        .send("No active WhatsApp client found for this company");
    }

    // 2. Use wwebjs to send the video message
    const media = await MessageMedia.fromUrl(videoUrl);
    const sentMessage = await client.sendMessage(chatId, media, { caption });
    let phoneNumber = "+" + chatId.split("@")[0];

    // 3. Save the message to Database
    const contactData = await getContactDataFromDatabaseByPhone(
      phoneNumber,
      companyId
    );

    await addMessageToPostgres(
      sentMessage,
      companyId,
      phoneNumber,
      contactData.name || contactData.contact_name || "",
      phoneIndex,
      userName
    );

    const contactID = companyId + "-" + chatId.split("@")[0];
    if (caption) {
      await findAndUpdateMessageAuthor(caption, contactID, companyId, userName);
    }

    res.json({ success: true, messageId: sentMessage.id._serialized });
  } catch (error) {
    console.error("Error sending video message:", error);
    res.status(500).send("Internal Server Error");
  }
});

app.post("/api/v2/messages/document/:companyId/:chatId", async (req, res) => {
  const companyId = req.params.companyId;
  const chatId = req.params.chatId;
  const {
    documentUrl,
    filename,
    caption,
    phoneIndex: requestedPhoneIndex,
    userName: requestedUserName,
  } = req.body;
  const phoneIndex =
    requestedPhoneIndex !== undefined ? parseInt(requestedPhoneIndex) : 0;
  const userName = requestedUserName !== undefined ? requestedUserName : "";

  console.log("\n=== New Document Message Request ===");
  console.log("Request details:", {
    companyId,
    chatId,
    documentUrl,
    filename,
    caption,
    requestedPhoneIndex,
    userName: requestedUserName,
    phoneIndex,
    userName,
  });

  try {
    let client;
    // 1. Get the client for this company from botMap
    const botData = botMap.get(companyId);
    if (!botData) {
      console.error("WhatsApp client not found for this company");
      return res.status(404).send("WhatsApp client not found for this company");
    }
    client = botData[phoneIndex].client;

    if (!client) {
      console.error("No active WhatsApp client found for this company");
      return res
        .status(404)
        .send("No active WhatsApp client found for this company");
    }

    // 2. Use wwebjs to send the document message
    const media = await MessageMedia.fromUrl(documentUrl, {
      unsafeMime: true,
      filename: filename,
    });
    const sentMessage = await client.sendMessage(chatId, media, { caption });
    console.log("Message sent successfully:", {
      messageId: sentMessage?.id?._serialized ?? "no id",
      timestamp: sentMessage?.timestamp ?? "no timestamp",
      type: sentMessage?.type ?? "no type",
    });
    let phoneNumber = "+" + chatId.split("@")[0];

    // 3. Save the message to Database
    const contactData = await getContactDataFromDatabaseByPhone(
      phoneNumber,
      companyId
    );

    await addMessageToPostgres(
      sentMessage,
      companyId,
      phoneNumber,
      contactData?.name || contactData?.contact_name || "",
      phoneIndex,
      userName
    );

    const contactID = companyId + "-" + chatId.split("@")[0];
    if (caption) {
      await findAndUpdateMessageAuthor(caption, contactID, companyId, userName);
    }

    res.json({ success: true, messageId: sentMessage.id._serialized });
  } catch (error) {
    console.error("Error sending document message:", error);
    res.status(500).send("Internal Server Error");
  }
});

app.post("/api/user/update-phone", async (req, res) => {
  try {
    const { email, phoneIndex } = req.body;
    console.log("updating phone index", email, phoneIndex);
    if (!email || phoneIndex === undefined) {
      return res.status(400).json({
        error: "Email and phoneIndex are required",
      });
    }

    // Validate phoneIndex is a number
    const validatedPhoneIndex = parseInt(phoneIndex);
    if (isNaN(validatedPhoneIndex) || validatedPhoneIndex < 0) {
      return res.status(400).json({
        error: "phoneIndex must be a valid non-negative number",
      });
    }

    console.log(
      `Updating phone index for user ${email} to ${validatedPhoneIndex}`
    );

    // Update the user's phone field in the users table
    const updateResult = await sqlDb.query(
      `UPDATE users 
       SET phone = $1, last_updated = CURRENT_TIMESTAMP
       WHERE email = $2
       RETURNING user_id, name, email, phone, company_id`,
      [validatedPhoneIndex, email]
    );

    if (updateResult.rowCount === 0) {
      return res.status(404).json({
        error: "User not found",
      });
    }

    console.log(
      `Successfully updated phone index for user ${email} to ${validatedPhoneIndex}`
    );

    res.json({
      success: true,
      message: "Phone index updated successfully",
      data: {
        email: updateResult.rows[0].email,
        name: updateResult.rows[0].name,
        phoneIndex: updateResult.rows[0].phone,
        userId: updateResult.rows[0].user_id,
        companyId: updateResult.rows[0].company_id,
      },
    });
  } catch (error) {
    console.error("Error updating user phone index:", error);
    res.status(500).json({
      error: "Failed to update phone index",
      details: error.message,
    });
  }
});

app.put("/api/update-phone-name", async (req, res) => {
  try {
    const { companyId, phoneIndex, phoneName } = req.body;
    console.log("Updating phone name:", { companyId, phoneIndex, phoneName });

    if (!companyId || phoneIndex === undefined || phoneName === undefined) {
      return res.status(400).json({
        error: "Company ID, phone index, and phone name are required",
      });
    }

    // Fetch current phone_numbers array
    const companyResult = await sqlDb.query(
      "SELECT phone_numbers FROM companies WHERE company_id = $1",
      [companyId]
    );
    if (companyResult.rows.length === 0) {
      return res.status(404).json({ error: "Company not found" });
    }

    console.log(
      "Raw phone_numbers from database:",
      companyResult.rows[0].phone_numbers
    );
    let phoneNumbers = [];
    if (companyResult.rows[0].phone_numbers) {
      try {
        // Accept both stringified array and array
        if (typeof companyResult.rows[0].phone_numbers === "string") {
          phoneNumbers = JSON.parse(companyResult.rows[0].phone_numbers);
        } else if (Array.isArray(companyResult.rows[0].phone_numbers)) {
          phoneNumbers = companyResult.rows[0].phone_numbers;
        }
      } catch (e) {
        phoneNumbers = [];
      }
    }

    console.log("Before update - Current array:", phoneNumbers);
    console.log("Target phoneIndex:", phoneIndex, "New phoneName:", phoneName);

    // Ensure the array is long enough, only extending if needed
    while (phoneNumbers.length <= phoneIndex) {
      phoneNumbers.push("");
    }
    phoneNumbers[phoneIndex] = phoneName;

    console.log("After update - New array:", phoneNumbers);

    // Update the phone_numbers array in the database
    await sqlDb.query(
      "UPDATE companies SET phone_numbers = $1 WHERE company_id = $2",
      [JSON.stringify(phoneNumbers), companyId]
    );
    console.log("Phone name updated successfully:", phoneNumbers);

    res.json({
      success: true,
      message: "Phone name updated successfully",
      phoneNumbers,
    });
  } catch (error) {
    console.error("Error updating phone name:", error);
    res
      .status(500)
      .json({ success: false, error: "Failed to update phone name" });
  }
});

// Add this right after your existing endpoint (around line 12640)
app.get("/api/debug-routes", (req, res) => {
  res.json({
    message: "Debug endpoint working",
    timestamp: new Date().toISOString(),
    testEndpoint: "/api/user/update-phone should be available",
  });
});

async function copyDirectory(source, target, options = {}) {
  const {
    maxRetries = 3,
    retryDelay = 1000,
    skipLockedFiles = true,
    skipPatterns = [".db-journal", ".db-wal", ".db-shm", "lockfile"],
  } = options;

  // Validate paths
  if (!source || !target) {
    throw new Error("Source and target paths must be specified");
  }

  // Normalize paths
  source = path.resolve(source);
  target = path.resolve(target);

  // Check if source exists
  try {
    await fs.promises.access(source);
  } catch (err) {
    console.error(`Access error for source directory ${source}:`, err);
    throw new Error(
      `Source directory does not exist or is not accessible: ${source}`
    );
  }

  // Remove existing target if it exists
  try {
    if (await pathExists(target)) {
      await fs.promises.rm(target, { recursive: true, force: true });
    }
  } catch (err) {
    console.error(`Error removing target directory ${target}:`, err);
    throw err;
  }

  // Create target directory
  try {
    await fs.promises.mkdir(target, { recursive: true });
  } catch (err) {
    console.error(`Error creating target directory ${target}:`, err);
    throw err;
  }

  // Copy contents
  try {
    const files = await fs.promises.readdir(source);

    await Promise.all(
      files.map(async (file) => {
        const sourcePath = path.join(source, file);
        const targetPath = path.join(target, file);

        // Skip files matching skip patterns
        if (skipPatterns.some((pattern) => file.endsWith(pattern))) {
          if (skipLockedFiles) {
            console.log(`Skipping locked file: ${file}`);
            return;
          }
        }

        try {
          const stat = await fs.promises.stat(sourcePath);

          if (stat.isDirectory()) {
            await retryOperation(
              () => copyDirectory(sourcePath, targetPath, options),
              maxRetries,
              retryDelay,
              `Copy directory ${sourcePath} -> ${targetPath}`
            );
          } else {
            await retryOperation(
              () => copyFileWithStreams(sourcePath, targetPath),
              maxRetries,
              retryDelay,
              `Copy file ${sourcePath} -> ${targetPath}`
            );
          }
        } catch (error) {
          console.error(`Error processing ${sourcePath}:`, error);
          if (!skipLockedFiles) throw error;
        }
      })
    );
  } catch (err) {
    console.error(`Error reading source directory ${source}:`, err);
    throw err;
  }
}

// Helper function to copy files using streams with proper error handling
async function copyFileWithStreams(sourcePath, targetPath) {
  try {
    await pipeline(
      fs.createReadStream(sourcePath),
      fs.createWriteStream(targetPath)
    );
  } catch (error) {
    // Clean up partially copied file if error occurs
    try {
      await fs.unlink(targetPath).catch(() => {});
    } catch (cleanupError) {
      console.warn(
        `Could not clean up failed copy ${targetPath}:`,
        cleanupError
      );
    }
    throw error;
  }
}

// Helper function to retry operations
async function retryOperation(
  operation,
  maxRetries,
  delayMs,
  operationName = "operation"
) {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error;
      if (attempt < maxRetries) {
        console.warn(
          `Attempt ${attempt}/${maxRetries} failed for ${operationName}, retrying...`
        );
        await new Promise((resolve) => setTimeout(resolve, delayMs * attempt));
      }
    }
  }

  console.error(`All ${maxRetries} attempts failed for ${operationName}`);
  throw lastError;
}

// Helper function to check if path exists
async function pathExists(path) {
  try {
    await fs.access(path);
    return true;
  } catch {
    return false;
  }
}

async function initializeBot(
  botName,
  phoneCount = 1,
  specificPhoneIndex,
  pairingConfig = null
) {
  try {
    console.log(
      `Starting initialization for bot: ${botName} with ${phoneCount} phone(s)${
        specificPhoneIndex !== undefined
          ? `, phone ${specificPhoneIndex + 1}`
          : ""
      }${
        pairingConfig
          ? ` with pairing config for ${pairingConfig.phoneNumber}`
          : ""
      }`
    );

    let clients =
      botMap.get(botName) ||
      Array(phoneCount)
        .fill(null)
        .map(() => ({
          client: null,
          status: null,
          qrCode: null,
          initializationStartTime: null,
        }));

    const indicesToInitialize =
      specificPhoneIndex !== undefined
        ? [specificPhoneIndex]
        : Array.from({ length: phoneCount }, (_, i) => i);

    // Initialize all phones in parallel
    const initializationPromises = indicesToInitialize.map(async (i) => {
      try {
        let clientName = `${botName}_phone${i + 1}`;

        // Small stagger between starts to prevent resource contention
        await new Promise((resolve) => setTimeout(resolve, i * 2500));

        return initializeWithTimeout(
          botName,
          i,
          clientName,
          clients,
          pairingConfig
        );
      } catch (phoneError) {
        console.error(
          `Error initializing bot ${botName} Phone ${i + 1}:`,
          phoneError
        );
        clients[i] = {
          client: null,
          status: "error",
          qrCode: null,
          error: phoneError.message,
          initializationStartTime: null,
        };
        botMap.set(botName, clients);
        broadcastStatus(botName, "error", i);
      }
    });

    // Wait for all initializations to complete
    await Promise.allSettled(initializationPromises);

    console.log(
      `Bot ${botName} initialization attempts completed for all phones`
    );
  } catch (error) {
    console.error(`Error in initializeBot for ${botName}:`, error);
    handleInitializationError(botName, phoneCount, specificPhoneIndex, error);
  }
}

// Add new function to manage phone status
// Around line 15955, replace the second updatePhoneStatus function:
// Around line 15955, replace the second updatePhoneStatus function:
async function updatePhoneStatus(companyId, phoneIndex, status, metadata = {}) {
  try {
    // First check if the company exists
    const companyResult = await sqlDb.query(
      "SELECT company_id FROM companies WHERE company_id = $1",
      [companyId]
    );

    if (companyResult.rows.length === 0) {
      console.log(
        `Company ${companyId} not found, skipping phone status update`
      );
      return;
    }

    // Get phone number if status is 'ready'
    let phoneNumber = null;
    if (status === "ready") {
      const botData = botMap.get(companyId);
      if (
        botData &&
        botData[phoneIndex] &&
        botData[phoneIndex].client?.info?.wid?.user
      ) {
        phoneNumber = botData[phoneIndex].client.info.wid.user;
      }
    }

    // If no phone number is available, use a placeholder or skip
    if (!phoneNumber) {
      phoneNumber = `phone_${phoneIndex}`; // Use a placeholder
    }

    // Check if a record already exists for this company and phone_index
    const existingResult = await sqlDb.query(
      "SELECT id FROM phone_status WHERE company_id = $1 AND phone_index = $2",
      [companyId, phoneIndex.toString()]
    );

    if (existingResult.rows.length > 0) {
      // Update existing record
      await sqlDb.query(
        `
        UPDATE phone_status 
        SET phone_number = $1, status = $2, last_seen = CURRENT_TIMESTAMP, 
            metadata = $3, updated_at = CURRENT_TIMESTAMP
        WHERE company_id = $4 AND phone_index = $5
        `,
        [
          phoneNumber,
          status,
          Object.keys(metadata).length ? JSON.stringify(metadata) : null,
          companyId,
          phoneIndex.toString(),
        ]
      );
    } else {
      // Insert new record
      await sqlDb.query(
        `
        INSERT INTO phone_status (company_id, phone_index, phone_number, status, last_seen, metadata, updated_at)
        VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, $5, CURRENT_TIMESTAMP)
        `,
        [
          companyId,
          phoneIndex.toString(),
          phoneNumber,
          status,
          Object.keys(metadata).length ? JSON.stringify(metadata) : null,
        ]
      );
    }
  } catch (error) {
    console.error(
      `Error updating phone status in SQL for ${companyId} Phone ${phoneIndex}:`,
      error
    );
    // Don't throw the error - just log it to prevent cascading failures
  }
}
const monitoringIntervals = new Map();

function startPhoneMonitoring(botName, phoneIndex) {
  if (monitoringIntervals.has(`${botName}_${phoneIndex}`)) {
    clearInterval(monitoringIntervals.get(`${botName}_${phoneIndex}`));
  }
  console.log(
    `Starting phone monitoring for ${botName} Phone ${phoneIndex + 1}`
  );
  const intervalId = setInterval(async () => {
    try {
      const result = await sqlDb.query(
        `
        SELECT status 
        FROM phone_status 
        WHERE company_id = $1 AND phone_number = $2
        `,
        [botName, `phone${phoneIndex}`]
      );

      if (result.rows.length > 0 && result.rows[0].status === "initializing") {
        console.log(
          `${botName} Phone ${
            phoneIndex + 1
          } - Still initializing, running cleanup...`
        );

        const { spawn } = require("child_process");
        const mime = require("mime-types");
        // Your existing cleanup code here
      }
    } catch (error) {
      console.error(
        `Error checking initialization status for ${botName} Phone ${
          phoneIndex + 1
        }:`,
        error
      );
    }
  }, 30000);

  // Store the interval ID
  monitoringIntervals.set(`${botName}_${phoneIndex}`, intervalId);
}

async function initializeWithTimeout(
  botName,
  phoneIndex,
  clientName,
  clients,
  pairingConfig = null
) {
  return new Promise(async (resolve, reject) => {
    let isResolved = false;
    const sessionDir = path.join(
      __dirname,
      ".wwebjs_auth",
      `session-${clientName}`
    );
    const backupDir = path.join(
      __dirname,
      ".wwebjs_auth_backup",
      `session-${clientName}`
    );

    // Backup logic for 'ready' status
    try {
      const result = await sqlDb.query(
        `SELECT status FROM phone_status 
         WHERE company_id = $1 AND phone_number = $2`,
        [botName, phoneIndex]
      );

      if (
        result.rows.length > 0 &&
        result.rows[0].status === "ready" &&
        fs.existsSync(sessionDir)
      ) {
        console.log(
          `${botName} Phone ${
            phoneIndex + 1
          } - Previous status was ready, creating backup...`
        );
        try {
          await fs.promises.mkdir(path.dirname(backupDir), { recursive: true });
          await copyDirectory(sessionDir, backupDir);
          console.log(
            `${botName} Phone ${phoneIndex + 1} - Backup created successfully`
          );
        } catch (backupError) {
          console.error(
            `${botName} Phone ${phoneIndex + 1} - Error creating backup:`,
            backupError
          );
        }
      }
    } catch (error) {
      console.error(
        `${botName} Phone ${phoneIndex + 1} - Error checking previous status:`,
        error
      );
    }

    // Enhanced error handlers for process-level events
    const errorHandlers = {
      unhandledRejection: async (reason) => {
        if (
          typeof reason === "string" &&
          (reason.includes("Protocol Error:") ||
            reason.includes("Target closed."))
        ) {
          await safeCleanup(botName, phoneIndex);
          await sendAlertToEmployees(botName);
        }
      },
      uncaughtException: async (error) => {
        if (
          error.message.includes("Protocol Error:") ||
          error.message.includes("Target closed.")
        ) {
          await safeCleanup(botName, phoneIndex);
          await sendAlertToEmployees(botName);
        }
      },
    };

    process.on("unhandledRejection", errorHandlers.unhandledRejection);
    process.on("uncaughtException", errorHandlers.uncaughtException);

    try {
      // Create client configuration
      const clientConfig = {
        authStrategy: new LocalAuth({
          clientId: clientName,
          dataPath: path.join(__dirname, ".wwebjs_auth"),
        }),
        authTimeoutMs: 20000,
        takeoverOnConflict: true,
        restartOnAuthFail: true,
        webVersionCache: {
          type: "remote",
          remotePath: "https://raw.githubusercontent.com/wppconnect-team/wa-version/main/html/2.3000.1032360465-alpha.html",
        },
        puppeteer: {
          headless: true,
          executablePath: process.env.CHROME_PATH || "/usr/bin/google-chrome",
          ignoreHTTPSErrors: true,
          args: [
            "--no-sandbox",
            "--disable-setuid-sandbox",
            "--disable-extensions",
            "--disable-gpu",
            "--disable-accelerated-2d-canvas",
            "--no-first-run",
            "--no-zygote",
            "--disable-dev-shm-usage",
            "--unhandled-rejections=strict",
            "--disable-gpu-driver-bug-workarounds",
            "--log-level=3",
            "--no-default-browser-check",
            "--disable-site-isolation-trials",
            "--no-experiments",
            "--ignore-gpu-blacklist",
            "--ignore-certificate-errors",
            "--ignore-certificate-errors-spki-list",
            "--disable-default-apps",
            "--enable-features=NetworkService",
            "--disable-webgl",
            "--disable-threaded-animation",
            "--disable-threaded-scrolling",
            "--disable-in-process-stack-traces",
            "--disable-histogram-customizer",
            "--disable-gl-extensions",
            "--disable-composited-antialiasing",
            "--disable-canvas-aa",
            "--disable-3d-apis",
            "--disable-accelerated-jpeg-decoding",
            "--disable-accelerated-mjpeg-decode",
            "--disable-app-list-dismiss-on-blur",
            "--disable-accelerated-video-decode",
          ],
          timeout: 120000,
        },
      };

      // Add pairing configuration if provided
      if (pairingConfig) {
        clientConfig.pairWithPhoneNumber = {
          phoneNumber: pairingConfig.phoneNumber,
          showNotification: true,
          intervalMs: 180000,
        };
        console.log(
          `${botName} Phone ${phoneIndex + 1} - Initializing with pairing for ${
            pairingConfig.phoneNumber
          }`
        );
        console.log(
          `${botName} Phone ${phoneIndex + 1} - Pairing config applied:`,
          clientConfig.pairWithPhoneNumber
        );
      } else {
        console.log(
          `${botName} Phone ${
            phoneIndex + 1
          } - Initializing without pairing config`
        );
      }

      const client = new Client(clientConfig);

      // Set initial status to initializing
      console.log(`Initializing ${botName} Phone ${phoneIndex + 1}...`);
      clients[phoneIndex] = {
        client,
        status: "initializing",
        qrCode: null,
        initializationStartTime: Date.now(),
      };
      botMap.set(botName, clients);
      await updatePhoneStatus(botName, phoneIndex, "initializing");

      // Start checking for stuck initialization or authenticated state (timeout 2 minutes)
      let checkCount = 0;
      const checkInitialization = setInterval(async () => {
        try {
          checkCount++;
          const result = await sqlDb.query(
            `SELECT status FROM phone_status
             WHERE company_id = $1 AND phone_number = $2`,
            [botName, phoneIndex]
          );

          if (result.rows.length > 0) {
            const status = result.rows[0].status;

            // Check for stuck in initializing state
            if (status === "initializing") {
              console.log(
                `${botName} Phone ${
                  phoneIndex + 1
                } - Still initializing after 2 minutes, running cleanup...`
              );
              clearInterval(checkInitialization);
              await safeCleanup(botName, phoneIndex);
            }

            // Check for stuck in authenticated state (should transition to ready within 60s)
            // Only trigger after second check (4 minutes total, 2 minutes in authenticated)
            if (status === "authenticated" && checkCount >= 2) {
              console.log(
                `${botName} Phone ${
                  phoneIndex + 1
                } - Stuck in authenticated state, running cleanup...`
              );
              clearInterval(checkInitialization);
              await safeCleanup(botName, phoneIndex);
            }
          }
        } catch (error) {
          console.error(`Error checking initialization status: ${error}`);
        }
      }, 120000);

      client.on("qr", async (qr) => {
        try {
          clearInterval(checkInitialization);
          const qrCodeData = await qrcode.toDataURL(qr);
          clients[phoneIndex] = {
            ...clients[phoneIndex],
            client,
            status: "qr",
            qrCode: qrCodeData,
            initializationStartTime: null,
          };
          botMap.set(botName, clients);
          await updatePhoneStatus(botName, phoneIndex, "qr", {
            qrCode: qrCodeData,
          });
          broadcastAuthStatus(
            botName,
            "qr",
            qrCodeData,
            clients.length > 1 ? phoneIndex : undefined
          );
        } catch (err) {
          console.error("Error generating QR code:", err);
        }
      });

      client.on("code", async (code) => {
        try {
          clearInterval(checkInitialization);
          console.log(
            `${botName} Phone ${
              phoneIndex + 1
            } - PAIRING CODE RECEIVED: ${code}`
          );
          clients[phoneIndex] = {
            ...clients[phoneIndex],
            client,
            status: "pairing_code",
            pairingCode: code,
            initializationStartTime: null,
          };
          botMap.set(botName, clients);
          await updatePhoneStatus(botName, phoneIndex, "pairing_code", {
            pairingCode: code,
          });
          console.log(
            `${botName} Phone ${
              phoneIndex + 1
            } - Pairing code saved to database: ${code}`
          );
          broadcastAuthStatus(
            botName,
            "pairing_code",
            code,
            clients.length > 1 ? phoneIndex : undefined
          );
        } catch (err) {
          console.error("Error handling pairing code:", err);
        }
      });

      client.on("authenticated", async () => {
        console.log(`${botName} Phone ${phoneIndex + 1} - AUTHENTICATED`);
        clients[phoneIndex] = {
          ...clients[phoneIndex],
          status: "authenticated",
          qrCode: null,
        };
        botMap.set(botName, clients);
        await updatePhoneStatus(botName, phoneIndex, "authenticated");
      });
      client.on("ready", async () => {
        clearInterval(checkInitialization);
        console.log(`${botName} Phone ${phoneIndex + 1} - READY`);

  
        clients[phoneIndex] = {
          ...clients[phoneIndex],
          status: "ready",
          qrCode: null,
        };
        botMap.set(botName, clients);
        setupMessageHandler(client, botName, phoneIndex);
        setupMessageCreateHandler(client, botName, phoneIndex);
        await updatePhoneStatus(botName, phoneIndex, "ready");
        if (!isResolved) {
          isResolved = true;
          resolve();
        }
      });
      client.on("error", async (error) => {
        clearInterval(checkInitialization);
        console.error(
          `${botName} Phone ${phoneIndex + 1} - Client error:`,
          error
        );

        // Handle network-related errors more gracefully
        if (
          error.code === "EADDRNOTAVAIL" ||
          error.code === "ENOTFOUND" ||
          error.code === "ECONNREFUSED" ||
          error.code === "ETIMEDOUT" ||
          error.message.includes("read EADDRNOTAVAIL") ||
          error.message.includes("TLSWrap")
        ) {
          console.error(
            `${botName} Phone ${
              phoneIndex + 1
            } - Network connectivity error detected, will retry...`
          );

          try {
            await updatePhoneStatus(botName, phoneIndex, "error", {
              error: `Network error: ${error.message}`,
            });

            // Wait before attempting reconnection
            await new Promise((resolve) => setTimeout(resolve, 5000));

            // Attempt reinitialization
            await initializeBot(botName, 1, phoneIndex);
          } catch (handlingError) {
            console.error(
              `${botName} Phone ${
                phoneIndex + 1
              } - Error handling network error:`,
              handlingError
            );
          }
          return;
        }

        try {
          await updatePhoneStatus(botName, phoneIndex, "error", {
            error: error.message,
          });

          console.log(
            `${botName} Phone ${
              phoneIndex + 1
            } - Error detected, attempting cleanup and reinitialization...`
          );

          await safeCleanup(botName, phoneIndex);
        } catch (handlingError) {
          console.error(
            `${botName} Phone ${phoneIndex + 1} - Error handling client error:`,
            handlingError
          );
          try {
            await initializeBot(botName, 1, phoneIndex);
          } catch (lastError) {
            console.error(
              `${botName} Phone ${
                phoneIndex + 1
              } - Last resort reinitialization failed:`,
              lastError
            );
          }
        }
      });

      client.on("disconnected", async (reason) => {
        clearInterval(checkInitialization);
        console.log(
          `${botName} Phone ${phoneIndex + 1} - DISCONNECTED:`,
          reason
        );

        try {
          await updatePhoneStatus(botName, phoneIndex, "disconnected", {
            reason: reason,
          });

          console.log(
            `${botName} Phone ${phoneIndex + 1} - Attempting cleanup...`
          );

          // Clean up session if disconnected due to navigation or logout
          if (reason === "NAVIGATION" || reason === "LOGOUT") {
            console.log(
              `${botName} Phone ${
                phoneIndex + 1
              } - Navigation or logout detected, attempting cleanup...`
            );
            await safeCleanup(botName, phoneIndex);
            await sendAlertToEmployees(botName);
          }

          await new Promise((resolve) => setTimeout(resolve, 2000));
          console.log(
            `${botName} Phone ${phoneIndex + 1} - Running cleanup...`
          );
        } catch (error) {
          console.error(
            `${botName} Phone ${
              phoneIndex + 1
            } - Error in disconnection handler:`,
            error
          );
          try {
            await new Promise((resolve) => setTimeout(resolve, 5000));
            await initializeBot(botName, 1, phoneIndex);
          } catch (lastError) {
            console.error(
              `${botName} Phone ${
                phoneIndex + 1
              } - Last resort reinitialization failed:`,
              lastError
            );
          }
        }
      });

      await client.initialize();
      console.log(
        `Bot ${botName} Phone ${phoneIndex + 1} initialization complete`
      );
      startPhoneMonitoring(botName, phoneIndex);
    } catch (error) {
      await updatePhoneStatus(botName, phoneIndex, "error", {
        error: error.message,
      });
      try {
        const result = await sqlDb.query(
          `SELECT status FROM phone_status 
           WHERE company_id = $1 AND phone_number = $2`,
          [botName, phoneIndex]
        );

        if (
          result.rows.length > 0 &&
          result.rows[0].status === "initializing"
        ) {
          console.log(
            `${botName} Phone ${
              phoneIndex + 1
            } - Still initializing, running cleanup...`
          );
          await safeCleanup(botName, phoneIndex);
        }
      } catch (error) {
        console.error(
          `Error checking initialization status for ${botName} Phone ${
            phoneIndex + 1
          }:`,
          error
        );
      }
      reject(error);
    } finally {
      // Clean up event listeners
      process.removeListener(
        "unhandledRejection",
        errorHandlers.unhandledRejection
      );
      process.removeListener(
        "uncaughtException",
        errorHandlers.uncaughtException
      );
    }
  });
}

async function destroyClient(client) {
  try {
    const browser = client.pupPage?.browser();
    if (browser) {
      await browser
        .close()
        .catch((err) => console.log("Browser close error:", err));
    }
    await client
      .destroy()
      .catch((err) => console.log("Client destroy error:", err));
  } catch (err) {
    if (err.code === "EBUSY") {
      console.warn("Resource busy, retrying...");
      await new Promise((resolve) => setTimeout(resolve, 1000));
      try {
        await client.destroy();
      } catch (retryErr) {
        console.warn("Final attempt to destroy client failed:", retryErr);
      }
    } else {
      throw err;
    }
  }
}

// Get session status from SQL database
async function getSessionStatus(botName, phoneIndex) {
  try {
    const result = await sqlDb.query(
      `SELECT status FROM phone_status 
       WHERE company_id = $1 AND phone_number = $2`,
      [botName, phoneIndex]
    );

    return result.rows.length > 0 ? result.rows[0].status : "unknown";
  } catch (error) {
    console.error(
      `Error getting session status for ${botName} phone ${phoneIndex}:`,
      error
    );
    return "unknown";
  }
}

// Main cleanup function
async function safeCleanup(botName, phoneIndex) {
  const clientName = `${botName}_phone${phoneIndex + 1}`;
  const sessionDir = path.join(
    __dirname,
    ".wwebjs_auth",
    `session-${clientName}`
  );

  try {
    // 1. Check if this session is actually problematic
    const status = await getSessionStatus(botName, phoneIndex);

    // Only clean up if session is in error state or disconnected
    if (status !== "ready" && status !== "authenticated") {
      console.log(`Cleaning up problematic session: ${clientName}`);
      await cleanupSession(botName, phoneIndex, sessionDir);
      return true;
    }

    console.log(
      `Session ${clientName} is healthy (status: ${status}), skipping cleanup`
    );
    return false;
  } catch (error) {
    console.error(`Error during cleanup check for ${clientName}:`, error);
    return false;
  }
}

// Enhanced session cleanup
async function cleanupSession(botName, phoneIndex, sessionDir) {
  try {
    console.log(`Cleaning up session ${botName} at ${sessionDir}`);
    // 1. Clean up locked files first
    await cleanupLockedFiles(sessionDir);

    // 2. Remove session directory
    await removeSessionDir(sessionDir);

    console.log(`Successfully cleaned up session ${botName}`);
    return true;
  } catch (error) {
    console.error(`Final cleanup attempt failed for ${botName}:`, error);
    return false;
  }
}

// Locked files cleaner
async function cleanupLockedFiles(dirPath) {
  console.log(`Cleaning up locked files in ${dirPath}`);
  if (!(await fileExists(dirPath))) return;

  try {
    const files = await fs.readdir(dirPath);
    const lockedFiles = files.filter(
      (file) =>
        file.endsWith(".db-journal") ||
        file.endsWith(".db-wal") ||
        file.endsWith(".db-shm") ||
        file === "lockfile"
    );

    for (const file of lockedFiles) {
      const filePath = path.join(dirPath, file);
      await forceDelete(filePath, 3); // 3 retries
    }
  } catch (error) {
    console.warn(`Error cleaning locked files in ${dirPath}:`, error);
  }
}

// Directory removal
async function removeSessionDir(dirPath) {
  console.log(`Deleting session directory ${dirPath}`);
  if (!(await fileExists(dirPath))) return;

  try {
    // Try standard deletion first
    console.log(`Deleting contents of ${dirPath}`);
    await fs.rm(dirPath, { recursive: true, force: true });
    console.log(`Successfully deleted contents of ${dirPath}`);

    // Verify deletion
    if (await fileExists(dirPath)) {
      throw new Error("Directory still exists after deletion");
    }
  } catch (error) {
    console.warn(`Standard deletion failed for ${dirPath}, trying fallback...`);

    // Fallback 1: Delete contents individually
    await deleteContentsIndividually(dirPath);

    // Fallback 2: Platform-specific commands
    await platformSpecificDelete(dirPath);
  }
}

// Utility functions
async function fileExists(path) {
  try {
    await fs.access(path);
    return true;
  } catch {
    return false;
  }
}

async function forceDelete(filePath, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      await fs.unlink(filePath);
      return;
    } catch (error) {
      if (attempt === maxRetries) throw error;
      await new Promise((resolve) => setTimeout(resolve, 1000 * attempt));
    }
  }
}

async function deleteContentsIndividually(dirPath) {
  const files = await fs.readdir(dirPath);
  for (const file of files) {
    const filePath = path.join(dirPath, file);
    try {
      const stat = await fs.lstat(filePath);
      if (stat.isDirectory()) {
        await removeSessionDir(filePath);
      } else {
        await forceDelete(filePath);
      }
    } catch (error) {
      console.warn(`Could not delete ${filePath}:`, error);
    }
  }
  // Only try to remove directory if it's empty
  try {
    await fs.rmdir(dirPath);
  } catch (error) {
    console.warn(`Could not remove directory ${dirPath}:`, error);
  }
}

async function platformSpecificDelete(dirPath) {
  return new Promise((resolve, reject) => {
    const command =
      process.platform === "win32"
        ? `rmdir /s /q "${dirPath}"`
        : `rm -rf "${dirPath}"`;

    exec(command, (error) => {
      if (error) {
        reject(error);
      } else {
        resolve();
      }
    });
  });
}

async function sendAlertToEmployees(companyId) {
  try {
    const companyQuery = `SELECT category FROM companies WHERE company_id = $1`;
    const { rows: companies } = await pool.query(companyQuery, [companyId]);

    if (companies.length === 0) {
      console.error(`Company with ID ${companyId} not found.`);
      return;
    }

    const companyCategory = companies[0].category;
    let botId = "0134";
    let alertMessage = `[ALERT] WhatsApp Connection Disconnected\n\nACTION REQUIRED:\n\n1. Navigate to the CRM.\n2. Log in to your account.\n3. Scan the QR code to reinitialize your WhatsApp connection.\n\nFor support, please contact +601121677672`;

    if (!companyCategory) {
      botId = "0134";
    } else if (companyCategory === "Omniyal") {
      botId = "063";
      alertMessage = `[ALERT] WhatsApp Connection Disconnected\n\nACTION REQUIRED:\n\n1. Navigate to app.omniyal.com.\n2. Log in to your account.\n3. Scan the QR code to reinitialize your WhatsApp connection.\n\nFor support, please contact us`;
    } else if (companyCategory === "XYZ") {
      botId = "0330";
      alertMessage = `[ALERT] WhatsApp Connection Disconnected\n\nACTION REQUIRED:\n\n1. Navigate to app.xyzaibot.com.\n2. Log in to your account.\n3. Scan the QR code to reinitialize your WhatsApp connection.\n\nFor support, please contact us`;
    }

    const botData = botMap.get(botId);
    if (!botData || !botData[0]?.client || botData[0].status !== "ready") {
      console.error(`Client for bot ${botId} is not initialized or not ready.`);
      return;
    }

    const client = botData[0].client;

    const query = `
      SELECT * FROM employees 
      WHERE company_id = $1 AND role = '1' AND active = true
    `;
    const { rows: employees } = await pool.query(query, [companyId]);

    console.log(
      `Fetched ${employees.length} employees with role '1' for company ${companyId}.`
    );

    if (employees.length === 0) {
      console.warn(
        `No active employees with role '1' found for company ${companyId}.`
      );
      return;
    }

    for (const emp of employees) {
      if (emp.phone_number) {
        const employeeID = emp.phone_number.replace("+", "") + "@c.us";
        console.log(`Sending alert to ${emp.phone_number}`);
        try {
          await client.sendMessage(employeeID, alertMessage);
          console.log(
            `Alert sent to ${emp.phone_number} about ${companyId} QR status`
          );
        } catch (sendError) {
          console.error(
            `Failed to send message to ${emp.phone_number}:`,
            sendError
          );
        }
      } else {
        console.warn(`Employee ${emp.name} does not have a phone number.`);
      }
    }
  } catch (error) {
    console.error("Error sending alert to employees:", error);
  }
}

function broadcastStatus(botName, status, phoneIndex = 0) {
  // Get client info if available
  const botData = botMap.get(botName);
  let clientPhone = null;

  if (botData?.[phoneIndex]?.client?.info?.wid) {
    clientPhone = botData[phoneIndex].client.info.wid.user;
  }

  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      // Send to logs viewers
      if (client.isLogsViewer) {
        client.send(
          JSON.stringify({
            type: "status_update",
            botName,
            status,
            phoneIndex,
            clientPhone,
            timestamp: new Date().toISOString(),
          })
        );
      }
      // Send to status page viewers
      else if (client.pathname === "/status") {
        client.send(
          JSON.stringify({
            type: "status_update",
            botName,
            status,
            phoneIndex,
            clientPhone,
            timestamp: new Date().toISOString(),
          })
        );
      }
    }
  });
}

// ... existing code ...

async function createAssistant(companyID) {
  const OPENAI_API_KEY = process.env.OPENAIKEY; // Ensure your environment variable is set
  const payload = {
    name: companyID,
    model: "gpt-4o-mini", // Ensure this model is supported and available
  };

  try {
    const response = await axios.post(
      "https://api.openai.com/v1/assistants",
      payload,
      {
        headers: {
          Authorization: `Bearer ${OPENAI_API_KEY}`,
          "Content-Type": "application/json",
          "OpenAI-Beta": "assistants=v2",
        },
      }
    );

    const assistantId = response.data.id;
    const companyResult = await sqlDb.query(
      "SELECT * FROM companies WHERE company_id = $1",
      [companyID]
    );
    const company = companyResult.rows[0];

    // Get existing assistant_ids or initialize empty array
    let existingAssistantIds = [];
    if (company && company.assistant_ids) {
      if (Array.isArray(company.assistant_ids)) {
        existingAssistantIds = company.assistant_ids;
      } else if (typeof company.assistant_ids === "string") {
        try {
          existingAssistantIds = JSON.parse(company.assistant_ids);
        } catch (e) {
          existingAssistantIds = [];
        }
      }
    }

    // Add the new assistant ID to the array
    existingAssistantIds.push(assistantId);

    // Update the companies table with the new assistant ID
    await sqlDb.query(
      `UPDATE companies 
       SET assistant_ids = $1, 
           v2 = true,
           updated_at = CURRENT_TIMESTAMP
       WHERE company_id = $2`,
      [JSON.stringify(existingAssistantIds), companyID]
    );

    console.log(
      `Assistant created successfully for company ${companyID}: ${assistantId}`
    );
    console.log(
      `Updated assistant_ids for company ${companyID}:`,
      existingAssistantIds
    );

    return assistantId;
  } catch (error) {
    console.error(
      "Error creating OpenAI assistant:",
      error.response ? error.response.data : error.message
    );
    // Don't use res here since this function is called outside of Express context
    throw error; // Re-throw the error to be handled by the caller
  }
}

// ... existing code ...

// 1. Modify the main() error handler (around line 15678)
main().catch((error) => {
  console.error("Error during initialization:", error);
  // Don't exit - just log the error and continue
  console.log("Continuing operation despite initialization error...");
});

// 2. Modify the uncaughtException handler (around line 15802)
process.on("uncaughtException", (error) => {
  console.error("\n========================================");
  console.error("UNCAUGHT EXCEPTION -", new Date().toISOString());
  console.error("========================================");
  console.error("Error:", error.message);
  console.error("Stack:", error.stack);
  console.error("Process PID:", process.pid);
  console.error("Memory Usage:", process.memoryUsage());
  console.error("========================================");

  // Log to file for debugging
  if (typeof logger !== "undefined" && logger.logToFile) {
    logger.logToFile("uncaught_exceptions", `${error.message}\n${error.stack}`);
  }

  // Handle specific database connection errors
  if (
    error.message &&
    (error.message.includes("Connection terminated unexpectedly") ||
      error.message.includes("connection terminated") ||
      error.message.includes("Client has encountered a connection error") ||
      error.message.includes("Connection to server closed") ||
      error.message.includes("server closed the connection unexpectedly"))
  ) {
    console.error("DATABASE CONNECTION ERROR DETECTED");
    console.error(
      "This is likely a database connectivity issue - continuing operation..."
    );
    console.error(
      "The connection pool will handle reconnection automatically."
    );
    return; // Don't crash for database connection issues
  }

  // Handle specific network-related errors
  if (
    error.code === "EADDRNOTAVAIL" ||
    error.code === "ENOTFOUND" ||
    error.code === "ECONNREFUSED" ||
    error.code === "ETIMEDOUT" ||
    error.message.includes("read EADDRNOTAVAIL") ||
    error.message.includes("TLSWrap")
  ) {
    console.error(
      "Network connectivity error detected - continuing operation..."
    );
    console.error(
      "This is likely a temporary network issue or WhatsApp connection problem."
    );
    return; // Don't crash for network issues
  }

  // For other critical errors, log but continue operation
  console.log("Continuing operation despite uncaught exception...");
});

// 3. Modify the unhandledRejection handler (around line 15808)
process.on("unhandledRejection", (reason, promise) => {
  console.error("\n========================================");
  console.error("UNHANDLED REJECTION -", new Date().toISOString());
  console.error("========================================");
  console.error("Reason:", reason);
  console.error("Promise:", promise);
  console.error("========================================");

  // Log to file for debugging
  if (typeof logger !== "undefined" && logger.logToFile) {
    logger.logToFile("unhandled_rejections", `${reason}\nPromise: ${promise}`);
  }

  // Handle database connection rejections
  if (
    reason &&
    reason.message &&
    (reason.message.includes("Connection terminated unexpectedly") ||
      reason.message.includes("connection terminated") ||
      reason.message.includes("Client has encountered a connection error") ||
      reason.message.includes("Connection to server closed") ||
      reason.message.includes("server closed the connection unexpectedly"))
  ) {
    console.error("DATABASE CONNECTION REJECTION DETECTED");
    console.error(
      "This is likely a database connectivity issue - continuing operation..."
    );
    console.error(
      "The connection pool will handle reconnection automatically."
    );
    return; // Don't crash for database connection issues
  }

  // Handle network-related rejections
  if (
    reason &&
    (reason.code === "EADDRNOTAVAIL" ||
      reason.code === "ENOTFOUND" ||
      reason.code === "ECONNREFUSED" ||
      reason.code === "ETIMEDOUT" ||
      (reason.message &&
        (reason.message.includes("fetch failed") ||
          reason.message.includes("read EADDRNOTAVAIL") ||
          reason.message.includes("TLSWrap"))))
  ) {
    console.error("Network connectivity error detected - continuing operation");
    return; // Don't shutdown for network issues
  }

  // For other errors, just log and continue
  console.log("Continuing operation despite unhandled rejection...");
});

// 4. Comment out or remove the worker restart logic (around line 15988)
// Comment out these lines:
// const { worker: newWorker } = createQueueAndWorker(botId);
// botWorkers.set(botId, newWorker);
// console.log(`Worker restarted for bot ${botId}`);

// 5. Modify the graceful shutdown to only exit on manual signals
process.on("SIGINT", async () => {
  console.log("\n=== Graceful Shutdown Initiated ===");
  // ... existing cleanup code ...

  // Only exit if it's a manual shutdown
  if (process.env.MANUAL_SHUTDOWN === "true") {
    process.exit(0);
  } else {
    console.log("Shutdown prevented - continuing operation...");
  }
});

// 6. Modify the shutdown error handler (around line 15792)
// Replace process.exit(1) with:
console.log("Shutdown error occurred but continuing operation...");

// Also handle other termination signals
process.on("SIGTERM", () => {
  console.log("SIGTERM received");
  process.emit("SIGINT");
});

process.on("uncaughtException", (error) => {
  console.error("\n=== Uncaught Exception ===");
  console.error("Error:", error);
  process.emit("SIGINT");
});

// Database health check
async function checkDatabaseHealth() {
  try {
    await sql`SELECT 1`;
    console.log("Database health check: OK");
  } catch (error) {
    console.error("Database health check failed:", error.message);
    // Log but don't crash
  }
}

// Run health check every 5 minutes
setInterval(checkDatabaseHealth, 5 * 60 * 1000);

// ============================================
// HOURLY SERVER HEALTH MONITORING & REPORTING
// ============================================

// Comprehensive health check function
async function performComprehensiveHealthCheck() {
  const healthReport = {
    timestamp: new Date().toISOString(),
    status: "OK",
    checks: {},
  };

  // 1. API Health Check
  try {
    const baseUrl = process.env.URL || "http://localhost:3000";
    const healthResponse = await axios.get(`${baseUrl}/api/health`, {
      timeout: 5000,
    });
    healthReport.checks.apiHealth = {
      status: healthResponse.status === 200 ? "OK" : "FAIL",
      uptime: healthResponse.data.uptime || 0,
    };
  } catch (error) {
    healthReport.checks.apiHealth = {
      status: "FAIL",
      error: error.message,
    };
    healthReport.status = "DEGRADED";
  }

  // 2. Login API Test
  try {
    const baseUrl = process.env.URL || "http://localhost:3000";
    const loginResponse = await axios.post(
      `${baseUrl}/api/login`,
      {
        email: "admin@juta.com",
        password: "123456",
      },
      { timeout: 5000 }
    );

    healthReport.checks.loginApi = {
      status: loginResponse.data.success ? "OK" : "FAIL",
      user: loginResponse.data.user?.email || "N/A",
    };
  } catch (error) {
    healthReport.checks.loginApi = {
      status: "FAIL",
      error: error.message,
    };
    healthReport.status = "DEGRADED";
  }

  // 3. Database Health
  try {
    await sql`SELECT 1`;
    healthReport.checks.database = {
      status: "OK",
    };
  } catch (error) {
    healthReport.checks.database = {
      status: "FAIL",
      error: error.message,
    };
    healthReport.status = "CRITICAL";
  }

  // 4. Memory Usage
  const memUsage = process.memoryUsage();
  const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);
  const heapTotalMB = Math.round(memUsage.heapTotal / 1024 / 1024);
  healthReport.checks.memory = {
    status: heapUsedMB > 500 ? "WARNING" : "OK",
    heapUsedMB,
    heapTotalMB,
    percentage: Math.round((heapUsedMB / heapTotalMB) * 100),
  };

  // 5. Bot Connections Status
  const botCount = botMap.size;
  const activeBots = Array.from(botMap.entries()).filter(
    ([_, botData]) => botData && botData[0]?.client
  ).length;

  healthReport.checks.bots = {
    status: botCount > 0 ? "OK" : "WARNING",
    total: botCount,
    active: activeBots,
    inactive: botCount - activeBots,
  };

  // 6. System Uptime
  const uptimeHours = Math.floor(process.uptime() / 3600);
  const uptimeMinutes = Math.floor((process.uptime() % 3600) / 60);
  healthReport.checks.uptime = {
    status: "OK",
    hours: uptimeHours,
    minutes: uptimeMinutes,
    totalSeconds: Math.floor(process.uptime()),
  };

  return healthReport;
}

// Function to send health report to WhatsApp group
async function sendHealthReportToGroup() {
  try {
    const companyId = "0210";
    const groupId = "120363178065670386@g.us";

    // Get bot client for company 0210
    const botData = botMap.get(companyId);

    if (!botData || !botData[0]?.client) {
      console.error(
        `[Health Report] No WhatsApp client found for company ${companyId}`
      );
      return;
    }

    // Perform comprehensive health check
    const healthReport = await performComprehensiveHealthCheck();

    // Format message
    const statusEmoji =
      healthReport.status === "OK"
        ? "✅"
        : healthReport.status === "DEGRADED"
        ? "⚠️"
        : "❌";

    let message = `${statusEmoji} *Hourly Server Health Report*\n\n`;
    message += `🕐 *Time:* ${moment()
      .tz("Asia/Kuala_Lumpur")
      .format("DD/MM/YYYY HH:mm:ss")}\n`;
    message += `📊 *Overall Status:* ${healthReport.status}\n\n`;

    // API Health
    message += `🌐 *API Health:* ${healthReport.checks.apiHealth.status}\n`;
    if (healthReport.checks.apiHealth.uptime) {
      const uptimeHours = Math.floor(
        healthReport.checks.apiHealth.uptime / 3600
      );
      message += `   Uptime: ${uptimeHours}h\n`;
    }
    if (healthReport.checks.apiHealth.error) {
      message += `   Error: ${healthReport.checks.apiHealth.error}\n`;
    }
    message += `\n`;

    // Login API
    message += `🔐 *Login API:* ${healthReport.checks.loginApi.status}\n`;
    if (healthReport.checks.loginApi.user) {
      message += `   Test User: ${healthReport.checks.loginApi.user}\n`;
    }
    if (healthReport.checks.loginApi.error) {
      message += `   Error: ${healthReport.checks.loginApi.error}\n`;
    }
    message += `\n`;

    // Database
    message += `💾 *Database:* ${healthReport.checks.database.status}\n`;
    if (healthReport.checks.database.error) {
      message += `   Error: ${healthReport.checks.database.error}\n`;
    }
    message += `\n`;

    // Memory
    const memStatus = healthReport.checks.memory.status === "OK" ? "✅" : "⚠️";
    message += `${memStatus} *Memory:* ${healthReport.checks.memory.heapUsedMB}MB / ${healthReport.checks.memory.heapTotalMB}MB (${healthReport.checks.memory.percentage}%)\n\n`;

    // Bot Connections
    message += `🤖 *Bot Connections:* ${healthReport.checks.bots.active}/${healthReport.checks.bots.total} active\n`;
    if (healthReport.checks.bots.inactive > 0) {
      message += `   ⚠️ ${healthReport.checks.bots.inactive} inactive\n`;
    }
    message += `\n`;

    // Uptime
    message += `⏱️ *System Uptime:* ${healthReport.checks.uptime.hours}h ${healthReport.checks.uptime.minutes}m\n\n`;

    message += `_Generated by Juta AI Health Monitor_`;

    // Send message
    await botData[0].client.sendMessage(groupId, message);

    console.log(
      `[Health Report] Successfully sent to group ${groupId} for company ${companyId}`
    );

    // Log to system
    logger.logEvent("HEALTH_REPORT", "Hourly health report sent", healthReport);
  } catch (error) {
    console.error("[Health Report] Error sending health report:", error);
    logger.logEvent("HEALTH_REPORT_ERROR", "Failed to send health report", {
      error: error.message,
      stack: error.stack,
    });
  }
}

/*Schedule hourly health report (at the top of every hour)
const healthReportCron = cron.schedule(
  "0 * * * *", // Every hour at minute 0
  async () => {
    console.log("[Health Report] Running hourly health check...");
    await sendHealthReportToGroup();
  },
  {
    timezone: "Asia/Kuala_Lumpur"
  }
);*/

console.log("[Health Report] Hourly health monitoring scheduled successfully");

// ============================================
// END HOURLY SERVER HEALTH MONITORING
// ============================================

// New endpoint to fetch message details from Firebase
app.get(
  "/api/queue/message-details/:companyId/:messageId",
  async (req, res) => {
    const { companyId, messageId } = req.params;

    try {
      const client = await pool.connect();

      try {
        const messageQuery = `
          SELECT * FROM scheduled_messages 
          WHERE id::text = $1::text AND company_id = $2
          LIMIT 1
        `;
        const messageResult = await client.query(messageQuery, [
          messageId,
          companyId,
        ]);

        if (messageResult.rowCount === 0) {
          return res.status(404).json({ error: "Message not found" });
        }

        const messageData = messageResult.rows[0];

        const batchesQuery = `
          SELECT * FROM scheduled_messages 
          WHERE schedule_id::text = $1::text 
            AND company_id = $2
            AND id::text != $1::text
          ORDER BY batch_index ASC
        `;
        const batchesResult = await client.query(batchesQuery, [
          messageId,
          companyId,
        ]);

        const batches = batchesResult.rows.map((batch) => ({
          id: batch.id,
          ...batch,
          chat_ids: batch.chat_ids
            ? safeJsonParse(
                batch.chat_ids,
                [],
                `chat_ids for batch ${batch.id}`
              )
            : [],
          messages: batch.messages
            ? safeJsonParse(
                batch.messages,
                [],
                `messages for batch ${batch.id}`
              )
            : [],
          message_delays: batch.message_delays
            ? safeJsonParse(
                batch.message_delays,
                null,
                `message_delays for batch ${batch.id}`
              )
            : null,
          active_hours: batch.active_hours
            ? safeJsonParse(
                batch.active_hours,
                null,
                `active_hours for batch ${batch.id}`
              )
            : null,
        }));

        const parsedMessageData = {
          ...messageData,
          chat_ids: messageData.chat_ids
            ? safeJsonParse(
                messageData.chat_ids,
                [],
                `chat_ids for message ${messageId}`
              )
            : [],
          messages: messageData.messages
            ? safeJsonParse(
                messageData.messages,
                [],
                `messages for message ${messageId}`
              )
            : [],
          message_delays: messageData.message_delays
            ? safeJsonParse(
                messageData.message_delays,
                null,
                `message_delays for message ${messageId}`
              )
            : null,
          active_hours: messageData.active_hours
            ? safeJsonParse(
                messageData.active_hours,
                null,
                `active_hours for message ${messageId}`
              )
            : null,
        };

        res.json({
          messageDetails: {
            id: messageId,
            ...parsedMessageData,
            batches,
          },
        });
      } catch (error) {
        console.error("Error fetching message details:", error);
        throw error;
      } finally {
        await safeRelease(client);
      }
    } catch (error) {
      console.error("Error fetching message details:", error);
      res.status(500).json({ error: "Failed to fetch message details" });
    }
  }
);

app.get("/api/queue/diagnose", async (req, res) => {
  try {
    const diagnosis = {
      queues: {},
    };

    for (const [botId, queue] of botQueues.entries()) {
      // Get all job types including completed with higher limits
      const counts = await queue.getJobCounts();

      // Fetch more historical jobs
      const completedJobs = await queue.getJobs(["completed"], 0, 1000); // Get last 1000 completed jobs
      const activeJobs = await queue.getJobs(["active"]);
      const delayedJobs = await queue.getJobs(["delayed"]);
      const failedJobs = await queue.getJobs(["failed"]);
      const waitingJobs = await queue.getJobs(["waiting"]);

      // Process jobs to ensure all data is included
      const processJobs = async (jobs) => {
        return Promise.all(
          jobs.map(async (job) => {
            // Ensure we have the job data
            if (!job) return null;

            const jobData = {
              id: job.id,
              name: job.name,
              timestamp: job.timestamp,
              processedOn: job.processedOn,
              finishedOn: job.finishedOn,
              attemptsMade: job.attemptsMade,
              failedReason: job.failedReason,
              opts: job.opts,
              data: job.data || {},
              progress: job.progress,
              status: job.status,
            };

            return jobData;
          })
        ).then((jobs) => jobs.filter((job) => job !== null));
      };

      diagnosis.queues[botId] = {
        counts,
        worker: {
          isRunning: botWorkers.get(botId)?.isRunning() || false,
          concurrency: botWorkers.get(botId)?.concurrency || 0,
        },
        activeJobs: await processJobs(activeJobs),
        delayedJobs: await processJobs(delayedJobs),
        failedJobs: await processJobs(failedJobs),
        waitingJobs: await processJobs(waitingJobs),
        completedJobs: await processJobs(completedJobs),
      };
    }

    res.json(diagnosis);
  } catch (error) {
    console.error("Queue diagnosis error:", error);
    res.status(500).json({ error: "Failed to diagnose queues" });
  }
});

// Update the reset endpoint as well
app.post("/api/queue/reset", async (req, res) => {
  try {
    console.log("\n=== Starting Queue Reset ===");
    const status = {};

    // Reset all queues and workers
    for (const [botId, queue] of botQueues.entries()) {
      const worker = botWorkers.get(botId);

      // Stop the worker
      if (worker) {
        await worker.close();
        console.log(`Worker closed for bot ${botId}`);
      }

      // Clear all jobs
      await queue.obliterate({ force: true });
      console.log(`Queue obliterated for bot ${botId}`);

      // Restart the worker
      const { worker: newWorker } = createQueueAndWorker(botId);
      botWorkers.set(botId, newWorker);
      console.log(`Worker restarted for bot ${botId}`);

      // Get current status
      status[botId] = await queue.getJobCounts();
    }

    res.json({
      message: "Queue reset complete",
      status,
    });
  } catch (error) {
    console.error("Error resetting queue:", error);
    res.status(500).json({ error: "Failed to reset queue" });
  }
});

// Update the force process endpoint
app.post("/api/queue/force-process", async (req, res) => {
  try {
    console.log("\n=== Force Processing Queues ===");
    const results = {};

    for (const [botId, queue] of botQueues.entries()) {
      const jobs = await queue.getJobs(["active", "delayed", "waiting"]);
      console.log(`Found ${jobs.length} jobs for bot ${botId}`);

      for (const job of jobs) {
        try {
          await job.moveToFailed(new Error("Force reset"), true);
          await job.retry();
        } catch (jobError) {
          console.error(
            `Error processing job ${job.id} for bot ${botId}:`,
            jobError
          );
        }
      }

      results[botId] = {
        processedCount: jobs.length,
        newStatus: await queue.getJobCounts(),
      };
    }

    res.json({
      message: "Force processing complete",
      results,
    });
  } catch (error) {
    console.error("Force processing error:", error);
    res.status(500).json({ error: "Failed to force process queues" });
  }
});

// Endpoint to requeue scheduled messages (used by the queue UI)
app.post("/api/requeue-scheduled-messages", async (req, res) => {
  const startTime = Date.now();
  const client = await pool.connect();
  try {
    // Find scheduled messages that are still scheduled and in the future
    const findQuery = `
      SELECT id, company_id, scheduled_time FROM scheduled_messages
      WHERE status = 'scheduled' AND scheduled_time > NOW()
      ORDER BY scheduled_time ASC
    `;
    const result = await client.query(findQuery);

    const messagesFound = result.rowCount;
    const companies = [...new Set(result.rows.map((r) => r.company_id))];
    const companiesProcessed = companies.length;
    const lastScheduledTime =
      result.rows.length > 0
        ? result.rows[result.rows.length - 1].scheduled_time
        : null;

    // Re-run the scheduler to (re)create queue jobs
    try {
      await scheduleAllMessages();
    } catch (schedErr) {
      console.error(
        "Error scheduling messages during requeue endpoint:",
        schedErr
      );
      // continue to return partial info
    }

    const totalTimeSpan = lastScheduledTime
      ? new Date(lastScheduledTime).getTime() - Date.now()
      : 0;

    res.json({
      messagesRequeued: messagesFound,
      companiesProcessed,
      messagesSkipped: {
        tooOld: 0,
        outsideTimeWindow: 0,
      },
      schedulingSummary: {
        totalTimeSpan,
        startTime,
        lastScheduledTime,
      },
      errors: [],
    });
  } catch (error) {
    console.error("Error in requeue-scheduled-messages endpoint:", error);
    res
      .status(500)
      .json({
        error: "Failed to requeue scheduled messages",
        details: error.message,
      });
  } finally {
    client.release();
  }
});

// Admin endpoint: cleanup stale queued jobs across all bot queues
app.post("/api/queue/cleanup-stale", async (req, res) => {
  const summary = {
    totalBots: 0,
    bots: {},
    totalRemoved: 0,
    errors: [],
  };

  let client = null;
  try {
    for (const [botId, queue] of botQueues.entries()) {
      summary.totalBots += 1;
      summary.bots[botId] = { checked: 0, removed: 0 };

      // get DB connection for checks
      client = await pool.connect();

      try {
        const jobs = await queue.getJobs(["delayed", "waiting", "active"]);
        summary.bots[botId].checked = jobs.length;

        for (const job of jobs) {
          try {
            const jobId = job.id;
            if (!jobId) continue;

            const q = await client.query(
              `SELECT id, status FROM scheduled_messages WHERE id = $1 AND company_id = $2 LIMIT 1`,
              [jobId, botId]
            );

            if (q.rowCount === 0 || q.rows[0].status !== "scheduled") {
              try {
                await job.remove();
                summary.bots[botId].removed += 1;
                summary.totalRemoved += 1;
              } catch (rmErr) {
                const msg = `Failed to remove job ${jobId} on bot ${botId}: ${rmErr.message}`;
                console.error(msg, rmErr);
                summary.errors.push(msg);
              }
            }
          } catch (jobErr) {
            const msg = `Error checking job ${job?.id} on bot ${botId}: ${jobErr.message}`;
            console.error(msg, jobErr);
            summary.errors.push(msg);
          }
        }
      } catch (queueErr) {
        const msg = `Error accessing jobs for bot ${botId}: ${queueErr.message}`;
        console.error(msg, queueErr);
        summary.errors.push(msg);
      } finally {
        if (client) {
          try {
            client.release();
          } catch (e) {
            /* ignore */
          }
          client = null;
        }
      }
    }

    res.json({ success: true, summary });
  } catch (error) {
    console.error("Error during cleanup-stale endpoint:", error);
    res.status(500).json({ success: false, error: error.message, summary });
  } finally {
    if (client) {
      try {
        client.release();
      } catch (e) {
        /* ignore */
      }
    }
  }
});

// Company-specific cleanup: remove stale queued jobs for a single company
app.post("/api/queue/cleanup-stale/:companyId", async (req, res) => {
  const { companyId } = req.params;
  if (!companyId)
    return res
      .status(400)
      .json({ success: false, error: "companyId required" });

  const summary = { companyId, checked: 0, removed: 0, errors: [] };
  let client = null;

  try {
    const queue = getQueueForBot(companyId);
    client = await pool.connect();

    const jobs = await queue.getJobs(["delayed", "waiting", "active"]);
    summary.checked = jobs.length;

    for (const job of jobs) {
      try {
        const jobId = job.id;
        if (!jobId) continue;

        const q = await client.query(
          `SELECT id, status FROM scheduled_messages WHERE id = $1 AND company_id = $2 LIMIT 1`,
          [jobId, companyId]
        );

        if (q.rowCount === 0 || q.rows[0].status !== "scheduled") {
          try {
            await job.remove();
            summary.removed += 1;
          } catch (rmErr) {
            const msg = `Failed to remove job ${jobId}: ${rmErr.message}`;
            console.error(msg, rmErr);
            summary.errors.push(msg);
          }
        }
      } catch (jobErr) {
        const msg = `Error checking job ${job?.id}: ${jobErr.message}`;
        console.error(msg, jobErr);
        summary.errors.push(msg);
      }
    }

    res.json({ success: true, summary });
  } catch (error) {
    console.error(
      `Error during company-specific cleanup for ${companyId}:`,
      error
    );
    res.status(500).json({ success: false, error: error.message, summary });
  } finally {
    if (client)
      try {
        client.release();
      } catch (e) {}
  }
});

// Company-specific requeue: run scheduler only for given company
app.post("/api/queue/requeue/:companyId", async (req, res) => {
  const { companyId } = req.params;
  if (!companyId)
    return res
      .status(400)
      .json({ success: false, error: "companyId required" });

  try {
    // First cleanup stale jobs for this company to avoid duplicates
    await (async () => {
      const queue = getQueueForBot(companyId);
      const client = await pool.connect();
      try {
        const jobs = await queue.getJobs(["delayed", "waiting", "active"]);
        for (const job of jobs) {
          try {
            const q = await client.query(
              `SELECT id, status FROM scheduled_messages WHERE id = $1 AND company_id = $2 LIMIT 1`,
              [job.id, companyId]
            );
            if (q.rowCount === 0 || q.rows[0].status !== "scheduled") {
              try {
                await job.remove();
              } catch (e) {
                /* ignore */
              }
            }
          } catch (e) {
            /* ignore per-job errors */
          }
        }
      } finally {
        client.release();
      }
    })();

    // Then schedule messages only for this company
    await scheduleAllMessages(companyId);
    res.json({
      success: true,
      message: `Requeue requested for company ${companyId}`,
    });
  } catch (error) {
    console.error(`Error requeueing for company ${companyId}:`, error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get user role endpoint
app.get("/api/user-role", async (req, res) => {
  try {
    const email = req.query.email;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const userData = await sqlDb.getRow(
      "SELECT role FROM users WHERE email = $1 AND active = true",
      [email]
    );

    if (!userData) {
      return res.status(404).json({ error: "User not found" });
    }

    res.json({ role: userData.role });
  } catch (error) {
    console.error("Error fetching user role:", error);
    res.status(500).json({ error: "Failed to fetch user role" });
  }
});

// Get user and company data endpoint
app.get("/api/user-company-data", async (req, res) => {
  try {
    const email = req.query.email;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    // First get user data to get company_id
    const userData = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1 AND active = true",
      [email]
    );

    if (!userData) {
      return res.status(404).json({ error: "User not found" });
    }

    const companyId = userData.company_id;

    // Then get company data - added assistant_id to the SELECT
    const companyData = await sqlDb.getRow(
      "SELECT id, company_id, name, email, phone, plan, v2, phone_count, assistant_ids, api_url FROM companies WHERE company_id = $1",
      [companyId]
    );

    if (!companyData) {
      return res.status(404).json({ error: "Company not found" });
    }

    // Get employee data
    const employeeResult = await sqlDb.getRows(
      "SELECT * FROM users WHERE company_id = $1 AND active = true",
      [companyId]
    );

    const employeeList = employeeResult.map((emp) => ({
      id: emp.id,
      name: emp.name,
      email: emp.email,
      phone: emp.phone,
      role: emp.role,
    }));

    // Get message usage for enterprise plan
    let messageUsage = 0;
    if (companyData.plan === "enterprise") {
      const currentDate = new Date();
      const monthKey = `${currentDate.getFullYear()}-${String(
        currentDate.getMonth() + 1
      ).padStart(2, "0")}`;

      const usageResult = await sqlDb.getRow(
        "SELECT total_messages FROM message_usage WHERE company_id = $1 AND month = $2",
        [companyId, monthKey]
      );

      if (usageResult) {
        messageUsage = usageResult.total_messages;
      }
    }

    // Get tags if company is using v2
    let tags = [];
    if (companyData.v2) {
      const contactsResult = await sqlDb.getRows(
        "SELECT DISTINCT jsonb_array_elements(CASE WHEN jsonb_typeof(tags) = 'array' THEN tags ELSE '[]'::jsonb END) as tag_name FROM contacts WHERE company_id = $1",
        [companyId]
      );

      const employeeNames = employeeList.map((emp) =>
        emp.name ? emp.name.trim().toLowerCase() : ""
      );
      tags = contactsResult
        .map((row) => ({ id: row.tag_name, name: row.tag_name }))
        .filter(
          (tag) =>
            typeof tag.name === "string" &&
            tag.name.trim() !== "" &&
            tag.name !== "{}" &&
            !employeeNames.includes(tag.name.toLowerCase())
        );
    }

    // Prepare response - added assistant_id to companyData
    const response = {
      userData: {
        name: userData.name,
        email: userData.email,
        role: userData.role,
        companyId: userData.company_id,
        viewEmployee: userData.view_employee,
      },
      companyData: {
        name: companyData.name,
        plan: companyData.plan,
        phoneCount: companyData.phone_count || 1,
        v2: companyData.v2,
        assistants_ids: companyData.assistant_ids,
        assistant_id: companyData.assistant_id,
        api_url: companyData.api_url || "",
      },
      employeeList,
      messageUsage,
      tags,
    };
    res.json(response);
  } catch (error) {
    console.error("Error fetching user and company data:", error);
    res.status(500).json({ error: "Failed to fetch data" });
  }
});

// ... existing code ...

app.get("/api/user-config", async (req, res) => {
  const { email } = req.query;

  if (!email) {
    return res.status(400).json({ error: "Email is required" });
  }

  try {
    // Get user data
    const userResult = await sqlDb.getRow(
      "SELECT * FROM users WHERE email = $1 AND active = true",
      [email]
    );

    if (!userResult) {
      return res.status(404).json({ error: "User not found" });
    }

    const userData = userResult;
    const companyId = userData.company_id;

    // Get company data
    const companyResult = await sqlDb.getRow(
      "SELECT * FROM companies WHERE company_id = $1",
      [companyId]
    );

    if (!companyResult) {
      return res.status(404).json({ error: "Company not found" });
    }

    const companyData = companyResult;

    let phoneNamesData = {};
    let phoneNames = [];
    if (companyData.phone_numbers) {
      try {
        // Accept both stringified array and array
        if (typeof companyData.phone_numbers === "string") {
          phoneNames = JSON.parse(companyData.phone_numbers);
        } else if (Array.isArray(companyData.phone_numbers)) {
          phoneNames = companyData.phone_numbers;
        }
      } catch (e) {
        phoneNames = [];
      }
    }
    // Always fallback to default names if empty
    for (let i = 0; i < (companyData.phone_count || 1); i++) {
      phoneNamesData[i] = phoneNames[i] || `Phone ${i + 1}`;
    }

    const phoneCount = companyData.phone_count || 1;

    // Get employee data
    const employeeResult = await sqlDb.getRows(
      "SELECT * FROM users WHERE company_id = $1 AND active = true",
      [companyId]
    );

    const employeeList = employeeResult.map((emp) => ({
      id: emp.id,
      name: emp.name,
      email: emp.email,
      phone: emp.phone,
      role: emp.role,
    }));

    // Get message usage based on plan type
    let messageUsage = {};
    const quotaKey = getQuotaKey(companyData.plan);
    const isLifetimePlan = !isMonthlyResetPlan(companyData.plan);

    // Get message usage for all features
    const usageFeatures = ["aiMessages", "blastedMessages"];
    for (const feature of usageFeatures) {
      let featureResult;

      if (isLifetimePlan) {
        // For free plan: get lifetime usage
        featureResult = await sqlDb.query(
          `SELECT SUM(usage_count) AS total_usage
           FROM usage_logs
           WHERE company_id = $1 AND feature = $2`,
          [companyId, feature]
        );
      } else {
        // For paid plans: get monthly usage
        const now = new Date();
        const year = now.getFullYear();
        const month = (now.getMonth() + 1).toString().padStart(2, "0");
        const monthlyKey = `${year}-${month}`;

        featureResult = await sqlDb.query(
          `SELECT SUM(usage_count) AS total_usage
           FROM usage_logs
           WHERE company_id = $1 AND feature = $2
           AND to_char(date, 'YYYY-MM') = $3`,
          [companyId, feature, monthlyKey]
        );
      }
      messageUsage[feature] = featureResult.rows[0]?.total_usage || 0;
    }

    let usageQuota = {};
    const planBasedQuota = getPlanBasedQuota(companyData.plan);
    const settingKey = "quotaAIMessage";

    const quotaResult = await sqlDb.query(
      `SELECT setting_value FROM settings
      WHERE company_id = $1 AND setting_type = 'messaging' AND setting_key = $2`,
      [companyId, settingKey]
    );

    let quotaObj = {};
    if (quotaResult.rows.length > 0) {
      try {
        quotaObj =
          typeof quotaResult.rows[0].setting_value === "string"
            ? JSON.parse(quotaResult.rows[0].setting_value)
            : quotaResult.rows[0].setting_value || {};
      } catch {
        quotaObj = {};
      }
    }

    if (!quotaObj[quotaKey]) {
      quotaObj[quotaKey] = planBasedQuota;
      if (quotaResult.rows.length > 0) {
        await sqlDb.query(
          `UPDATE settings SET setting_value = $1, updated_at = CURRENT_TIMESTAMP
        WHERE company_id = $2 AND setting_type = 'messaging' AND setting_key = $3`,
          [JSON.stringify(quotaObj), companyId, settingKey]
        );
      } else {
        await sqlDb.query(
          `INSERT INTO settings (company_id, setting_type, setting_key, setting_value, created_at, updated_at)
        VALUES ($1, 'messaging', $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)`,
          [companyId, settingKey, JSON.stringify(quotaObj)]
        );
      }
    }
    usageQuota.aiMessages = quotaObj[quotaKey] || planBasedQuota;

    // Get tags if company is using v2
    let tags = [];
    if (companyData.v2) {
      const contactsResult = await sqlDb.getRows(
        "SELECT DISTINCT jsonb_array_elements(CASE WHEN jsonb_typeof(tags) = 'array' THEN tags ELSE '[]'::jsonb END) as tag_name FROM contacts WHERE company_id = $1",
        [companyId]
      );

      const employeeNames = employeeList.map((emp) =>
        emp.name ? emp.name.trim().toLowerCase() : ""
      );
      tags = contactsResult
        .map((row) => ({ id: row.tag_name, name: row.tag_name }))
        .filter(
          (tag) =>
            typeof tag.name === "string" &&
            tag.name &&
            !employeeNames.includes(tag.name.toLowerCase())
        );
    }

    let viewEmployeesArr = [];
    try {
      if (userData.view_employees) {
        viewEmployeesArr =
          typeof userData.view_employees === "string"
            ? JSON.parse(userData.view_employees)
            : userData.view_employees;
      }
    } catch (error) {
      console.error("Error parsing view_employees:", error);
      viewEmployeesArr = [];
    }

    // Prepare response
    const response = {
      userData: {
        name: userData.name,
        email: userData.email,
        role: userData.role,
        companyId: userData.company_id,
        viewEmployees: viewEmployeesArr,
        phone: userData.phone, // Added selected_phone to userData
      },
      companyData: {
        name: companyData.name,
        plan: companyData.plan,
        phoneNames: phoneNamesData,
        phoneCount: phoneCount,
        v2: companyData.v2,
      },
      employeeList,
      messageUsage,
      usageQuota,
      tags,
    };

    res.json(response);
  } catch (error) {
    console.error("Error fetching user config:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/api/daily-usage/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;

    const now = new Date();
    const monthlyKey = `${now.getFullYear()}-${String(
      now.getMonth() + 1
    ).padStart(2, "0")}`;

    const usageFeatures = ["aiMessages", "blastedMessages"];
    const dailyUsage = {};

    for (const feature of usageFeatures) {
      const rowsResult = await sqlDb.query(
        `SELECT usage_count, to_char(date, 'YYYY-MM-DD') as date
         FROM usage_logs
         WHERE company_id = $1 AND feature = $2
         AND to_char(date, 'YYYY-MM') = $3
         ORDER BY date ASC`,
        [companyId, feature, monthlyKey]
      );
      dailyUsage[feature] = rowsResult.rows.map((row) => ({
        usage_count: row.usage_count,
        date: row.date,
      }));
    }
    res.json(dailyUsage);
  } catch (error) {
    console.error("Error fetching daily usage:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/api/companies/:companyId/contacts", async (req, res) => {
  try {
    const { email } = req.query;
    const { companyId } = req.params;
    if (!email) {
      console.log("Missing email in query");
      return res.status(400).json({ error: "Email is required" });
    }

    // Get user email from session
    const userEmail = email;
    console.log("User email:", userEmail);

    // Verify user belongs to company
    const userData = await sqlDb.getRow(
      "SELECT role, name FROM users WHERE email = $1 AND company_id = $2 AND active = true",
      [userEmail, companyId]
    );
    // console.log("User data from DB:", userData);

    if (!userData) {
      console.log("User not authorized for this company");
      return res
        .status(403)
        .json({ error: "Forbidden - User not authorized for this company" });
    }

    // Fetch all contacts for the company
    // Fetch all contacts for the company
    const contacts = await sqlDb.getRows(
      `
  SELECT 
    c.id,
    c.contact_id,
    c.name,
    c.contact_name,
    c.phone,
    c.phone_index,
    c.email,
    c.chat_id,
    c.profile,
    c.profile_pic_url,
    c.tags,
    c.created_at,
    c.last_updated,
    c.phone_indexes,
    c.unread_count,
    c.custom_fields,
    c.branch,
    c.expiry_date,
    c.vehicle_number,
    c.ic,
    c.address1,
    c.company,
    c.notes,
    c.last_name,
    c.pinned,
    c.points,
    CASE 
      WHEN c.chat_id LIKE '%@c.us' THEN true 
      ELSE false 
    END as is_individual,
    (
      SELECT jsonb_agg(e.name)
      FROM assignments a
      JOIN employees e ON a.employee_id = e.employee_id
      WHERE a.contact_id = c.contact_id 
      AND a.company_id = c.company_id
      AND a.status = 'active'
    ) as assigned_to,
    (
      SELECT jsonb_build_object(
        'chat_id', m.chat_id,
        'from', m.chat_id,
        'from_me', m.from_me,
        'id', m.message_id,
        'source', '',
        'status', m.status,
        'text', jsonb_build_object('body', m.content),
        'timestamp', EXTRACT(EPOCH FROM m.timestamp)::bigint,
        'type', m.message_type,
        'name', m.author
      )
      FROM messages m
      WHERE m.contact_id = c.contact_id
      AND m.company_id = c.company_id
      ORDER BY m.timestamp DESC
      LIMIT 1
    ) as last_message
  FROM contacts c
  WHERE c.company_id = $1
  ORDER BY c.last_updated DESC
`,
      [companyId]
    );

    // Process contacts to match frontend expectations
    const processedContacts = contacts.map((contact, idx) => {
      // Parse tags from JSONB if they are a string, or use empty array if null/undefined
      let tags = contact.tags;
      try {
        if (typeof tags === "string") {
          tags = JSON.parse(tags);
        }
        // Ensure tags is an array and filter out empty values
        tags = Array.isArray(tags) ? tags.filter((tag) => tag) : [];
      } catch (error) {
        console.error(
          `Error parsing tags for contact[${idx}]:`,
          error,
          "Raw tags:",
          contact.tags
        );
        tags = [];
      }

      // Parse phone_indexes from JSONB if they are a string, or use empty array if null/undefined
      let phoneIndexes = contact.phone_indexes;
      try {
        if (typeof phoneIndexes === "string") {
          phoneIndexes = JSON.parse(phoneIndexes);
        }
        phoneIndexes = Array.isArray(phoneIndexes)
          ? phoneIndexes.filter((v) => v !== undefined && v !== null)
          : [];
      } catch (error) {
        console.error(
          `Error parsing phone_indexes for contact[${idx}]:`,
          error,
          "Raw phone_indexes:",
          contact.phone_indexes
        );
        phoneIndexes = [];
      }

      // Parse assigned_to from JSONB if it exists
      let assignedTo = contact.assigned_to;
      try {
        if (typeof assignedTo === "string") {
          assignedTo = JSON.parse(assignedTo);
        }
        // Ensure assignedTo is an array
        assignedTo = Array.isArray(assignedTo) ? assignedTo : [];
      } catch (error) {
        console.error(
          `Error parsing assigned_to for contact[${idx}]:`,
          error,
          "Raw assigned_to:",
          contact.assigned_to
        );
        assignedTo = [];
      }

      const processed = {
        id: contact.id,
        contact_id: contact.contact_id,
        name: contact.name || contact.contact_name || "",
        phone: contact.phone || "",
        email: contact.email || "",
        chat_id: contact.chat_id || "",
        profileUrl: contact.profile_pic_url || "",
        profile: contact.profile || {},
        tags: tags,
        phoneIndex: contact.phone_index || 0,
        phoneIndexes: phoneIndexes,
        assignedTo: assignedTo,
        createdAt: contact.created_at,
        pinned: contact.pinned,
        lastUpdated: contact.last_updated,
        isIndividual: contact.is_individual,
        last_message: contact.last_message || null,
        unreadCount: contact.unread_count || 0,
        customFields: contact.custom_fields || {},
        // Add the missing fields
        branch: contact.branch || null,
        expiryDate: contact.expiry_date || null,
        vehicleNumber: contact.vehicle_number || null,
        ic: contact.ic || null,
        address1: contact.address1 || null,
        company: contact.company || null,
        notes: contact.notes || null,
        lastName: contact.last_name || null,
        points: contact.points || 0,
      };
      //  console.log(`Processed contact[${idx}]:`, processed);
      return processed;
    });

    // Filter contacts based on user role

    const filteredContacts = filterContactsByUserRole(
      processedContacts,
      userData.role,
      userData.name
    );

    res.json({
      success: true,
      total: processedContacts.length,
      contacts: processedContacts,
    });
  } catch (error) {
    console.error("Error fetching contacts:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch contacts",
      message: error.message,
    });
  }
});

// Function to filter contacts based on user role
function filterContactsByUserRole(contacts, userRole, userName) {
  // If user is admin (role 1), return all contacts
  if (userRole === "1") {
    return contacts;
  }

  // If user is sales (role 2), return only contacts assigned to them
  if (userRole === "2") {
    return contacts.filter((contact) => {
      // Check if contact is assigned to this user
      const isAssignedToUser =
        contact.assignedTo &&
        contact.assignedTo.some(
          (assignee) => assignee.toLowerCase() === userName.toLowerCase()
        );

      // Check if contact has user's name in tags
      const hasUserTag =
        contact.tags &&
        contact.tags.some(
          (tag) =>
            typeof tag === "string" &&
            tag.toLowerCase() === userName.toLowerCase()
        );

      // Include group chats regardless of assignment
      const isGroupChat = contact.chat_id && contact.chat_id.includes("@g.us");

      return isAssignedToUser || hasUserTag || isGroupChat;
    });
  }

  // For other roles, return empty array
  return [];
}

module.exports = { botMap };

// Get user data
app.get("/api/user-data", async (req, res) => {
  try {
    const { email } = req.query;

    const result = await sqlDb.query(`SELECT * FROM users WHERE email = $1`, [
      email,
    ]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching user data:", error);
    res.status(500).json({ error: "Failed to fetch user data" });
  }
});

// Get company data
app.get("/api/company-data", async (req, res) => {
  try {
    const { companyId } = req.query;

    const result = await sqlDb.query(
      `SELECT * FROM companies WHERE company_id = $1`,
      [companyId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Company not found" });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching company data:", error);
    res.status(500).json({ error: "Failed to fetch company data" });
  }
});

// Get messages
app.get("/api/messages", async (req, res) => {
  try {
    const { chatId, companyId } = req.query;
    // console.log(
    //   "Fetching messages for chatId:",
    //   chatId,
    //   "companyId:",
    //   companyId
    // );
    const result = await sqlDb.query(
      `SELECT m.id, m.message_id, m.company_id, m.contact_id, m.thread_id, 
             m.customer_phone, m.content, m.message_type, m.media_url, m.timestamp,
             m.logs, m.tags, m.reaction, m.reaction_timestamp, m.edited, m.edited_at,
             m.start_time, m.end_time, m.duration, m.direction, m.status, m.created_at,
             m.from_me, m.chat_id, m.author, m.media_data, m.media_metadata, 
             m.phone_index, m.quoted_message, c.name as contact_name
       FROM messages m
       LEFT JOIN contacts c ON m.contact_id = c.contact_id AND m.company_id = c.company_id
       WHERE m.contact_id = $1 AND m.company_id = $2 
       ORDER BY m.timestamp ASC`,
      [chatId, companyId]
    );

    res.json(result.rows);
  } catch (error) {
    console.error("Error fetching messages:", error);
    res.status(500).json({ error: "Failed to fetch messages" });
  }
});
// Get paginated messages for app
app.get("/api/message-pages", async (req, res) => {
  try {
    const { chatId, companyId, limit = 50, offset = 0 } = req.query;
    if (!chatId || !companyId) {
      return res.status(400).json({ error: "Missing chatId or companyId" });
    }

    const sql = `
      SELECT m.*, c.name as contact_name 
      FROM messages m
      LEFT JOIN contacts c ON m.contact_id = c.contact_id AND m.company_id = c.company_id
      WHERE m.contact_id = $1 AND m.company_id = $2
      ORDER BY m.timestamp DESC
      LIMIT $3 OFFSET $4
    `;
    const params = [
      chatId,
      companyId,
      parseInt(limit, 10),
      parseInt(offset, 10),
    ];

    const result = await sqlDb.query(sql, params);

    res.json({
      success: true,
      messages: result.rows,
      count: result.rows.length,
    });
  } catch (error) {
    console.error("Error fetching paginated messages:", error);
    res.status(500).json({ error: "Failed to fetch messages" });
  }
});

// Update contact
app.patch("/api/contacts/:contactId", async (req, res) => {
  try {
    const { contactId } = req.params;
    const { company_id, tags, last_message } = req.body;

    const result = await sqlDb.query(
      `UPDATE contacts 
       SET tags = $1, 
           last_message = $2,
           last_updated = CURRENT_TIMESTAMP
       WHERE contact_id = $3 AND company_id = $4
       RETURNING *`,
      [tags, last_message, contactId, company_id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Contact not found" });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error updating contact:", error);
    res.status(500).json({ error: "Failed to update contact" });
  }
});

// API endpoint to get all user context data (user + company + employees)
app.get("/api/user-context", async (req, res) => {
  try {
    const { email } = req.query;

    // 1. Get user data
    const userResult = await sqlDb.query(
      `SELECT * FROM users WHERE email = $1`,
      [email]
    );

    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    const userData = userResult.rows[0];
    const companyId = userData.company_id;

    // 2. Get company data (including phone info)
    const companyResult = await sqlDb.query(
      `SELECT * FROM companies WHERE company_id = $1`,
      [companyId]
    );

    const companyData = companyResult.rows[0] || {};

    // Process phone names
    const phoneCount = companyData.phone_count || 0;
    const apiUrl = companyData.api_url || process.env.URL;
    const stopBot = companyData.stopbot || false;
    const stopBots = companyData.stopbots || {};

    let phoneNamesData = {};
    let phoneNames = [];
    if (companyData.phone_numbers) {
      try {
        // Accept both stringified array and array
        if (typeof companyData.phone_numbers === "string") {
          phoneNames = JSON.parse(companyData.phone_numbers);
        } else if (Array.isArray(companyData.phone_numbers)) {
          phoneNames = companyData.phone_numbers;
        }
      } catch (e) {
        phoneNames = [];
      }
    }
    // Always fallback to default names if empty
    for (let i = 0; i < (companyData.phone_count || 1); i++) {
      phoneNamesData[i] = phoneNames[i] || `Phone ${i + 1}`;
    }

    // 3. Get all employees for the company
    const employeesResult = await sqlDb.query(
      `SELECT 
        id, name, email, role, employee_id, phone_number 
       FROM employees 
       WHERE company_id = $1`,
      [companyId]
    );

    // Return combined data
    res.json({
      ...userData,
      companyId,
      phoneNames: phoneNamesData,
      phoneCount: phoneCount,
      employees: employeesResult.rows,
      apiUrl: apiUrl,
      stopBot: stopBot,
      stopBots: stopBots,
    });
  } catch (error) {
    console.error("Error fetching user context:", error);
    res.status(500).json({ error: "Failed to fetch user context" });
  }
});

// API endpoint to get detailed user data
app.get("/api/user-details", async (req, res) => {
  try {
    const { email } = req.query;

    const result = await sqlDb.query(
      `SELECT 
        name, phone_number, role, company_id, emp_group, 
        employee_id, notes, quota_leads, invoice_number,
        phone_access, image_url, weightages, view_employees
       FROM employees
       WHERE email = $1`,
      [email]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error fetching user details:", error);
    res.status(500).json({ error: "Failed to fetch user details" });
  }
});

// API endpoint to get all user context data (user + company + employees)
app.get("/api/user-page-context", async (req, res) => {
  try {
    const { email } = req.query;

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    // 1. Get user data from users table
    const userResult = await sqlDb.query(
      `SELECT u.*, e.employee_id, e.phone_access, e.weightages, e.image_url, 
              e.notes, e.quota_leads, e.view_employees, e.invoice_number, e.emp_group
       FROM users u
       LEFT JOIN employees e ON u.email = e.email AND u.company_id = e.company_id
       WHERE u.email = $1 AND u.active = true`,
      [email]
    );

    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    const userData = userResult.rows[0];
    const companyId = userData.company_id;

    // 2. Get company data (including phone info)
    const companyResult = await sqlDb.query(
      `SELECT * FROM companies WHERE company_id = $1`,
      [companyId]
    );

    const companyData = companyResult.rows[0] || {};

    let phoneNamesData = {};
    let phoneNames = [];
    if (companyData.phone_numbers) {
      try {
        // Accept both stringified array and array
        if (typeof companyData.phone_numbers === "string") {
          phoneNames = JSON.parse(companyData.phone_numbers);
        } else if (Array.isArray(companyData.phone_numbers)) {
          phoneNames = companyData.phone_numbers;
        }
      } catch (e) {
        phoneNames = [];
      }
    }
    // Always fallback to default names if empty
    for (let i = 0; i < (companyData.phone_count || 1); i++) {
      phoneNamesData[i] = phoneNames[i] || `Phone ${i + 1}`;
    }
    console.log("Phone names data:", phoneNamesData);

    // 3. Get all employees for the company
    const employeesResult = await sqlDb.query(
      `SELECT 
        id, name, email, role, employee_id, phone_number, assigned_contacts, image_url, view_employees, emp_group, phone_access, weightages
       FROM employees 
       WHERE company_id = $1 AND active = true
       ORDER BY role, name`,
      [companyId]
    );

    // Format employees data
    const employeeListData = employeesResult.rows.map((employee) => {
      let phoneAccess = {};
      let weightages = {};
      let viewEmployees = [];

      // Parse JSON fields safely
      try {
        if (employee.phone_access) {
          phoneAccess =
            typeof employee.phone_access === "string"
              ? JSON.parse(employee.phone_access)
              : employee.phone_access;
        }
      } catch (error) {
        console.error(
          "Error parsing phone_access for employee:",
          employee.email,
          error
        );
        phoneAccess = {};
      }

      try {
        if (employee.weightages) {
          weightages =
            typeof employee.weightages === "string"
              ? JSON.parse(employee.weightages)
              : employee.weightages;
        }
      } catch (error) {
        console.error(
          "Error parsing weightages for employee:",
          employee.email,
          error
        );
        weightages = {};
      }

      try {
        if (employee.view_employees) {
          viewEmployees =
            typeof employee.view_employees === "string"
              ? JSON.parse(employee.view_employees)
              : employee.view_employees;
        }
      } catch (error) {
        console.error(
          "Error parsing view_employees for employee:",
          employee.email,
          error
        );
        viewEmployees = [];
      }

      return {
        id: employee.id,
        name: employee.name,
        email: employee.email || employee.id,
        role: employee.role,
        employeeId: employee.employee_id,
        phoneNumber: employee.phone_number,
        assignedContacts: employee.assigned_contacts || 0,
        imageUrl: employee.image_url || "",
        viewEmployees: viewEmployees,
        empGroup: employee.emp_group || "",
        phoneAccess: phoneAccess,
        weightages: weightages,
      };
    });

    // Parse current user's JSON fields
    let currentUserPhoneAccess = {};
    let currentUserWeightages = {};
    let currentUserViewEmployees = [];

    try {
      if (userData.phone_access) {
        currentUserPhoneAccess =
          typeof userData.phone_access === "string"
            ? JSON.parse(userData.phone_access)
            : userData.phone_access;
      }
    } catch (error) {
      console.error("Error parsing current user phone_access:", error);
      currentUserPhoneAccess = {};
    }

    try {
      if (userData.weightages) {
        currentUserWeightages =
          typeof userData.weightages === "string"
            ? JSON.parse(userData.weightages)
            : userData.weightages;
      }
    } catch (error) {
      console.error("Error parsing current user weightages:", error);
      currentUserWeightages = {};
    }

    try {
      if (userData.view_employees) {
        currentUserViewEmployees =
          typeof userData.view_employees === "string"
            ? JSON.parse(userData.view_employees)
            : userData.view_employees;
      }
    } catch (error) {
      console.error("Error parsing current user view_employees:", error);
      currentUserViewEmployees = [];
    }

    // Return combined data
    res.json({
      companyId,
      role: userData.role,
      email: userData.email,
      name: userData.name,
      phoneAccess: currentUserPhoneAccess,
      weightages: currentUserWeightages,
      viewEmployees: currentUserViewEmployees,
      phoneNames: phoneNamesData,
      employees: employeeListData,
      companyData: {
        phoneCount: phoneNames.length || 1,
        ghl_accessToken: companyData.ghl_accesstoken,
        apiUrl: companyData.api_url || process.env.URL,
        v2: companyData.v2,
        whapiToken: companyData.whapi_token,
        stopBot: companyData.stopbot || false,
        stopBots: companyData.stopbots || {},
      },
    });
  } catch (error) {
    console.error("Error fetching user context:", error);
    res.status(500).json({ error: "Failed to fetch user context" });
  }
});

// API endpoint to get detailed user data
app.get("/api/user-page-details", async (req, res) => {
  try {
    const { id } = req.query; // This is the email

    if (!id) {
      return res.status(400).json({ error: "User ID (email) is required" });
    }

    // Get user and employee data with a LEFT JOIN
    const query = `
      SELECT u.name, u.phone, u.role, u.company_id, u.email, e.phone_number,
             e.employee_id, e.phone_access, e.weightages, e.image_url, 
             e.notes, e.quota_leads, e.view_employees, e.invoice_number, e.emp_group
      FROM users u
      LEFT JOIN employees e ON u.email = e.email AND u.company_id = e.company_id
      WHERE u.email = $1 AND u.active = true
    `;
    const result = await sqlDb.query(query, [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }

    const userData = result.rows[0];

    // Parse JSON fields safely
    let phoneAccess = {};
    let weightages = {};
    let viewEmployees = [];

    try {
      if (userData.phone_access) {
        phoneAccess =
          typeof userData.phone_access === "string"
            ? JSON.parse(userData.phone_access)
            : userData.phone_access;
      }
    } catch (error) {
      console.error("Error parsing phone_access:", error);
      phoneAccess = {};
    }

    try {
      if (userData.weightages) {
        weightages =
          typeof userData.weightages === "string"
            ? JSON.parse(userData.weightages)
            : userData.weightages;
      }
    } catch (error) {
      console.error("Error parsing weightages:", error);
      weightages = {};
    }

    try {
      if (userData.view_employees) {
        viewEmployees =
          typeof userData.view_employees === "string"
            ? JSON.parse(userData.view_employees)
            : userData.view_employees;
      }
    } catch (error) {
      console.error("Error parsing view_employees:", error);
      viewEmployees = [];
    }

    // Format the response to match the frontend expectations
    const response = {
      name: userData.name,
      phoneNumber: userData.phone_number,
      email: userData.email,
      role: userData.role,
      companyId: userData.company_id,
      employeeId: userData.employee_id,
      phone_access: phoneAccess,
      weightages: weightages,
      imageUrl: userData.image_url,
      notes: userData.notes,
      quotaLeads: userData.quota_leads || 0,
      viewEmployees: viewEmployees,
      invoiceNumber: userData.invoice_number,
      group: userData.emp_group,
    };

    res.json(response);
  } catch (error) {
    console.error("Error fetching user details:", error);
    res.status(500).json({ error: "Failed to fetch user details" });
  }
});

// API endpoint to get quick replies for a user (by email)
app.get("/api/quick-replies", async (req, res) => {
  try {
    const { email } = req.query;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    // Get company_id from users table
    const userResult = await sqlDb.query(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }
    const companyId = userResult.rows[0].company_id;

    // Get quick replies for the company
    const quickRepliesResult = await sqlDb.query(
      `SELECT id, category, keyword, text, type, documents, images, videos, created_by, created_at, updated_at, status
       FROM quick_replies
       WHERE company_id = $1 AND status = 'active'
       ORDER BY updated_at DESC`,
      [companyId]
    );

    res.json({ quickReplies: quickRepliesResult.rows });
  } catch (error) {
    console.error("Error fetching quick replies:", error);
    res.status(500).json({ error: "Failed to fetch quick replies" });
  }
});

// API endpoint to add a quick reply
app.post("/api/quick-replies", async (req, res) => {
  try {
    const {
      email,
      category,
      keyword,
      text,
      type,
      documents,
      images,
      videos,
      created_by,
    } = req.body;

    if (!email || !text) {
      return res.status(400).json({ error: "Email and text are required" });
    }

    // Get company_id from users table
    const userResult = await sqlDb.query(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (userResult.rows.length === 0) {
      return res.status(404).json({ error: "User not found" });
    }
    const companyId = userResult.rows[0].company_id;

    // Insert quick reply
    const insertResult = await sqlDb.query(
      `INSERT INTO quick_replies
        (company_id, category, keyword, text, type, documents, images, videos, created_by, created_at, updated_at, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 'active')
        RETURNING id, category, keyword, text, type, documents, images, videos, created_by, created_at, updated_at, status`,
      [
        companyId,
        category || null,
        keyword || null,
        text,
        type || null,
        documents ? JSON.stringify(documents) : null,
        images ? JSON.stringify(images) : null,
        videos ? JSON.stringify(videos) : null,
        created_by || email,
      ]
    );

    res.json({ success: true, quickReply: insertResult.rows[0] });
  } catch (error) {
    console.error("Error adding quick reply:", error);
    res.status(500).json({ error: "Failed to add quick reply" });
  }
});

// API endpoint to edit a quick reply
app.put("/api/quick-replies/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      category,
      keyword,
      text,
      type,
      documents,
      images,
      videos,
      status,
      updated_by,
    } = req.body;

    const updateFields = [];
    const values = [];
    let idx = 1;

    if (category !== undefined) {
      updateFields.push(`category = $${idx++}`);
      values.push(category);
    }
    if (keyword !== undefined) {
      updateFields.push(`keyword = $${idx++}`);
      values.push(keyword);
    }
    if (text !== undefined) {
      updateFields.push(`text = $${idx++}`);
      values.push(text);
    }
    if (type !== undefined) {
      updateFields.push(`type = $${idx++}`);
      values.push(type);
    }
    if (documents !== undefined) {
      updateFields.push(`documents = $${idx++}`);
      values.push(documents);
    }
    if (images !== undefined) {
      updateFields.push(`images = $${idx++}`);
      values.push(images);
    }
    if (videos !== undefined) {
      updateFields.push(`videos = $${idx++}`);
      values.push(videos);
    }
    if (status !== undefined) {
      updateFields.push(`status = $${idx++}`);
      values.push(status);
    }
    if (updated_by !== undefined) {
      updateFields.push(`updated_by = $${idx++}`);
      values.push(updated_by);
    }
    updateFields.push(`updated_at = CURRENT_TIMESTAMP`);

    if (updateFields.length === 0) {
      return res.status(400).json({ error: "No fields to update" });
    }

    values.push(id);

    const query = `
      UPDATE quick_replies
      SET ${updateFields.join(", ")}
      WHERE id = $${idx}
      RETURNING *
    `;

    const result = await sqlDb.query(query, values);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Quick reply not found" });
    }

    res.json({ success: true, quickReply: result.rows[0] });
  } catch (error) {
    console.error("Error updating quick reply:", error);
    res.status(500).json({ error: "Failed to update quick reply" });
  }
});

// API endpoint to delete a quick reply
app.delete("/api/quick-replies/:id", async (req, res) => {
  try {
    const { id } = req.params;
    // Soft delete: set status to 'deleted'
    const result = await sqlDb.query(
      `UPDATE quick_replies SET status = 'deleted', updated_at = CURRENT_TIMESTAMP WHERE id = $1 RETURNING id`,
      [id]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Quick reply not found" });
    }
    res.json({ success: true, id });
  } catch (error) {
    console.error("Error deleting quick reply:", error);
    res.status(500).json({ error: "Failed to delete quick reply" });
  }
});

// API endpoint to get quick reply categories from settings
app.get("/api/quick-reply-categories", async (req, res) => {
  try {
    const { companyId } = req.query;
    if (!companyId) {
      return res.status(400).json({ error: "companyId is required" });
    }
    const result = await sqlDb.query(
      `SELECT setting_value FROM settings WHERE company_id = $1 AND setting_type = 'quick_reply' AND setting_key = 'categories'`,
      [companyId]
    );
    if (result.rows.length === 0) {
      return res.json({ categories: [] });
    }
    res.json({ categories: result.rows[0].setting_value || [] });
  } catch (error) {
    console.error("Error fetching quick reply categories:", error);
    res.status(500).json({ error: "Failed to fetch categories" });
  }
});

// API endpoint to add a quick reply category
app.post("/api/quick-reply-categories", async (req, res) => {
  try {
    const { companyId, category } = req.body;
    if (!companyId || !category) {
      return res
        .status(400)
        .json({ error: "companyId and category are required" });
    }
    // Get current categories
    const result = await sqlDb.query(
      `SELECT id, setting_value FROM settings WHERE company_id = $1 AND setting_type = 'quick_reply' AND setting_key = 'categories'`,
      [companyId]
    );
    let categories = [];
    let settingsId = null;
    if (result.rows.length > 0) {
      categories = result.rows[0].setting_value || [];
      settingsId = result.rows[0].id;
    }
    if (categories.includes(category)) {
      return res.status(409).json({ error: "Category already exists" });
    }
    categories.push(category);
    if (settingsId) {
      await sqlDb.query(
        `UPDATE settings SET setting_value = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2`,
        [JSON.stringify(categories), settingsId]
      );
    } else {
      await sqlDb.query(
        `INSERT INTO settings (company_id, setting_type, setting_key, setting_value) VALUES ($1, 'quick_reply', 'categories', $2)`,
        [companyId, JSON.stringify(categories)]
      );
    }
    res.json({ success: true, categories });
  } catch (error) {
    console.error("Error adding quick reply category:", error);
    res.status(500).json({ error: "Failed to add category" });
  }
});

// API endpoint to edit a quick reply category
app.put("/api/quick-reply-categories", async (req, res) => {
  try {
    const { companyId, oldCategory, newCategory } = req.body;
    if (!companyId || !oldCategory || !newCategory) {
      return res
        .status(400)
        .json({ error: "companyId, oldCategory, newCategory are required" });
    }
    const result = await sqlDb.query(
      `SELECT id, setting_value FROM settings WHERE company_id = $1 AND setting_type = 'quick_reply' AND setting_key = 'categories'`,
      [companyId]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Categories not found" });
    }
    let categories = result.rows[0].setting_value || [];
    const idx = categories.indexOf(oldCategory);
    if (idx === -1) {
      return res.status(404).json({ error: "Old category not found" });
    }
    categories[idx] = newCategory;
    await sqlDb.query(
      `UPDATE settings SET setting_value = $1, last_updated = CURRENT_TIMESTAMP WHERE id = $2`,
      [JSON.stringify(categories), result.rows[0].id]
    );
    res.json({ success: true, categories });
  } catch (error) {
    console.error("Error editing quick reply category:", error);
    res.status(500).json({ error: "Failed to edit category" });
  }
});

// API endpoint to delete a quick reply category
app.delete("/api/quick-reply-categories", async (req, res) => {
  try {
    const { companyId, category } = req.body;
    if (!companyId || !category) {
      return res
        .status(400)
        .json({ error: "companyId and category are required" });
    }
    const result = await sqlDb.query(
      `SELECT id, setting_value FROM settings WHERE company_id = $1 AND setting_type = 'quick_reply' AND setting_key = 'categories'`,
      [companyId]
    );
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Categories not found" });
    }
    let categories = result.rows[0].setting_value || [];
    categories = categories.filter((c) => c !== category);
    await sqlDb.query(
      `UPDATE settings SET setting_value = $1, last_updated = CURRENT_TIMESTAMP WHERE id = $2`,
      [JSON.stringify(categories), result.rows[0].id]
    );
    res.json({ success: true, categories });
  } catch (error) {
    console.error("Error deleting quick reply category:", error);
    res.status(500).json({ error: "Failed to delete category" });
  }
});

// Get AI settings
app.get("/api/ai-settings", async (req, res) => {
  try {
    const { companyId } = req.query;
    if (!companyId) {
      return res.status(400).json({ error: "companyId is required" });
    }
    const result = await sqlDb.query(
      `SELECT setting_key, setting_value 
       FROM settings 
       WHERE company_id = $1 AND setting_type = 'messaging' AND setting_key IN ('aiDelay', 'autoResponse')`,
      [companyId]
    );
    const settings = {};
    result.rows.forEach((row) => {
      try {
        const parsed =
          typeof row.setting_value === "string"
            ? JSON.parse(row.setting_value)
            : row.setting_value;
        settings[row.setting_key] = parsed.value;
      } catch {
        settings[row.setting_key] = row.setting_value;
      }
    });
    res.json({ settings });
  } catch (error) {
    console.error("Error fetching AI settings:", error);
    res.status(500).json({ error: "Failed to fetch AI settings" });
  }
});

// Update AI settings
app.put("/api/ai-settings", async (req, res) => {
  try {
    const { companyId, settings } = req.body;
    if (!companyId || typeof settings !== "object" || !settings) {
      return res
        .status(400)
        .json({ error: "companyId and settings object are required" });
    }
    const allowedKeys = ["aiDelay", "autoResponse"];
    const updates = [];
    for (const key of allowedKeys) {
      if (key in settings) {
        // First, check if the entry exists
        const checkResult = await sqlDb.query(
          `SELECT id FROM settings WHERE company_id = $1 AND setting_type = 'messaging' AND setting_key = $2`,
          [companyId, key]
        );
        if (checkResult.rows.length > 0) {
          // Exists, update
          updates.push(
            sqlDb.query(
              `UPDATE settings SET setting_value = $1, updated_at = CURRENT_TIMESTAMP
             WHERE company_id = $2 AND setting_type = 'messaging' AND setting_key = $3
             RETURNING setting_key, setting_value`,
              [JSON.stringify({ value: settings[key] }), companyId, key]
            )
          );
        } else {
          // Doesn't exist, insert
          updates.push(
            sqlDb.query(
              `INSERT INTO settings (company_id, setting_type, setting_key, setting_value, updated_at, created_at)
             VALUES ($1, 'messaging', $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
             RETURNING setting_key, setting_value`,
              [companyId, key, JSON.stringify({ value: settings[key] })]
            )
          );
        }
      }
    }
    const results = await Promise.all(updates);
    const responseSettings = {};
    results.forEach((r) => {
      if (r.rows.length > 0) {
        const row = r.rows[0];
        try {
          const parsed =
            typeof row.setting_value === "string"
              ? JSON.parse(row.setting_value)
              : row.setting_value;
          responseSettings[row.setting_key] = parsed.value;
        } catch {
          responseSettings[row.setting_key] = row.setting_value;
        }
      }
    });
    res.json({ success: true, settings: responseSettings });
  } catch (error) {
    console.error("Error updating AI settings:", error);
    res.status(500).json({ error: "Failed to update AI settings" });
  }
});

// API endpoint to get company groups
app.get("/api/company-groups", async (req, res) => {
  try {
    const { companyId } = req.query;

    const result = await sqlDb.query(
      `SELECT DISTINCT emp_group AS group_name 
       FROM employees 
       WHERE company_id = $1 AND emp_group IS NOT NULL`,
      [companyId]
    );

    const groups = result.rows.map((row) => row.group_name);
    res.json(groups);
  } catch (error) {
    console.error("Error fetching company groups:", error);
    res.status(500).json({ error: "Failed to fetch company groups" });
  }
});

app.post("/api/private-note", async (req, res) => {
  try {
    const { companyId, chatId, text, from, fromEmail } = req.body;
    if (!companyId || !chatId || !text || !from) {
      return res.status(400).json({ error: "Missing required fields" });
    }

    const numericChatId = chatId.startsWith("+")
      ? chatId
      : "+" + chatId.replace(/\D/g, "");

    const contactId = companyId + "-" + numericChatId.replace(/^\+/, "");

    const noteId = uuidv4();
    const timestamp = new Date();

    const insertNoteQuery = `
      INSERT INTO private_notes (
        id, company_id, contact_id, text, "from", from_email, timestamp, type
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *
    `;
    const noteResult = await sqlDb.query(insertNoteQuery, [
      noteId,
      companyId,
      contactId,
      text,
      from,
      fromEmail || "",
      timestamp,
      "privateNote",
    ]);
    const note = noteResult.rows[0];

    const insertMessageQuery = `
      INSERT INTO messages (
        message_id, company_id, contact_id, content, message_type,
        timestamp, direction, status, from_me, chat_id, author
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    `;
    await sqlDb.query(insertMessageQuery, [
      noteId,
      companyId,
      contactId,
      text,
      "privateNote",
      timestamp,
      "internal",
      "delivered",
      true,
      numericChatId,
      from,
    ]);

    const mentions = (text.match(/@\w+/g) || []).map((m) => m.slice(1));
    for (const employeeName of mentions) {
      await addNotificationToUser(companyId, text, employeeName);
    }

    res.json({
      success: true,
      note: {
        id: note.id,
        text: note.text,
        from: note.from,
        timestamp: note.timestamp,
        type: note.type,
      },
    });
  } catch (error) {
    console.error("Error adding private note:", error);
    res.status(500).json({ error: "Failed to add private note" });
  }
});

app.post("/api/company/update-stopbot", async (req, res) => {
  try {
    const { companyId, stopbot, phoneIndex } = req.body;
    if (!companyId) {
      return res.status(400).json({ error: "companyId is required" });
    }
    if (typeof stopbot === "undefined" || typeof phoneIndex === "undefined") {
      return res
        .status(400)
        .json({ error: "stopbot and phoneIndex are required" });
    }

    // Fetch current stopbots object
    const companyResult = await sqlDb.query(
      "SELECT stopbots FROM companies WHERE company_id = $1",
      [companyId]
    );
    if (companyResult.rows.length === 0) {
      return res.status(404).json({ error: "Company not found" });
    }
    let stopbots = companyResult.rows[0].stopbots || {};

    // If stopbots is a string (from DB), parse it
    if (typeof stopbots === "string") {
      try {
        stopbots = JSON.parse(stopbots);
      } catch {
        stopbots = {};
      }
    }

    // Update the stopbots for the given phoneIndex
    stopbots[phoneIndex] = stopbot;

    // Update the company row
    const result = await sqlDb.query(
      `
        UPDATE companies
        SET stopbot = $1,
            stopbots = $2,
            updated_at = CURRENT_TIMESTAMP
        WHERE company_id = $3
        RETURNING company_id, stopbot, stopbots
      `,
      [stopbot, JSON.stringify(stopbots), companyId]
    );

    res.json({
      success: true,
      message: "Company stopbot settings updated",
      data: result.rows[0],
    });
  } catch (error) {
    console.error("Error updating stopbot:", error);
    res
      .status(500)
      .json({ error: "Failed to update stopbot", details: error.message });
  }
});

// Get reminder settings
app.get("/api/reminder-settings", async (req, res) => {
  try {
    const { email } = req.query;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Get reminder settings from settings table
    const settingsResult = await sqlDb.getRow(
      "SELECT setting_value FROM settings WHERE company_id = $1 AND setting_type = 'config' AND setting_key = 'reminder'",
      [user.company_id]
    );

    let reminderSettings = [];
    if (settingsResult && settingsResult.setting_value) {
      reminderSettings = Array.isArray(settingsResult.setting_value)
        ? settingsResult.setting_value
        : [settingsResult.setting_value];
    } else {
      // Return default reminder settings
      reminderSettings = [
        {
          enabled: true,
          hours_before: 24,
          message_template:
            "Reminder: You have an appointment scheduled for {datetime}",
          selected_employees: [],
          recipient_type: "contacts",
        },
      ];
    }

    res.json({
      company_id: user.company_id,
      reminders: reminderSettings,
    });
  } catch (error) {
    console.error("Error fetching reminder settings:", error);
    res.status(500).json({ error: "Failed to fetch reminder settings" });
  }
});

// Update reminder settings
app.put("/api/reminder-settings", async (req, res) => {
  try {
    const { email, reminders } = req.body;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    if (!Array.isArray(reminders)) {
      return res.status(400).json({ error: "Reminders must be an array" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Check if setting exists
    const existingSetting = await sqlDb.getRow(
      "SELECT id FROM settings WHERE company_id = $1 AND setting_type = 'config' AND setting_key = 'reminder'",
      [user.company_id]
    );

    if (existingSetting) {
      // Update existing setting
      await sqlDb.query(
        "UPDATE settings SET setting_value = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
        [JSON.stringify(reminders), existingSetting.id]
      );
    } else {
      // Insert new setting
      await sqlDb.query(
        "INSERT INTO settings (company_id, setting_type, setting_key, setting_value, created_at, updated_at) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)",
        [user.company_id, "config", "reminder", JSON.stringify(reminders)]
      );
    }

    res.json({
      company_id: user.company_id,
      reminders: reminders,
    });
  } catch (error) {
    console.error("Error updating reminder settings:", error);
    res.status(500).json({ error: "Failed to update reminder settings" });
  }
});

// Get all appointments for a company
app.get("/api/appointments", async (req, res) => {
  try {
    const { email, employeeId } = req.query;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    let query = `
      SELECT 
        a.id,
        a.appointment_id,
        a.title,
        a.description as details,
        a.scheduled_time as "startTime",
        (a.scheduled_time + (COALESCE(a.duration_minutes, 60) * interval '1 minute')) as "endTime",
        a.status as "appointmentStatus",
        a.created_at as "dateAdded",
        a.metadata,
        a.staff_assigned as staff,
        c.name as contact_name,
        c.phone as contact_phone,
        c.email as contact_email,
        c.contact_id,
        '' as address,
        '#51484f' as color,
        '[]' as tags
      FROM appointments a
      LEFT JOIN contacts c ON a.contact_id = c.contact_id AND a.company_id = c.company_id
      WHERE a.company_id = $1
    `;

    const params = [user.company_id];

    if (employeeId) {
      query += ` AND (a.staff_assigned ? $2 OR a.metadata->'userEmail' = $2)`;
      params.push(employeeId);
    }

    query += ` ORDER BY a.scheduled_time DESC`;

    const result = await sqlDb.query(query, params);

    // Transform the data to match the calendar component's expected format
    const appointments = result.rows.map((appointment) => ({
      id: appointment.id,
      title: appointment.title || "Untitled Appointment",
      startTime: appointment.startTime,
      endTime: appointment.endTime,
      address: appointment.address || "",
      appointmentStatus: appointment.appointmentStatus || "scheduled",
      staff: appointment.staff || [],
      tags: [],
      color: appointment.color,
      dateAdded: appointment.dateAdded,
      contacts: appointment.contact_id
        ? [
            {
              id: appointment.contact_id,
              name: appointment.contact_name || "Unknown",
              phone: appointment.contact_phone || "",
              email: appointment.contact_email || "",
            },
          ]
        : [],
      details: appointment.details || "",
      meetLink: "",
    }));

    res.json({ appointments });
  } catch (error) {
    console.error("Error fetching appointments:", error);
    res.status(500).json({ error: "Failed to fetch appointments" });
  }
});

// Get appointment tags - redirecting to existing endpoint
app.get("/api/appointment-tags", async (req, res) => {
  try {
    const { email } = req.query;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Redirect to the existing company tags endpoint
    const response = await fetch(
      `${req.protocol}://${req.get("host")}/api/companies/${
        user.company_id
      }/tags`
    );
    const data = await response.json();
    res.json(data);
  } catch (error) {
    console.error("Error fetching appointment tags:", error);
    res.status(500).json({ error: "Failed to fetch appointment tags" });
  }
});

app.get("/api/company-data-user", async (req, res) => {
  try {
    const { email } = req.query;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const company = await sqlDb.getRow(
      "SELECT * FROM companies WHERE company_id = $1",
      [user.company_id]
    );

    if (!company) {
      return res.status(404).json({ error: "Company not found" });
    }

    res.json(company);
  } catch (error) {
    console.error("Error fetching company data:", error);
    res.status(500).json({ error: "Failed to fetch company data" });
  }
});

app.get("/api/employees", async (req, res) => {
  try {
    const { email } = req.query;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    // Redirect to the existing user-context endpoint which includes employee data
    const response = await fetch(
      `${req.protocol}://${req.get(
        "host"
      )}/api/user-context?email=${encodeURIComponent(email)}`
    );
    const data = await response.json();

    // Extract and return employee information
    res.json({
      employees: data.employees || [],
      userRole: data.userRole,
      companyId: data.companyId,
    });
  } catch (error) {
    console.error("Error fetching employees:", error);
    res.status(500).json({ error: "Failed to fetch employees" });
  }
});

app.post("/api/send-whatsapp-notification", async (req, res) => {
  try {
    const { email, contacts, message, appointmentDetails } = req.body;

    if (!email || !contacts || !message) {
      return res
        .status(400)
        .json({ error: "Email, contacts, and message are required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const results = [];

    // Send notification to each contact
    for (const contact of contacts) {
      if (contact.phone) {
        try {
          // Clean phone number (remove any non-digit characters except +)
          const cleanPhone = contact.phone.replace(/[^\d+]/g, "");
          const chatId = cleanPhone.startsWith("+")
            ? cleanPhone
            : `+${cleanPhone}`;

          // Use the existing v2 messages API
          const response = await fetch(
            `${req.protocol}://${req.get("host")}/api/v2/messages/text/${
              user.company_id
            }/${encodeURIComponent(chatId)}`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                message: message,
                phoneIndex: 0, // Default to first phone
              }),
            }
          );

          if (response.ok) {
            results.push({
              contact: contact.name || contact.phone,
              phone: contact.phone,
              status: "sent",
              message: "Notification sent successfully",
            });
          } else {
            results.push({
              contact: contact.name || contact.phone,
              phone: contact.phone,
              status: "failed",
              message: "Failed to send notification",
            });
          }
        } catch (error) {
          console.error(
            `Error sending notification to ${contact.phone}:`,
            error
          );
          results.push({
            contact: contact.name || contact.phone,
            phone: contact.phone,
            status: "error",
            message: error.message,
          });
        }
      } else {
        results.push({
          contact: contact.name || "Unknown",
          phone: "N/A",
          status: "skipped",
          message: "No phone number available",
        });
      }
    }

    res.json({
      success: true,
      message: "Notification process completed",
      results: results,
    });
  } catch (error) {
    console.error("Error sending WhatsApp notifications:", error);
    res.status(500).json({ error: "Failed to send WhatsApp notifications" });
  }
});

// Create appointment
app.post("/api/appointments", async (req, res) => {
  try {
    // Accept all fields from request body
    const requestData = { ...req.body };
    console.log("Received appointment request data:", requestData);

    // Extract userEmail for authentication
    const email = requestData.userEmail;
    if (!email) {
      return res
        .status(400)
        .json({ error: "userEmail is required for authentication" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Define schema fields that map directly to database columns
    const schemaFields = {
      appointment_id: null,
      company_id: user.company_id,
      contact_id: null,
      title: null,
      description: null,
      scheduled_time: null,
      duration_minutes: null,
      status: "scheduled", // default status
      metadata: {},
      staff_assigned: [],
      appointment_type: "general", // default type
    };

    // Map common frontend field names to schema fields
    const fieldMappings = {
      // Frontend field -> Schema field
      startTime: "scheduled_time",
      start_time: "scheduled_time",
      endTime: null, // Will be used to calculate duration_minutes
      end_time: null, // Will be used to calculate duration_minutes
      details: "description",
      description: "description",
      appointmentStatus: "status",
      appointmentType: "appointment_type",
      staff: "staff_assigned",
      contacts: "contact_id", // Special handling needed
    };

    // Process each field from request
    const metadataFields = {};

    for (const [key, value] of Object.entries(requestData)) {
      if (key === "userEmail") continue; // Skip auth field

      // Check if field has a direct mapping
      if (fieldMappings.hasOwnProperty(key)) {
        const mappedField = fieldMappings[key];
        if (mappedField) {
          schemaFields[mappedField] = value;
        }
        // Special handling for endTime/end_time to calculate duration
        if (
          (key === "endTime" || key === "end_time") &&
          value &&
          schemaFields.scheduled_time
        ) {
          const startDate = new Date(schemaFields.scheduled_time);
          const endDate = new Date(value);
          schemaFields.duration_minutes = Math.round(
            (endDate.getTime() - startDate.getTime()) / (1000 * 60)
          );
        }
      }
      // Check if field exists directly in schema
      else if (schemaFields.hasOwnProperty(key)) {
        schemaFields[key] = value;
      }
      // Everything else goes to metadata
      else {
        metadataFields[key] = value;
      }
    }

    // Handle contacts field - extract contact_id
    if (requestData.contacts) {
      if (
        Array.isArray(requestData.contacts) &&
        requestData.contacts.length > 0
      ) {
        schemaFields.contact_id =
          requestData.contacts[0].id || requestData.contacts[0].contact_id;
      } else if (typeof requestData.contacts === "string") {
        schemaFields.contact_id = requestData.contacts;
      } else {
        schemaFields.contact_id = null;
      }
    }

    // Handle staff_assigned as JSON
    if (
      schemaFields.staff_assigned &&
      !Array.isArray(schemaFields.staff_assigned)
    ) {
      schemaFields.staff_assigned = [schemaFields.staff_assigned];
    }

    // Generate appointment_id if not provided
    if (!schemaFields.appointment_id) {
      schemaFields.appointment_id = require("crypto").randomUUID();
    }

    // Calculate duration if not set but we have start and end times
    if (
      !schemaFields.duration_minutes &&
      schemaFields.scheduled_time &&
      (requestData.endTime || requestData.end_time)
    ) {
      const startDate = new Date(schemaFields.scheduled_time);
      const endDate = new Date(requestData.endTime || requestData.end_time);
      schemaFields.duration_minutes = Math.round(
        (endDate.getTime() - startDate.getTime()) / (1000 * 60)
      );
    }

    // Validate required fields
    if (!schemaFields.title || !schemaFields.scheduled_time) {
      return res.status(400).json({
        error: "title and scheduled_time (or startTime) are required",
      });
    }

    // Ensure contact_id is null if empty
    schemaFields.contact_id =
      schemaFields.contact_id && String(schemaFields.contact_id).trim() !== ""
        ? schemaFields.contact_id
        : null;

    // Merge additional metadata
    schemaFields.metadata = { ...metadataFields, ...schemaFields.metadata };

    console.log("Creating appointment with schema fields:", {
      appointment_id: schemaFields.appointment_id,
      company_id: schemaFields.company_id,
      contact_id: schemaFields.contact_id,
      title: schemaFields.title,
      appointment_type: schemaFields.appointment_type,
      status: schemaFields.status,
    });

    const result = await sqlDb.query(
      `
      INSERT INTO appointments (
        appointment_id, company_id, contact_id, title, description, 
        scheduled_time, duration_minutes, status, metadata, staff_assigned, appointment_type
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `,
      [
        schemaFields.appointment_id,
        schemaFields.company_id,
        schemaFields.contact_id,
        schemaFields.title,
        schemaFields.description,
        schemaFields.scheduled_time,
        schemaFields.duration_minutes,
        schemaFields.status,
        JSON.stringify(schemaFields.metadata),
        JSON.stringify(schemaFields.staff_assigned),
        schemaFields.appointment_type,
      ]
    );

    // Transform response to match calendar component expectations
    const appointment = result.rows[0];
    const transformedAppointment = {
      id: appointment.id,
      title: appointment.title,
      startTime: appointment.scheduled_time,
      endTime: appointment.duration_minutes
        ? new Date(
            new Date(appointment.scheduled_time).getTime() +
              appointment.duration_minutes * 60000
          )
        : appointment.scheduled_time,
      address:
        appointment.metadata?.location || appointment.metadata?.address || "",
      appointmentStatus: appointment.status,
      staff: appointment.staff_assigned || [],
      tags: appointment.metadata?.tags || [],
      color: appointment.metadata?.color || "#51484f",
      dateAdded: appointment.created_at,
      contacts: requestData.contacts || [],
      details: appointment.description || "",
      meetLink: appointment.metadata?.meetLink || "",
      appointmentType: appointment.appointment_type,
      ...appointment.metadata, // Include all metadata fields in response
    };

    res.json(transformedAppointment);
  } catch (error) {
    console.error("Error creating appointment:", error);
    res
      .status(500)
      .json({ error: "Failed to create appointment", details: error.message });
  }
});

// Update appointment
app.put("/api/appointments/:id", async (req, res) => {
  try {
    const { id } = req.params;
    // Accept all fields from request body
    const requestData = { ...req.body };
    console.log("Received appointment update request data:", requestData);

    // Extract userEmail for authentication
    const email = requestData.userEmail || requestData.email;
    if (!email) {
      return res
        .status(400)
        .json({ error: "userEmail or email is required for authentication" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Get existing appointment to merge metadata
    const existingAppointment = await sqlDb.getRow(
      "SELECT * FROM appointments WHERE id = $1 AND company_id = $2",
      [id, user.company_id]
    );

    if (!existingAppointment) {
      return res.status(404).json({ error: "Appointment not found" });
    }

    // Define schema fields that map directly to database columns
    const updateFields = {};

    // Map common frontend field names to schema fields
    const fieldMappings = {
      startTime: "scheduled_time",
      start_time: "scheduled_time",
      endTime: null, // Will be used to calculate duration_minutes
      end_time: null, // Will be used to calculate duration_minutes
      details: "description",
      description: "description",
      appointmentStatus: "status",
      appointmentType: "appointment_type",
      staff: "staff_assigned",
      contacts: "contact_id", // Special handling needed
    };

    // Process each field from request
    const metadataFields = { ...(existingAppointment.metadata || {}) };
    let endTime = null;

    for (const [key, value] of Object.entries(requestData)) {
      if (key === "userEmail" || key === "email") continue; // Skip auth fields

      // Check if field has a direct mapping
      if (fieldMappings.hasOwnProperty(key)) {
        const mappedField = fieldMappings[key];
        if (mappedField) {
          updateFields[mappedField] = value;
        }
        // Store endTime for duration calculation
        if (key === "endTime" || key === "end_time") {
          endTime = value;
        }
      }
      // Check if field exists directly in schema
      else if (
        [
          "appointment_id",
          "contact_id",
          "title",
          "description",
          "scheduled_time",
          "duration_minutes",
          "status",
          "staff_assigned",
          "appointment_type",
        ].includes(key)
      ) {
        updateFields[key] = value;
      }
      // Everything else goes to metadata
      else {
        metadataFields[key] = value;
      }
    }

    // Handle contacts field - extract contact_id
    if (requestData.contacts) {
      if (
        Array.isArray(requestData.contacts) &&
        requestData.contacts.length > 0
      ) {
        updateFields.contact_id =
          requestData.contacts[0].id || requestData.contacts[0].contact_id;
      } else if (typeof requestData.contacts === "string") {
        updateFields.contact_id = requestData.contacts;
      } else {
        updateFields.contact_id = null;
      }
    }

    // Calculate duration if we have start time and end time
    if (
      (updateFields.scheduled_time || existingAppointment.scheduled_time) &&
      endTime
    ) {
      const startDate = new Date(
        updateFields.scheduled_time || existingAppointment.scheduled_time
      );
      const endDate = new Date(endTime);
      updateFields.duration_minutes = Math.round(
        (endDate.getTime() - startDate.getTime()) / (1000 * 60)
      );
    }

    // Handle staff_assigned as JSON
    if (
      updateFields.staff_assigned &&
      !Array.isArray(updateFields.staff_assigned)
    ) {
      updateFields.staff_assigned = [updateFields.staff_assigned];
    }

    // Ensure contact_id is null if empty
    if (updateFields.contact_id !== undefined) {
      updateFields.contact_id =
        updateFields.contact_id && String(updateFields.contact_id).trim() !== ""
          ? updateFields.contact_id
          : null;
    }

    // Always update metadata with merged fields
    updateFields.metadata = metadataFields;

    // Build the update query dynamically
    const updateFieldsArray = [];
    const updateValues = [];
    let paramIndex = 1;

    for (const [field, value] of Object.entries(updateFields)) {
      updateFieldsArray.push(`${field} = $${paramIndex++}`);
      if (field === "metadata" || field === "staff_assigned") {
        updateValues.push(JSON.stringify(value));
      } else {
        updateValues.push(value);
      }
    }

    if (updateFieldsArray.length === 0) {
      return res.status(400).json({ error: "No fields to update" });
    }

    updateValues.push(id, user.company_id);

    console.log("Updating appointment with fields:", Object.keys(updateFields));

    const result = await sqlDb.query(
      `
      UPDATE appointments SET
        ${updateFieldsArray.join(", ")}
      WHERE id = $${paramIndex++} AND company_id = $${paramIndex++}
      RETURNING *
    `,
      updateValues
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Appointment not found" });
    }

    // Transform response to match calendar component expectations
    const appointment = result.rows[0];
    const transformedAppointment = {
      id: appointment.id,
      title: appointment.title,
      startTime: appointment.scheduled_time,
      endTime: appointment.duration_minutes
        ? new Date(
            new Date(appointment.scheduled_time).getTime() +
              appointment.duration_minutes * 60000
          )
        : appointment.scheduled_time,
      address:
        appointment.metadata?.location || appointment.metadata?.address || "",
      appointmentStatus: appointment.status,
      staff: appointment.staff_assigned || [],
      tags: appointment.metadata?.tags || [],
      color: appointment.metadata?.color || "#51484f",
      dateAdded: appointment.created_at,
      contacts: requestData.contacts || [],
      details: appointment.description || "",
      meetLink: appointment.metadata?.meetLink || "",
      appointmentType: appointment.appointment_type,
      ...appointment.metadata, // Include all metadata fields in response
    };

    res.json(transformedAppointment);
  } catch (error) {
    console.error("Error updating appointment:", error);
    res
      .status(500)
      .json({ error: "Failed to update appointment", details: error.message });
  }
});

// Get specific appointment
app.get("/api/appointments/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { email } = req.query;

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const appointment = await sqlDb.getRow(
      `
      SELECT 
        a.*,
        c.name as contact_name, 
        c.phone as contact_phone,
        c.email as contact_email,
        c.contact_id
      FROM appointments a
      LEFT JOIN contacts c ON a.contact_id = c.contact_id AND a.company_id = c.company_id
      WHERE a.id = $1 AND a.company_id = $2
    `,
      [id, user.company_id]
    );

    if (!appointment) {
      return res.status(404).json({ error: "Appointment not found" });
    }

    // Transform response to match calendar component expectations
    const transformedAppointment = {
      id: appointment.id,
      title: appointment.title,
      startTime: appointment.scheduled_time,
      endTime: new Date(
        new Date(appointment.scheduled_time).getTime() +
          appointment.duration_minutes * 60000
      ),
      address: appointment.metadata?.location || "",
      appointmentStatus: appointment.status,
      staff: appointment.staff_assigned || [],
      tags: appointment.metadata?.tags || [],
      color: "#51484f",
      dateAdded: appointment.created_at,
      contacts: appointment.contact_id
        ? [
            {
              id: appointment.contact_id,
              name: appointment.contact_name || "Unknown",
              phone: appointment.contact_phone || "",
              email: appointment.contact_email || "",
            },
          ]
        : [],
      details: appointment.description || "",
      meetLink: "",
    };

    res.json(transformedAppointment);
  } catch (error) {
    console.error("Error fetching appointment:", error);
    res.status(500).json({ error: "Failed to fetch appointment" });
  }
});

// Delete appointment
app.delete("/api/appointments/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const result = await sqlDb.query(
      "DELETE FROM appointments WHERE id = $1 AND company_id = $2 RETURNING appointment_id",
      [id, user.company_id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Appointment not found" });
    }

    res.json({ success: true, message: "Appointment deleted successfully" });
  } catch (error) {
    console.error("Error deleting appointment:", error);
    res.status(500).json({ error: "Failed to delete appointment" });
  }
});

// Get calendar configuration
app.get("/api/calendar-config", async (req, res) => {
  try {
    const { email } = req.query;
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Get calendar config from settings table
    const settingsResult = await sqlDb.getRow(
      "SELECT setting_value FROM settings WHERE company_id = $1 AND setting_type = 'config' AND setting_key = 'calendar'",
      [user.company_id]
    );

    let calendarConfig = {
      calendarId: "",
      additionalCalendarIds: [],
      startHour: 11,
      endHour: 21,
      slotDuration: 30,
      daysAhead: 3,
    };

    if (settingsResult && settingsResult.setting_value) {
      // Parse the existing config or use defaults
      const existingConfig =
        typeof settingsResult.setting_value === "string"
          ? JSON.parse(settingsResult.setting_value)
          : settingsResult.setting_value;

      calendarConfig = { ...calendarConfig, ...existingConfig };
    }

    res.json({
      company_id: user.company_id,
      ...calendarConfig,
    });
  } catch (error) {
    console.error("Error fetching calendar config:", error);
    res.status(500).json({ error: "Failed to fetch calendar config" });
  }
});

// Update calendar configuration
app.put("/api/calendar-config", async (req, res) => {
  try {
    const {
      email,
      config: {
        calendarId,
        additionalCalendarIds,
        startHour,
        endHour,
        slotDuration,
        daysAhead,
      },
    } = req.body;
    console.log("Updating calendar config with:", req.body);
    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const calendarConfig = {
      calendarId: calendarId || "",
      additionalCalendarIds: additionalCalendarIds || [],
      startHour: startHour || 11,
      endHour: endHour || 21,
      slotDuration: slotDuration || 30,
      daysAhead: daysAhead || 3,
    };
    console.log("Updating calendar config with:", calendarConfig);

    // Check if setting exists
    const existingSetting = await sqlDb.getRow(
      "SELECT id FROM settings WHERE company_id = $1 AND setting_type = 'config' AND setting_key = 'calendar'",
      [user.company_id]
    );

    if (existingSetting) {
      // Update existing setting
      await sqlDb.query(
        "UPDATE settings SET setting_value = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
        [JSON.stringify(calendarConfig), existingSetting.id]
      );
    } else {
      // Insert new setting
      await sqlDb.query(
        "INSERT INTO settings (company_id, setting_type, setting_key, setting_value, created_at, updated_at) VALUES ($1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)",
        [user.company_id, "config", "calendar", JSON.stringify(calendarConfig)]
      );
    }

    res.json({
      company_id: user.company_id,
      ...calendarConfig,
    });
  } catch (error) {
    console.error("Error updating calendar config:", error);
    res.status(500).json({ error: "Failed to update calendar config" });
  }
});

// Create expense
app.post("/api/expenses", async (req, res) => {
  try {
    const { email, appointment_id, amount, description, category, date } =
      req.body;

    if (!email || !appointment_id || !amount) {
      return res
        .status(400)
        .json({ error: "Email, appointment_id, and amount are required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const result = await sqlDb.query(
      `
      INSERT INTO expenses (
        company_id, appointment_id, amount, description, category, date, created_at
      )
      VALUES ($1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP)
      RETURNING *
    `,
      [user.company_id, appointment_id, amount, description, category, date]
    );

    res.json(result.rows[0]);
  } catch (error) {
    console.error("Error creating expense:", error);
    res.status(500).json({ error: "Failed to create expense" });
  }
});

// ======================
// GOOGLE CALENDAR INTEGRATION
// ======================

// Initialize Google Calendar API with service account auth
let googleCalendarAuth = null;

// Initialize Google Calendar Authentication
async function initializeGoogleCalendarAuth() {
  try {
    // Check if service_account.json exists (same pattern as existing code)
    const fs = require("fs");
    if (!fs.existsSync("./service_account.json")) {
      console.warn(
        "Google Calendar credentials not configured - service_account.json not found"
      );
      return null;
    }

    const auth = new google.auth.GoogleAuth({
      keyFile: "./service_account.json",
      scopes: [
        "https://www.googleapis.com/auth/calendar.readonly",
        "https://www.googleapis.com/auth/calendar",
      ],
    });

    googleCalendarAuth = await auth.getClient();
    console.log("Google Calendar authentication initialized successfully");
    return googleCalendarAuth;
  } catch (error) {
    console.error("Failed to initialize Google Calendar auth:", error);
    return null;
  }
}

// Initialize Google Calendar auth on startup
initializeGoogleCalendarAuth();

// Cache for calendar events (5 minute cache)
const calendarCache = new Map();
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes in milliseconds

// Helper function to get cache key
function getCacheKey(email, timeMin, timeMax, calendarId) {
  return `${email}_${calendarId}_${timeMin}_${timeMax}`;
}

// Helper function to validate and get user
async function validateUserForCalendar(email) {
  try {
    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    return user;
  } catch (error) {
    console.error("Error validating user:", error);
    return null;
  }
}

// GET /api/google-calendar/events - Fetch events from Google Calendar
app.get("/api/google-calendar/events", async (req, res) => {
  try {
    const { email, timeMin, timeMax, calendarId = "primary" } = req.query;

    // Validate required parameters
    if (!email || !timeMin || !timeMax) {
      return res.status(400).json({
        success: false,
        events: [],
        error: "email, timeMin, and timeMax are required parameters",
      });
    }

    // Validate user access
    const user = await validateUserForCalendar(email);
    if (!user) {
      return res.status(401).json({
        success: false,
        events: [],
        error: "Unauthorized: User not found",
      });
    }

    // Check if Google Calendar auth is available
    if (!googleCalendarAuth) {
      console.warn(
        "Google Calendar not configured, attempting to initialize..."
      );
      const auth = await initializeGoogleCalendarAuth();
      if (!auth) {
        return res.status(503).json({
          success: false,
          events: [],
          error: "Google Calendar integration not configured",
        });
      }
    }

    // Check cache first
    const cacheKey = getCacheKey(email, timeMin, timeMax, calendarId);
    const cachedData = calendarCache.get(cacheKey);

    if (cachedData && Date.now() - cachedData.timestamp < CACHE_DURATION) {
      console.log("Returning cached calendar events for:", email);
      return res.json({
        success: true,
        events: cachedData.events,
        cached: true,
      });
    }

    // Initialize Google Calendar API
    const calendar = google.calendar({
      version: "v3",
      auth: googleCalendarAuth,
    });

    console.log(
      `Fetching Google Calendar events for ${email} from ${timeMin} to ${timeMax}`
    );

    // Fetch events from Google Calendar
    const response = await calendar.events.list({
      calendarId: calendarId,
      timeMin: timeMin,
      timeMax: timeMax,
      singleEvents: true,
      orderBy: "startTime",
      timeZone: "Asia/Kuala_Lumpur",
      maxResults: 250, // Reasonable limit to prevent huge responses
    });

    // Transform events to match expected format
    const events =
      response.data.items?.map((event) => {
        // Handle all-day events vs timed events
        const isAllDay = !event.start?.dateTime && event.start?.date;

        let startDateTime, endDateTime;

        if (isAllDay) {
          // For all-day events, convert date to dateTime at start of day in Malaysia timezone
          const startDate = new Date(event.start.date + "T00:00:00+08:00");
          const endDate = new Date(event.end.date + "T00:00:00+08:00");

          startDateTime = startDate.toISOString();
          endDateTime = endDate.toISOString();
        } else {
          // For timed events, use the existing dateTime
          startDateTime = event.start?.dateTime || null;
          endDateTime = event.end?.dateTime || null;
        }

        return {
          summary: event.summary || "Busy",
          start: {
            dateTime: startDateTime,
            date: event.start?.date || null,
          },
          end: {
            dateTime: endDateTime,
            date: event.end?.date || null,
          },
          id: event.id,
          status: event.status,
          transparency: event.transparency, // 'transparent' means the event doesn't block time
          isAllDay: isAllDay, // Add flag to indicate if this is an all-day event
        };
      }) || [];

    // Filter out cancelled events and transparent events (they don't block time)
    const filteredEvents = events.filter(
      (event) =>
        event.status !== "cancelled" && event.transparency !== "transparent"
    );

    // Cache the results
    calendarCache.set(cacheKey, {
      events: filteredEvents,
      timestamp: Date.now(),
    });

    // Clean up old cache entries (optional - prevents memory leaks)
    if (calendarCache.size > 1000) {
      const now = Date.now();
      for (const [key, value] of calendarCache.entries()) {
        if (now - value.timestamp > CACHE_DURATION) {
          calendarCache.delete(key);
        }
      }
    }

    console.log(`Found ${filteredEvents.length} calendar events for ${email}`);

    res.json({
      success: true,
      events: filteredEvents,
    });
  } catch (error) {
    console.error("Google Calendar API error:", error);

    // Determine error type and provide appropriate response
    let errorMessage = "Failed to fetch calendar events";
    let statusCode = 500;

    if (error.code === 404) {
      errorMessage = "Calendar not found or access denied";
      statusCode = 404;
    } else if (error.code === 403) {
      errorMessage = "Insufficient permissions to access calendar";
      statusCode = 403;
    } else if (error.code === 429) {
      errorMessage = "Rate limit exceeded, please try again later";
      statusCode = 429;
    } else if (error.message?.includes("invalid_grant")) {
      errorMessage = "Google Calendar authentication failed";
      statusCode = 401;
    }

    res.status(statusCode).json({
      success: false,
      events: [],
      error: errorMessage,
    });
  }
});

// POST /api/google-calendar/create-event - Create a new event in Google Calendar
app.post("/api/google-calendar/create-event", async (req, res) => {
  try {
    const { event, calendarId = "primary", userEmail } = req.body;

    // Use the provided calendarId or default to the specific calendar
    const actualCalendarId = "thealistmalaysia@gmail.com";

    // Validate required parameters
    if (!event || !event.summary || !event.start || !event.end) {
      return res.status(400).json({
        success: false,
        error: "event with summary, start, and end times are required",
      });
    }

    // Validate user access if userEmail is provided
    if (userEmail) {
      const user = await validateUserForCalendar(userEmail);
      if (!user) {
        return res.status(401).json({
          success: false,
          error: "Unauthorized: User not found",
        });
      }
    }

    // Check if Google Calendar auth is available
    if (!googleCalendarAuth) {
      console.warn(
        "Google Calendar not configured, attempting to initialize..."
      );
      const auth = await initializeGoogleCalendarAuth();
      if (!auth) {
        return res.status(503).json({
          success: false,
          error: "Google Calendar integration not configured",
        });
      }
    }

    // Initialize Google Calendar API with write permissions and conference data creation
    const auth = new google.auth.GoogleAuth({
      keyFile: "./service_account.json",
      scopes: [
        "https://www.googleapis.com/auth/calendar",
        "https://www.googleapis.com/auth/calendar.events",
      ],
    });

    const calendar = google.calendar({
      version: "v3",
      auth: auth,
    });

    console.log(
      `Creating Google Calendar event: ${event.summary} on ${actualCalendarId}`
    );
    console.log(
      "Service account email:",
      "crm-643@onboarding-a5fcb.iam.gserviceaccount.com"
    );
    console.log("Event details:", JSON.stringify(event, null, 2));

    // Check calendar conference settings first
    try {
      const calendarInfo = await calendar.calendars.get({
        calendarId: actualCalendarId,
      });
      console.log(
        "Calendar conference properties:",
        calendarInfo.data.conferenceProperties
      );

      const allowedTypes =
        calendarInfo.data.conferenceProperties
          ?.allowedConferenceSolutionTypes || [];
      console.log("Allowed conference solution types:", allowedTypes);

      if (!allowedTypes.includes("hangoutsMeet")) {
        console.warn(
          "WARNING: hangoutsMeet is not in allowed conference solution types for this calendar"
        );
        console.log("Available types:", allowedTypes);
      }
    } catch (calError) {
      console.warn(
        "Could not check calendar conference properties:",
        calError.message
      );
    }

    // Process event data - title comes pre-formatted from frontend
    const eventForCalendar = { ...event };

    console.log(`Event title: "${event.summary}"`);

    // Service accounts cannot invite attendees without Domain-Wide Delegation
    // So we'll add attendee info to the description instead
    if (event.attendees && event.attendees.length > 0) {
      const attendeeInfo = event.attendees
        .map((attendee) => `${attendee.displayName || ""} (${attendee.email})`)
        .join(", ");

      eventForCalendar.description = `${
        event.description || ""
      }\n\nGuest: ${attendeeInfo}`.trim();
      console.log("Adding attendee info to description:", attendeeInfo);

      // Remove attendees from the event to avoid permission errors
      delete eventForCalendar.attendees;
    }

    // Try to create event with Google Meet, fallback gracefully if it fails
    let response;
    let meetLinkCreated = false;
    let manualMeetLink = null;

    // First, try creating event with Google Meet
    if (eventForCalendar.conferenceData) {
      try {
        // Ensure correct conference data format for Google Meet
        eventForCalendar.conferenceData = {
          createRequest: {
            requestId: `booking-${Date.now()}`,
            conferenceSolutionKey: {
              type: "hangoutsMeet",
            },
          },
        };

        console.log("Attempting to create event with Google Meet...");
        console.log(
          "Conference data:",
          JSON.stringify(eventForCalendar.conferenceData, null, 2)
        );

        const insertParamsWithMeet = {
          calendarId: actualCalendarId,
          resource: eventForCalendar,
          conferenceDataVersion: 1,
          sendUpdates: "all",
        };

        response = await calendar.events.insert(insertParamsWithMeet);
        meetLinkCreated = true;
        console.log("Successfully created event with Google Meet");
      } catch (meetError) {
        console.log("Google Meet creation failed:", meetError);
        console.log("Error details:", meetError.message);
        console.log("Error code:", meetError.code);

        // Try alternative conference solution approach
        try {
          console.log("Trying alternative Google Meet creation method...");

          // Reset conference data with different approach
          eventForCalendar.conferenceData = {
            createRequest: {
              requestId: `booking-alt-${Date.now()}`,
              conferenceSolutionKey: {
                type: "hangoutsMeet",
              },
            },
          };

          const insertParamsAlt = {
            calendarId: actualCalendarId,
            resource: eventForCalendar,
            conferenceDataVersion: 1,
          };

          response = await calendar.events.insert(insertParamsAlt);
          meetLinkCreated = true;
          console.log(
            "Successfully created event with Google Meet (alternative method)"
          );
        } catch (altError) {
          console.log(
            "Alternative Google Meet creation also failed, falling back to event without Meet:",
            altError.message
          );

          // Remove conference data and try again
          delete eventForCalendar.conferenceData;

          const insertParamsWithoutMeet = {
            calendarId: actualCalendarId,
            resource: eventForCalendar,
          };

          // Add manual Google Meet link to description as fallback
          manualMeetLink = `https://meet.google.com/new`;
          eventForCalendar.description = `${
            eventForCalendar.description || ""
          }\n\n🎥 Google Meet: ${manualMeetLink}\n(Click to create a new meeting room)`.trim();

          response = await calendar.events.insert(insertParamsWithoutMeet);
          console.log("Successfully created event without Google Meet");
          console.log(
            "Added manual Google Meet link to description:",
            manualMeetLink
          );
        }
      }
    } else {
      // No conference data requested, create simple event
      const insertParams = {
        calendarId: actualCalendarId,
        resource: eventForCalendar,
      };

      response = await calendar.events.insert(insertParams);
    }

    const createdEvent = response.data;

    console.log(
      `Successfully created Google Calendar event with ID: ${createdEvent.id}`
    );
    console.log(`Event created in calendar: ${actualCalendarId}`);
    console.log(`Event HTML Link: ${createdEvent.htmlLink}`);
    console.log(`Google Meet link created: ${meetLinkCreated}`);
    if (createdEvent.hangoutLink) {
      console.log(`Google Meet link: ${createdEvent.hangoutLink}`);
    }

    res.json({
      success: true,
      meetLinkCreated: meetLinkCreated,
      manualMeetLink: manualMeetLink,
      event: {
        id: createdEvent.id,
        htmlLink: createdEvent.htmlLink,
        hangoutLink: createdEvent.hangoutLink || manualMeetLink,
        status: createdEvent.status,
        created: createdEvent.created,
        summary: createdEvent.summary,
        start: createdEvent.start,
        end: createdEvent.end,
        attendees: createdEvent.attendees,
        conferenceData: createdEvent.conferenceData,
      },
    });
  } catch (error) {
    console.error("Google Calendar create event error:", error);

    // Determine error type and provide appropriate response
    let errorMessage = "Failed to create calendar event";
    let statusCode = 500;

    if (error.code === 404) {
      errorMessage = "Calendar not found or access denied";
      statusCode = 404;
    } else if (error.code === 403) {
      errorMessage = "Insufficient permissions to create events in calendar";
      statusCode = 403;
    } else if (error.code === 429) {
      errorMessage = "Rate limit exceeded, please try again later";
      statusCode = 429;
    } else if (error.message?.includes("invalid_grant")) {
      errorMessage = "Google Calendar authentication failed";
      statusCode = 401;
    } else if (error.message?.includes("Invalid conference type")) {
      errorMessage = "Failed to create Google Meet conference";
      statusCode = 400;
    }

    res.status(statusCode).json({
      success: false,
      error: errorMessage,
    });
  }
});
// ============================================
// USER & COMPANY ANALYTICS API
// ============================================

// GET /api/users/analytics - Get comprehensive user and company analytics
app.get("/api/users/analytics", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Check if tables exist and get users
      let users = [];
      try {
        const usersQuery = `
          SELECT 
            u.email,
            u.name,
            u.role,
            u.active,
            u.company_id,
            u.created_at,
            c.name as company_name,
            c.phone as company_phone,
            c.email as company_email
          FROM users u
          LEFT JOIN companies c ON u.company_id = c.company_id
          WHERE u.active = true
          ORDER BY u.created_at DESC
        `;

        const usersResult = await client.query(usersQuery);
        users = usersResult.rows;
      } catch (error) {
        console.log("Users table might not exist, using mock data");
        // Provide mock data if table doesn't exist
        users = [
          {
            email: "admin@example.com",
            name: "Admin User",
            role: "admin",
            active: true,
            company_id: "001",
            created_at: new Date(),
            company_name: "Example Company",
            company_phone: "+1234567890",
            company_email: "contact@example.com",
          },
          {
            email: "user@example.com",
            name: "Test User",
            role: "user",
            active: true,
            company_id: "002",
            created_at: new Date(Date.now() - 86400000), // 1 day ago
            company_name: "Test Company",
            company_phone: "+0987654321",
            company_email: "test@example.com",
          },
        ];
      }

      // Get contact counts for each user's company
      const contactCounts = {};
      try {
        const contactCountsQuery = `
          SELECT 
            company_id,
            COUNT(*) as contact_count
          FROM contacts 
          GROUP BY company_id
        `;

        const contactCountsResult = await client.query(contactCountsQuery);
        contactCountsResult.rows.forEach((row) => {
          contactCounts[row.company_id] = parseInt(row.contact_count);
        });
      } catch (error) {
        console.log("Contacts table might not exist, using mock data");
        // Mock contact counts
        contactCounts["001"] = 150;
        contactCounts["002"] = 75;
      }

      // Get AI response usage for each company
      const aiUsage = {};
      try {
        // First try to get AI-specific usage
        const aiUsageQuery = `
        SELECT
          company_id,
          SUM(usage_count) as total_ai_responses
        FROM usage_logs
        WHERE feature = 'aiMessages' OR feature = 'ai_response' OR feature LIKE '%ai%' OR feature LIKE '%response%'
        GROUP BY company_id
      `;

        const aiUsageResult = await client.query(aiUsageQuery);
        console.log("AI Usage Query Result:", aiUsageResult.rows);
        aiUsageResult.rows.forEach((row) => {
          aiUsage[row.company_id] = parseInt(row.total_ai_responses) || 0;
        });

        // If no AI usage found, try a broader query for any usage
        if (Object.keys(aiUsage).length === 0) {
          console.log("No AI usage found, trying broader query...");
          const broaderQuery = `
            SELECT 
              company_id,
              SUM(usage_count) as total_usage
            FROM usage_logs 
            GROUP BY company_id
          `;

          const broaderResult = await client.query(broaderQuery);
          console.log("Broader Usage Query Result:", broaderResult.rows);
          broaderResult.rows.forEach((row) => {
            aiUsage[row.company_id] = parseInt(row.total_usage) || 0;
          });
        }
      } catch (error) {
        console.log("Usage logs table error:", error.message);
        // Mock AI usage data
        aiUsage["001"] = 250;
        aiUsage["002"] = 120;
        aiUsage["003"] = 180;
      }

      // Get phone status information
      const phoneStatus = {};
      try {
        const phoneStatusQuery = `
          SELECT 
            company_id,
            phone_index,
            status,
            updated_at
          FROM phone_status 
          ORDER BY company_id, phone_index
        `;

        const phoneStatusResult = await client.query(phoneStatusQuery);
        phoneStatusResult.rows.forEach((row) => {
          if (!phoneStatus[row.company_id]) {
            phoneStatus[row.company_id] = [];
          }
          phoneStatus[row.company_id].push({
            phoneIndex: row.phone_index,
            status: row.status,
            updatedAt: row.updated_at,
          });
        });
      } catch (error) {
        console.log("Phone status table might not exist, using mock data");
        // Mock phone status data
        phoneStatus["001"] = [
          { phoneIndex: 0, status: "active", updatedAt: new Date() },
        ];
        phoneStatus["002"] = [
          { phoneIndex: 0, status: "pending", updatedAt: new Date() },
        ];
      }

      // Combine all data
      const enrichedUsers = users.map((user) => {
        const contactCount = contactCounts[user.company_id] || 0;
        const aiResponseCount = aiUsage[user.company_id] || 0;
        const phoneStatuses = phoneStatus[user.company_id] || [];

        // Determine overall phone status
        let overallPhoneStatus = "unknown";
        if (phoneStatuses.length > 0) {
          const activePhones = phoneStatuses.filter(
            (p) => p.status === "active"
          );
          if (activePhones.length > 0) {
            overallPhoneStatus = "active";
          } else if (phoneStatuses.some((p) => p.status === "pending")) {
            overallPhoneStatus = "pending";
          } else {
            overallPhoneStatus = "inactive";
          }
        }

        return {
          email: user.email,
          name: user.name || user.email?.split("@")[0] || "Unknown User",
          role: user.role,
          active: user.active,
          companyId: user.company_id,
          companyName: user.company_name,
          companyPhone: user.company_phone,
          companyEmail: user.company_email,
          createdAt: user.created_at,
          contactCount: contactCount,
          aiResponseCount: aiResponseCount,
          phoneStatus: overallPhoneStatus,
          phoneStatuses: phoneStatuses,
        };
      });

      // Calculate statistics
      const totalUsers = users.length;
      const totalCompanies = new Set(users.map((u) => u.company_id)).size;
      const activeUsers = users.filter((u) => u.active).length;
      const totalContacts = Object.values(contactCounts).reduce(
        (sum, count) => sum + count,
        0
      );
      const totalAIResponses = Object.values(aiUsage).reduce(
        (sum, count) => sum + count,
        0
      );
      const avgContactsPerUser =
        totalUsers > 0 ? Math.round(totalContacts / totalUsers) : 0;

      res.json({
        success: true,
        users: enrichedUsers,
        stats: {
          totalUsers,
          totalCompanies,
          activeUsers,
          totalContacts,
          totalAIResponses,
          avgContactsPerUser,
        },
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching user analytics:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch user analytics",
    });
  }
});

// GET /api/users/analytics/company/:companyId - Get detailed analytics for a specific company
app.get("/api/users/analytics/company/:companyId", async (req, res) => {
  try {
    const { companyId } = req.params;
    const client = await pool.connect();

    try {
      // Get company details
      const companyQuery = `
        SELECT 
          company_id,
          name as company_name,
          email as company_email,
          phone as company_phone,
          created_at
        FROM companies 
        WHERE company_id = $1
      `;

      const companyResult = await client.query(companyQuery, [companyId]);
      const company = companyResult.rows[0];

      if (!company) {
        return res.status(404).json({
          success: false,
          error: "Company not found",
        });
      }

      // Get users for this company
      const usersQuery = `
        SELECT 
          email,
          name,
          role,
          active,
          created_at
        FROM users 
        WHERE company_id = $1 AND active = true
        ORDER BY created_at DESC
      `;

      const usersResult = await client.query(usersQuery, [companyId]);
      const users = usersResult.rows;

      // Get contact count
      const contactCountQuery = `
        SELECT COUNT(*) as contact_count
        FROM contacts 
        WHERE company_id = $1
      `;

      const contactCountResult = await client.query(contactCountQuery, [
        companyId,
      ]);
      const contactCount = parseInt(contactCountResult.rows[0].contact_count);

      // Get AI response usage
      const aiUsageQuery = `
        SELECT 
          SUM(usage_count) as total_ai_responses,
          COUNT(*) as usage_days
        FROM usage_logs 
        WHERE company_id = $1 AND feature = 'ai_response'
      `;

      const aiUsageResult = await client.query(aiUsageQuery, [companyId]);
      const aiUsage = aiUsageResult.rows[0];

      // Get phone status
      const phoneStatusQuery = `
        SELECT 
          phone_index,
          status,
          details,
          updated_at
        FROM phone_status 
        WHERE company_id = $1
        ORDER BY phone_index
      `;

      const phoneStatusResult = await client.query(phoneStatusQuery, [
        companyId,
      ]);
      const phoneStatuses = phoneStatusResult.rows;

      // Get recent activity (last 30 days)
      const recentActivityQuery = `
        SELECT 
          feature,
          date,
          usage_count
        FROM usage_logs 
        WHERE company_id = $1 
        AND date >= NOW() - INTERVAL '30 days'
        ORDER BY date DESC
      `;

      const recentActivityResult = await client.query(recentActivityQuery, [
        companyId,
      ]);
      const recentActivity = recentActivityResult.rows;

      res.json({
        success: true,
        company: {
          ...company,
          users: users,
          contactCount: contactCount,
          aiResponseCount: parseInt(aiUsage.total_ai_responses) || 0,
          usageDays: parseInt(aiUsage.usage_days) || 0,
          phoneStatuses: phoneStatuses,
          recentActivity: recentActivity,
        },
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching company analytics:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch company analytics",
    });
  }
});

// GET /api/users - Get all users
app.get("/api/users", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      let users = [];
      try {
        const usersQuery = `
          SELECT 
            u.email,
            u.name,
            u.role,
            u.active,
            u.company_id,
            u.created_at,
            c.name as company_name,
            c.phone as company_phone,
            c.email as company_email
          FROM users u
          LEFT JOIN companies c ON u.company_id = c.company_id
          WHERE u.active = true
          ORDER BY u.created_at DESC
        `;

        const usersResult = await client.query(usersQuery);
        users = usersResult.rows;
      } catch (error) {
        console.log("Users table might not exist, using mock data");
        // Provide mock data if table doesn't exist
        users = [
          {
            email: "admin@example.com",
            name: "Admin User",
            role: "admin",
            active: true,
            company_id: "001",
            created_at: new Date(),
            company_name: "Example Company",
            company_phone: "+1234567890",
            company_email: "contact@example.com",
          },
          {
            email: "user@example.com",
            name: "Test User",
            role: "user",
            active: true,
            company_id: "002",
            created_at: new Date(Date.now() - 86400000), // 1 day ago
            company_name: "Test Company",
            company_phone: "+0987654321",
            company_email: "test@example.com",
          },
          {
            email: "manager@example.com",
            name: "Manager User",
            role: "manager",
            active: true,
            company_id: "003",
            created_at: new Date(Date.now() - 172800000), // 2 days ago
            company_name: "Manager Corp",
            company_phone: "+1122334455",
            company_email: "manager@example.com",
          },
        ];
      }

      res.json({
        success: true,
        users: users,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch users",
    });
  }
});

// GET /api/companies - Get all companies
app.get("/api/companies", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      let companies = [];
      try {
        const companiesQuery = `
          SELECT 
            company_id,
            name,
            email,
            phone,
            status,
            enabled,
            created_at,
            api_url,
            plan
          FROM companies 
          ORDER BY created_at DESC
        `;

        const companiesResult = await client.query(companiesQuery);
        companies = companiesResult.rows;
      } catch (error) {
        console.log("Companies table might not exist, using mock data");
        // Provide mock data if table doesn't exist
        companies = [
          {
            company_id: "001",
            name: "Example Company",
            email: "contact@example.com",
            phone: "+1234567890",
            status: "active",
            enabled: true,
            created_at: new Date(),
          },
          {
            company_id: "002",
            name: "Test Company",
            email: "test@example.com",
            phone: "+0987654321",
            status: "active",
            enabled: true,
            created_at: new Date(Date.now() - 86400000), // 1 day ago
          },
          {
            company_id: "003",
            name: "Manager Corp",
            email: "manager@example.com",
            phone: "+1122334455",
            status: "active",
            enabled: true,
            created_at: new Date(Date.now() - 172800000), // 2 days ago
          },
        ];
      }

      res.json({
        success: true,
        companies: companies,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching companies:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch companies",
    });
  }
});

// ======================
// FINANCIAL DATA ENDPOINTS
// ======================

// GET /api/financial/monthly-data - Get all monthly financial data
app.get("/api/financial/monthly-data", async (req, res) => {
  try {
    const monthlyData = await sql`
      SELECT * FROM monthly_financial_data 
      ORDER BY year ASC, 
      CASE 
        WHEN UPPER(month) IN ('JANUARY', 'JAN') THEN 1
        WHEN UPPER(month) IN ('FEBRUARY', 'FEB') THEN 2
        WHEN UPPER(month) IN ('MARCH', 'MAR') THEN 3
        WHEN UPPER(month) IN ('APRIL', 'APR') THEN 4
        WHEN UPPER(month) = 'MAY' THEN 5
        WHEN UPPER(month) IN ('JUNE', 'JUN') THEN 6
        WHEN UPPER(month) IN ('JULY', 'JUL') THEN 7
        WHEN UPPER(month) IN ('AUGUST', 'AUG') THEN 8
        WHEN UPPER(month) IN ('SEPTEMBER', 'SEP') THEN 9
        WHEN UPPER(month) IN ('OCTOBER', 'OCT') THEN 10
        WHEN UPPER(month) IN ('NOVEMBER', 'NOV') THEN 11
        WHEN UPPER(month) IN ('DECEMBER', 'DEC') THEN 12
        ELSE 13
      END ASC
    `;

    res.json({
      success: true,
      data: monthlyData,
    });
  } catch (error) {
    console.error("Error fetching monthly financial data:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch monthly financial data",
    });
  }
});

// GET /api/financial/income-sources - Get income sources
app.get("/api/financial/income-sources", async (req, res) => {
  try {
    const { month, year } = req.query;

    let query = sql`SELECT * FROM income_sources`;

    if (month && year) {
      query = sql`SELECT * FROM income_sources WHERE month = ${month} AND year = ${parseInt(
        year
      )}`;
    } else if (year) {
      query = sql`SELECT * FROM income_sources WHERE year = ${parseInt(year)}`;
    }

    query = sql`${query} ORDER BY amount DESC`;

    const incomeSources = await query;

    res.json({
      success: true,
      data: incomeSources,
    });
  } catch (error) {
    console.error("Error fetching income sources:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch income sources",
    });
  }
});

// GET /api/financial/expense-categories - Get expense categories
app.get("/api/financial/expense-categories", async (req, res) => {
  try {
    const { month, year, category } = req.query;

    let query = sql`SELECT * FROM expense_categories`;

    if (month && year) {
      query = sql`SELECT * FROM expense_categories WHERE month = ${month} AND year = ${parseInt(
        year
      )}`;
    } else if (year) {
      query = sql`SELECT * FROM expense_categories WHERE year = ${parseInt(
        year
      )}`;
    }

    if (category) {
      query = sql`${query} AND category = ${category}`;
    }

    query = sql`${query} ORDER BY amount DESC`;

    const expenseCategories = await query;

    res.json({
      success: true,
      data: expenseCategories,
    });
  } catch (error) {
    console.error("Error fetching expense categories:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch expense categories",
    });
  }
});

// GET /api/financial/summary - Get financial summary
app.get("/api/financial/summary", async (req, res) => {
  try {
    const { year } = req.query;

    let query = sql`
      SELECT 
        SUM(total_income) as total_income,
        SUM(total_expenses) as total_expenses,
        SUM(net_budget) as net_budget,
        COUNT(*) as months_count
      FROM monthly_financial_data
    `;

    if (year) {
      query = sql`${query} WHERE year = ${parseInt(year)}`;
    }

    const summary = await query;

    // Get yearly breakdown
    const yearlyBreakdown = await sql`
      SELECT 
        year,
        SUM(total_income) as total_income,
        SUM(total_expenses) as total_expenses,
        SUM(net_budget) as net_budget,
        COUNT(*) as months_count
      FROM monthly_financial_data
      GROUP BY year
      ORDER BY year ASC
    `;

    res.json({
      success: true,
      summary: summary[0],
      yearlyBreakdown: yearlyBreakdown,
    });
  } catch (error) {
    console.error("Error fetching financial summary:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch financial summary",
    });
  }
});

// GET /api/financial/categories-summary - Get expense categories summary
app.get("/api/financial/categories-summary", async (req, res) => {
  try {
    const { year } = req.query;

    let query = sql`
      SELECT 
        category,
        SUM(amount) as total_amount,
        COUNT(*) as item_count
      FROM expense_categories
    `;

    if (year) {
      query = sql`${query} WHERE year = ${parseInt(year)}`;
    }

    query = sql`${query} GROUP BY category ORDER BY total_amount DESC`;

    const categoriesSummary = await query;

    res.json({
      success: true,
      data: categoriesSummary,
    });
  } catch (error) {
    console.error("Error fetching categories summary:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch categories summary",
    });
  }
});

// POST /api/financial/add-entry - Add new financial entry
app.post("/api/financial/add-entry", async (req, res) => {
  try {
    const { type, month, year, name, amount, category, description } = req.body;

    if (type === "income") {
      await sql`
        INSERT INTO income_sources (month, year, source_name, amount, description)
        VALUES (${month}, ${parseInt(year)}, ${name}, ${parseFloat(amount)}, ${
        description || ""
      })
      `;

      // Update monthly totals
      await sql`
        UPDATE monthly_financial_data 
        SET total_income = total_income + ${parseFloat(amount)},
            net_budget = net_budget + ${parseFloat(amount)},
            updated_at = CURRENT_TIMESTAMP
        WHERE month = ${month} AND year = ${parseInt(year)}
      `;
    } else if (type === "expense") {
      await sql`
        INSERT INTO expense_categories (month, year, category, item_name, amount, description)
        VALUES (${month}, ${parseInt(year)}, ${category}, ${name}, ${parseFloat(
        amount
      )}, ${description || ""})
      `;

      // Update monthly totals
      await sql`
        UPDATE monthly_financial_data 
        SET total_expenses = total_expenses + ${parseFloat(amount)},
            net_budget = net_budget - ${parseFloat(amount)},
            updated_at = CURRENT_TIMESTAMP
        WHERE month = ${month} AND year = ${parseInt(year)}
      `;
    }

    res.json({
      success: true,
      message: "Entry added successfully",
    });
  } catch (error) {
    console.error("Error adding financial entry:", error);
    res.status(500).json({
      success: false,
      error: "Failed to add financial entry",
    });
  }
});

// ============================================
// CLIENT ANALYTICS API ENDPOINTS
// ============================================

// GET /api/client-analytics - Get client analytics data
app.get("/api/client-analytics", async (req, res) => {
  try {
    const analytics = await sql`
      SELECT 
        company_id,
        total_paid,
        total_invoices,
        avg_payment_time,
        last_payment_date,
        retention_score,
        client_since,
        status,
        services,
        created_at,
        updated_at
      FROM client_analytics
      ORDER BY total_paid DESC
    `;

    res.json({
      success: true,
      data: analytics,
    });
  } catch (error) {
    console.error("Error fetching client analytics:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch client analytics",
    });
  }
});

// GET /api/client-invoices - Get all client invoices
app.get("/api/client-invoices", async (req, res) => {
  try {
    const { status, company_id } = req.query;

    let query = sql`
      SELECT 
        id,
        invoice_id,
        company_id,
        client_name,
        amount,
        description,
        due_date,
        status,
        paid_date,
        service_type,
        invoice_number,
        created_date,
        created_at,
        updated_at
      FROM client_invoices
    `;

    const conditions = [];
    if (status) {
      conditions.push(sql`status = ${status}`);
    }
    if (company_id) {
      conditions.push(sql`company_id = ${company_id}`);
    }

    if (conditions.length > 0) {
      query = sql`
        SELECT 
          id,
          invoice_id,
          company_id,
          client_name,
          amount,
          description,
          due_date,
          status,
          paid_date,
          service_type,
          invoice_number,
          created_date,
          created_at,
          updated_at
        FROM client_invoices
        WHERE ${sql.join(conditions, sql` AND `)}
        ORDER BY created_at DESC
      `;
    } else {
      query = sql`
        SELECT 
          id,
          invoice_id,
          company_id,
          client_name,
          amount,
          description,
          due_date,
          status,
          paid_date,
          service_type,
          invoice_number,
          created_date,
          created_at,
          updated_at
        FROM client_invoices
        ORDER BY created_at DESC
      `;
    }

    const invoices = await query;

    res.json({
      success: true,
      data: invoices,
    });
  } catch (error) {
    console.error("Error fetching client invoices:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch client invoices",
    });
  }
});

// POST /api/client-invoices - Create new client invoice
app.post("/api/client-invoices", async (req, res) => {
  try {
    const {
      company_id,
      client_name,
      amount,
      description,
      due_date,
      service_type = "AI Bot Service",
    } = req.body;

    // Validate required fields
    if (!company_id || !client_name || !amount || !due_date) {
      return res.status(400).json({
        success: false,
        error:
          "Missing required fields: company_id, client_name, amount, due_date",
      });
    }

    // Generate unique invoice ID and number
    const invoiceId = uuidv4();
    const invoiceNumber = `INV-${new Date().getFullYear()}-${String(
      Date.now()
    ).slice(-6)}`;

    // Insert new invoice
    const result = await sql`
      INSERT INTO client_invoices (
        invoice_id,
        company_id,
        client_name,
        amount,
        description,
        due_date,
        service_type,
        invoice_number,
        status,
        created_date
      )
      VALUES (
        ${invoiceId},
        ${company_id},
        ${client_name},
        ${parseFloat(amount)},
        ${description || ""},
        ${due_date},
        ${service_type},
        ${invoiceNumber},
        'pending',
        CURRENT_DATE
      )
      RETURNING *
    `;

    res.json({
      success: true,
      data: result[0],
      message: "Invoice created successfully",
    });
  } catch (error) {
    console.error("Error creating client invoice:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create invoice",
    });
  }
});

// PUT /api/client-invoices/:id - Update client invoice
app.put("/api/client-invoices/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { status, paid_date, amount, description, due_date } = req.body;

    // Build update query dynamically
    const updates = [];
    const values = [];

    if (status !== undefined) {
      updates.push(sql`status = ${status}`);
    }
    if (paid_date !== undefined) {
      updates.push(sql`paid_date = ${paid_date}`);
    }
    if (amount !== undefined) {
      updates.push(sql`amount = ${parseFloat(amount)}`);
    }
    if (description !== undefined) {
      updates.push(sql`description = ${description}`);
    }
    if (due_date !== undefined) {
      updates.push(sql`due_date = ${due_date}`);
    }

    if (updates.length === 0) {
      return res.status(400).json({
        success: false,
        error: "No fields to update",
      });
    }

    // Add updated_at
    updates.push(sql`updated_at = CURRENT_TIMESTAMP`);

    const result = await sql`
      UPDATE client_invoices
      SET ${sql.join(updates, sql`, `)}
      WHERE invoice_id = ${id}
      RETURNING *
    `;

    if (result.length === 0) {
      return res.status(404).json({
        success: false,
        error: "Invoice not found",
      });
    }

    // If marking as paid, create payment record
    if (status === "paid" && paid_date) {
      const paymentId = uuidv4();
      await sql`
        INSERT INTO client_payments (
          payment_id,
          invoice_id,
          company_id,
          amount,
          payment_date,
          status
        )
        VALUES (
          ${paymentId},
          ${id},
          ${result[0].company_id},
          ${result[0].amount},
          ${paid_date},
          'completed'
        )
      `;
    }

    res.json({
      success: true,
      data: result[0],
      message: "Invoice updated successfully",
    });
  } catch (error) {
    console.error("Error updating client invoice:", error);
    res.status(500).json({
      success: false,
      error: "Failed to update invoice",
    });
  }
});

// GET /api/client-payments - Get client payment history
app.get("/api/client-payments", async (req, res) => {
  try {
    const { company_id, invoice_id } = req.query;

    let query = sql`
      SELECT 
        cp.id,
        cp.payment_id,
        cp.invoice_id,
        cp.company_id,
        cp.amount,
        cp.payment_date,
        cp.payment_method,
        cp.reference_number,
        cp.status,
        cp.created_at,
        ci.client_name,
        ci.invoice_number
      FROM client_payments cp
      LEFT JOIN client_invoices ci ON cp.invoice_id = ci.invoice_id
    `;

    const conditions = [];
    if (company_id) {
      conditions.push(sql`cp.company_id = ${company_id}`);
    }
    if (invoice_id) {
      conditions.push(sql`cp.invoice_id = ${invoice_id}`);
    }

    if (conditions.length > 0) {
      query = sql`
        SELECT 
          cp.id,
          cp.payment_id,
          cp.invoice_id,
          cp.company_id,
          cp.amount,
          cp.payment_date,
          cp.payment_method,
          cp.reference_number,
          cp.status,
          cp.created_at,
          ci.client_name,
          ci.invoice_number
        FROM client_payments cp
        LEFT JOIN client_invoices ci ON cp.invoice_id = ci.invoice_id
        WHERE ${sql.join(conditions, sql` AND `)}
        ORDER BY cp.payment_date DESC
      `;
    } else {
      query = sql`
        SELECT 
          cp.id,
          cp.payment_id,
          cp.invoice_id,
          cp.company_id,
          cp.amount,
          cp.payment_date,
          cp.payment_method,
          cp.reference_number,
          cp.status,
          cp.created_at,
          ci.client_name,
          ci.invoice_number
        FROM client_payments cp
        LEFT JOIN client_invoices ci ON cp.invoice_id = ci.invoice_id
        ORDER BY cp.payment_date DESC
      `;
    }

    const payments = await query;

    res.json({
      success: true,
      data: payments,
    });
  } catch (error) {
    console.error("Error fetching client payments:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch client payments",
    });
  }
});

// GET /api/client-analytics/summary - Get client analytics summary
app.get("/api/client-analytics/summary", async (req, res) => {
  try {
    const summary = await sql`
      SELECT 
        COUNT(*) as total_clients,
        SUM(total_paid) as total_revenue,
        AVG(total_paid) as avg_client_value,
        AVG(retention_score) as avg_retention_score,
        COUNT(CASE WHEN status = 'active' THEN 1 END) as active_clients,
        COUNT(CASE WHEN total_paid > 10000 THEN 1 END) as high_value_clients
      FROM client_analytics
    `;

    const recentPayments = await sql`
      SELECT 
        COUNT(*) as recent_payments,
        SUM(amount) as recent_revenue
      FROM client_payments
      WHERE payment_date >= CURRENT_DATE - INTERVAL '30 days'
    `;

    const pendingInvoices = await sql`
      SELECT 
        COUNT(*) as pending_count,
        SUM(amount) as pending_amount
      FROM client_invoices
      WHERE status = 'pending'
    `;

    res.json({
      success: true,
      data: {
        ...summary[0],
        ...recentPayments[0],
        ...pendingInvoices[0],
      },
    });
  } catch (error) {
    console.error("Error fetching client analytics summary:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch client analytics summary",
    });
  }
});
// GET /api/contacts - Get all contacts
app.get("/api/contacts", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Query real contacts from database
      const contactsQuery = `
        SELECT 
          id,
          name,
          phone,
          email,
          company_id,
          created_at,
          updated_at
        FROM contacts 
        ORDER BY created_at DESC
      `;

      const contactsResult = await client.query(contactsQuery);

      res.json({
        success: true,
        data: contactsResult.rows,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching contacts:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch contacts",
    });
  }
});

// GET /api/messages - Get all messages
app.get("/api/messages", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Query real messages from database
      const messagesQuery = `
        SELECT 
          id,
          sender,
          recipient,
          message,
          timestamp,
          company_id,
          contact_id,
          message_type,
          status,
          ai_generated
        FROM messages 
        ORDER BY timestamp DESC
        LIMIT 100
      `;

      const messagesResult = await client.query(messagesQuery);

      res.json({
        success: true,
        data: messagesResult.rows,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching messages:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch messages",
    });
  }
});

// GET /api/employees - Get all employees
app.get("/api/employees", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Query real employees from database
      const employeesQuery = `
        SELECT 
          u.email,
          u.name,
          u.role,
          u.active,
          u.company_id,
          u.created_at,
          u.last_login,
          c.name as company_name
        FROM users u
        LEFT JOIN companies c ON u.company_id = c.company_id
        WHERE u.role IN ('employee', 'manager', 'admin')
        ORDER BY u.created_at DESC
      `;

      const employeesResult = await client.query(employeesQuery);

      res.json({
        success: true,
        data: employeesResult.rows,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching employees:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch employees",
    });
  }
});

// GET /api/feedback - Get all feedback
app.get("/api/feedback", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Query real feedback from database
      const feedbackQuery = `
        SELECT 
          id,
          customer_name,
          customer_email,
          rating,
          comment,
          category,
          status,
          created_at,
          company_id
        FROM feedback 
        ORDER BY created_at DESC
      `;

      const feedbackResult = await client.query(feedbackQuery);

      res.json({
        success: true,
        data: feedbackResult.rows,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching feedback:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch feedback",
    });
  }
});

// GET /api/notifications - Get all notifications
app.get("/api/notifications", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Query real notifications from database
      const notificationsQuery = `
        SELECT 
          id,
          type,
          title,
          message,
          recipient,
          status,
          priority,
          created_at,
          sent_at,
          company_id
        FROM notifications 
        ORDER BY created_at DESC
      `;

      const notificationsResult = await client.query(notificationsQuery);

      res.json({
        success: true,
        data: notificationsResult.rows,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching notifications:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch notifications",
    });
  }
});

// GET /api/usage-logs - Get all usage logs
app.get("/api/usage-logs", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Query real usage logs from database
      const usageLogsQuery = `
        SELECT 
          id,
          user_id,
          user_email,
          action,
          resource,
          details,
          ip_address,
          user_agent,
          timestamp,
          duration,
          ai_usage,
          company_id
        FROM usage_logs 
        ORDER BY timestamp DESC
        LIMIT 200
      `;

      const usageLogsResult = await client.query(usageLogsQuery);

      res.json({
        success: true,
        data: usageLogsResult.rows,
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching usage logs:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch usage logs",
    });
  }
});

// GET /api/dashboard/top-users - Get top users analytics
app.get("/api/dashboard/top-users", async (req, res) => {
  try {
    const client = await pool.connect();

    try {
      // Query top contact users
      const topContactUsersQuery = `
        SELECT 
          ul.user_email,
          u.name as user_name,
          c.name as company_name,
          COUNT(*) as contact_interactions,
          AVG(ul.duration) as avg_session_duration,
          MAX(ul.timestamp) as last_active
        FROM usage_logs ul
        LEFT JOIN users u ON ul.user_email = u.email
        LEFT JOIN companies c ON ul.company_id = c.company_id
        WHERE ul.action LIKE '%contact%'
        GROUP BY ul.user_email, u.name, c.name
        ORDER BY contact_interactions DESC
        LIMIT 5
      `;

      // Query top AI message users
      const topAiUsersQuery = `
        SELECT 
          ul.user_email,
          u.name as user_name,
          c.name as company_name,
          COUNT(*) as ai_messages_generated,
          SUM(ul.duration) / 3600.0 as ai_usage_hours,
          MAX(ul.timestamp) as last_ai_usage
        FROM usage_logs ul
        LEFT JOIN users u ON ul.user_email = u.email
        LEFT JOIN companies c ON ul.company_id = c.company_id
        WHERE ul.ai_usage = true
        GROUP BY ul.user_email, u.name, c.name
        ORDER BY ai_messages_generated DESC
        LIMIT 5
      `;

      // Query top overall users
      const topOverallUsersQuery = `
        SELECT 
          ul.user_email,
          u.name as user_name,
          c.name as company_name,
          COUNT(DISTINCT ul.id) as total_sessions,
          SUM(ul.duration) / 3600.0 as total_usage_hours,
          COUNT(CASE WHEN ul.action LIKE '%contact%' THEN 1 END) as contact_interactions,
          COUNT(CASE WHEN ul.ai_usage = true THEN 1 END) as ai_messages_generated,
          COUNT(CASE WHEN ul.action LIKE '%message%' OR ul.action LIKE '%reply%' THEN 1 END) as messages_replied_to,
          MAX(ul.timestamp) as last_active,
          (COUNT(*) + COUNT(CASE WHEN ul.ai_usage = true THEN 1 END) * 2) as usage_score
        FROM usage_logs ul
        LEFT JOIN users u ON ul.user_email = u.email
        LEFT JOIN companies c ON ul.company_id = c.company_id
        GROUP BY ul.user_email, u.name, c.name
        ORDER BY usage_score DESC
        LIMIT 5
      `;

      // Query summary statistics
      const summaryQuery = `
        SELECT 
          COUNT(DISTINCT user_email) as total_active_users,
          AVG(duration) as avg_session_duration,
          COUNT(CASE WHEN ai_usage = true THEN 1 END) as total_ai_messages_generated,
          COUNT(CASE WHEN action LIKE '%contact%' THEN 1 END) as total_contact_interactions
        FROM usage_logs
        WHERE timestamp >= NOW() - INTERVAL '30 days'
      `;

      const [
        topContactUsersResult,
        topAiUsersResult,
        topOverallUsersResult,
        summaryResult,
      ] = await Promise.all([
        client.query(topContactUsersQuery),
        client.query(topAiUsersQuery),
        client.query(topOverallUsersQuery),
        client.query(summaryQuery),
      ]);

      const summary = summaryResult.rows[0] || {
        total_active_users: 0,
        avg_session_duration: 0,
        total_ai_messages_generated: 0,
        total_contact_interactions: 0,
      };

      res.json({
        success: true,
        data: {
          topContactUsers: topContactUsersResult.rows,
          topAiMessageUsers: topAiUsersResult.rows,
          topOverallUsers: topOverallUsersResult.rows,
          summary: {
            totalActiveUsers: summary.total_active_users,
            avgSessionDuration: Math.round(summary.avg_session_duration),
            totalAiMessagesGenerated: summary.total_ai_messages_generated,
            totalContactInteractions: summary.total_contact_interactions,
            mostActiveHour: "10:00-11:00", // Could be calculated from data
            peakUsageDay: "Tuesday", // Could be calculated from data
          },
        },
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Error fetching top users:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch top users data",
    });
  }
});

// ======================
// BOOKING SLOTS API
// ======================

// GET /api/booking-slots - Get all booking slots for a company
app.get("/api/booking-slots", async (req, res) => {
  try {
    const { email } = req.query;

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    const query = `
      SELECT * FROM booking_slots 
      WHERE company_id = $1 
      ORDER BY created_at DESC
    `;

    const result = await sqlDb.query(query, [user.company_id]);

    res.json({
      success: true,
      bookingSlots: result.rows,
    });
  } catch (error) {
    console.error("Error fetching booking slots:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch booking slots",
    });
  }
});

// GET /api/booking-slots/:slug - Get specific booking slot by slug
app.get("/api/booking-slots/:slug", async (req, res) => {
  try {
    const { slug } = req.params;

    const query = `
      SELECT * FROM booking_slots 
      WHERE slug = $1 AND is_active = true
    `;

    const result = await sqlDb.getRow(query, [slug]);

    if (!result) {
      return res.status(404).json({
        success: false,
        error: "Booking slot not found",
      });
    }

    res.json({
      success: true,
      bookingSlot: result,
    });
  } catch (error) {
    console.error("Error fetching booking slot:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch booking slot",
    });
  }
});

// POST /api/booking-slots - Create new booking slot
app.post("/api/booking-slots", async (req, res) => {
  try {
    const {
      title,
      slug,
      description,
      location,
      duration,
      staffName,
      staff_phone,
      is_active,
      created_by,
      company_id,
    } = req.body;

    // Validation
    if (!title || !slug || !staffName || !created_by || !company_id) {
      return res.status(422).json({
        success: false,
        error:
          "title, slug, staffName, created_by, and company_id are required",
      });
    }

    // Check if slug already exists and handle gracefully
    let finalSlug = slug;
    let existingSlot = await sqlDb.getRow(
      "SELECT * FROM booking_slots WHERE slug = $1",
      [finalSlug]
    );

    if (existingSlot) {
      // If it's the exact same booking slot (same title, staff, company), return the existing one
      if (
        existingSlot.title === title &&
        existingSlot.staff_name === staffName &&
        existingSlot.company_id === company_id
      ) {
        return res.status(200).json({
          success: true,
          bookingSlot: existingSlot,
          message: "Booking slot already exists",
        });
      }

      // Otherwise, generate a unique slug with timestamp
      const timestamp = Date.now();
      finalSlug = `${slug}-${timestamp}`;

      // Double-check the new slug doesn't exist
      const newSlugCheck = await sqlDb.getRow(
        "SELECT id FROM booking_slots WHERE slug = $1",
        [finalSlug]
      );

      if (newSlugCheck) {
        return res.status(409).json({
          success: false,
          error: "Unable to generate unique slug. Please try again.",
        });
      }
    }

    const bookingSlotId = require("uuid").v4();

    // ... existing code ...

    const query = `
      INSERT INTO booking_slots (
        id, title, slug, description, location, duration_minutes, 
        staff_name, staff_phone, is_active, created_by, company_id, created_at, updated_at
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW(), NOW())
      RETURNING *
    `;

    const result = await sqlDb.getRow(query, [
      bookingSlotId,
      title,
      finalSlug,
      description,
      location,
      duration || 30,
      staffName,
      staff_phone,
      is_active !== false,
      created_by,
      company_id,
    ]);

    res.status(201).json({
      success: true,
      bookingSlot: result,
    });
  } catch (error) {
    console.error("Error creating booking slot:", error);

    // Handle specific database errors
    if (error.code === "23505") {
      // Unique constraint violation
      return res.status(409).json({
        success: false,
        error: "A booking slot with this slug already exists",
      });
    }

    res.status(500).json({
      success: false,
      error: "Failed to create booking slot",
    });
  }
});

// PUT /api/booking-slots/:id - Update booking slot
app.put("/api/booking-slots/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const {
      title,
      slug,
      description,
      location,
      duration,
      staffName,
      is_active,
    } = req.body;

    // Check if booking slot exists
    const existingSlot = await sqlDb.getRow(
      "SELECT id FROM booking_slots WHERE id = $1",
      [id]
    );

    if (!existingSlot) {
      return res.status(404).json({
        success: false,
        error: "Booking slot not found",
      });
    }

    // Build update query dynamically
    const updateFields = [];
    const values = [];
    let paramCount = 1;

    if (title !== undefined) {
      updateFields.push(`title = $${paramCount++}`);
      values.push(title);
    }
    if (slug !== undefined) {
      updateFields.push(`slug = $${paramCount++}`);
      values.push(slug);
    }
    if (description !== undefined) {
      updateFields.push(`description = $${paramCount++}`);
      values.push(description);
    }
    if (location !== undefined) {
      updateFields.push(`location = $${paramCount++}`);
      values.push(location);
    }
    if (duration !== undefined) {
      updateFields.push(`duration_minutes = $${paramCount++}`);
      values.push(duration);
    }
    if (staffName !== undefined) {
      updateFields.push(`staff_name = $${paramCount++}`);
      values.push(staffName);
    }
    if (is_active !== undefined) {
      updateFields.push(`is_active = $${paramCount++}`);
      values.push(is_active);
    }

    if (updateFields.length === 0) {
      return res.status(422).json({
        success: false,
        error: "No fields to update",
      });
    }

    updateFields.push(`updated_at = NOW()`);
    values.push(id);

    const query = `
      UPDATE booking_slots 
      SET ${updateFields.join(", ")}
      WHERE id = $${paramCount}
      RETURNING *
    `;

    const result = await sqlDb.getRow(query, values);

    res.json({
      success: true,
      bookingSlot: result,
    });
  } catch (error) {
    console.error("Error updating booking slot:", error);
    res.status(500).json({
      success: false,
      error: "Failed to update booking slot",
    });
  }
});

// DELETE /api/booking-slots/:id - Delete booking slot
app.delete("/api/booking-slots/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ error: "Email is required" });
    }

    const user = await sqlDb.getRow(
      "SELECT company_id FROM users WHERE email = $1",
      [email]
    );
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    // Check if booking slot exists and belongs to user's company
    const existingSlot = await sqlDb.getRow(
      "SELECT id FROM booking_slots WHERE id = $1 AND company_id = $2",
      [id, user.company_id]
    );

    if (!existingSlot) {
      return res.status(404).json({
        success: false,
        error: "Booking slot not found",
      });
    }

    await sqlDb.query("DELETE FROM booking_slots WHERE id = $1", [id]);

    res.json({
      success: true,
      message: "Booking slot deleted successfully",
    });
  } catch (error) {
    console.error("Error deleting booking slot:", error);
    res.status(500).json({
      success: false,
      error: "Failed to delete booking slot",
    });
  }
});

// POST /api/booking-slots/book - Create a booking (alternative endpoint for frontend)
app.post("/api/booking-slots/book", async (req, res) => {
  try {
    // Log the full request body for debugging
    console.log("Booking request received:", JSON.stringify(req.body, null, 2));

    const {
      bookingSlotId,
      firstName,
      lastName,
      email,
      phone,
      selectedDate,
      selectedTime,
      message,
      staffName,
      title,
      duration,
      startDateTime,
      endDateTime,
      // Frontend also sends these fields
      slotId,
      slotSlug,
      phoneNumber,
      name,
      bookedAt,
    } = req.body;

    // Map frontend field names to backend expected names
    const actualFirstName = firstName || name;
    const actualPhone = phone || phoneNumber;

    // Validation - flexible to support different frontend formats
    if (!actualFirstName || !email || !actualPhone) {
      return res.status(422).json({
        success: false,
        error: "name/firstName, email, and phone/phoneNumber are required",
      });
    }

    // Check if we have any date/time information
    if (!selectedDate && !startDateTime) {
      return res.status(422).json({
        success: false,
        error: "Either selectedDate or startDateTime is required",
      });
    }

    // Handle different date/time formats from frontend
    let appointmentDateTime, endTime;

    if (startDateTime) {
      // Direct datetime format
      appointmentDateTime = new Date(startDateTime);
      endTime = endDateTime
        ? new Date(endDateTime)
        : new Date(appointmentDateTime.getTime() + (duration || 30) * 60000);
    } else if (selectedDate && selectedTime) {
      // Separate date and time - handle both 12-hour and 24-hour formats
      let timeString = selectedTime;

      // Convert 12-hour format to 24-hour format
      if (selectedTime.includes("am") || selectedTime.includes("pm")) {
        const time = selectedTime.toLowerCase().replace(/\s/g, "");
        const [timePart, meridiem] = [time.slice(0, -2), time.slice(-2)];
        let [hours, minutes] = timePart.split(":");

        hours = parseInt(hours);
        minutes = minutes || "00";

        if (meridiem === "pm" && hours !== 12) {
          hours += 12;
        } else if (meridiem === "am" && hours === 12) {
          hours = 0;
        }

        timeString = `${hours.toString().padStart(2, "0")}:${minutes}`;
      }

      appointmentDateTime = new Date(`${selectedDate}T${timeString}`);
      endTime = new Date(
        appointmentDateTime.getTime() + (duration || 30) * 60000
      );
    }

    if (!appointmentDateTime || isNaN(appointmentDateTime.getTime())) {
      console.error("Invalid date/time:", {
        selectedDate,
        selectedTime,
        startDateTime,
        endDateTime,
      });
      return res.status(422).json({
        success: false,
        error: "Invalid date/time format. Please check date and time values.",
      });
    }

    // Get company_id - try from bookingSlotId first, fallback to default
    let company_id = null;

    if (bookingSlotId) {
      const bookingSlot = await sqlDb.getRow(
        "SELECT company_id FROM booking_slots WHERE id = $1",
        [bookingSlotId]
      );
      company_id = bookingSlot?.company_id;
    }

    // Fallback: get company_id from a user email if available in metadata
    if (!company_id) {
      // For calendar bookings, we might need to get company_id differently
      // This is a fallback - you may need to adjust based on your data structure
      const defaultUser = await sqlDb.getRow(
        "SELECT company_id FROM users LIMIT 1"
      );
      company_id = defaultUser?.company_id;
    }

    if (!company_id) {
      return res.status(422).json({
        success: false,
        error: "Unable to determine company_id for booking",
      });
    }

    // Create appointment
    const appointmentId = require("uuid").v4();
    const contactName = `${actualFirstName} ${lastName || ""}`.trim();

    const appointmentData = {
      appointment_id: appointmentId,
      company_id: company_id,
      contact_id: null, // Calendar bookings don't require existing contacts
      title: title || `Appointment - ${contactName}`,
      description: message || `Calendar booking for ${contactName}`,
      scheduled_time: appointmentDateTime.toISOString(),
      duration_minutes:
        duration ||
        Math.round(
          (endTime.getTime() - appointmentDateTime.getTime()) / (1000 * 60)
        ),
      status: "scheduled",
      metadata: JSON.stringify({
        bookingSlotId: bookingSlotId || slotId || null,
        bookingSlotSlug: slotSlug || null,
        calendarBooking: true,
        customerEmail: email,
        customerPhone: actualPhone,
        staffName: staffName || "Staff",
        source: "calendar",
        bookedAt: bookedAt || new Date().toISOString(),
      }),
      staff_assigned: JSON.stringify([staffName || "Staff"]),
      appointment_type: "booking",
    };

    const result = await sqlDb.query(
      `
      INSERT INTO appointments (
        appointment_id, company_id, contact_id, title, description, 
        scheduled_time, duration_minutes, status, metadata, staff_assigned, appointment_type
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `,
      [
        appointmentData.appointment_id,
        appointmentData.company_id,
        appointmentData.contact_id,
        appointmentData.title,
        appointmentData.description,
        appointmentData.scheduled_time,
        appointmentData.duration_minutes,
        appointmentData.status,
        appointmentData.metadata,
        appointmentData.staff_assigned,
        appointmentData.appointment_type,
      ]
    );

    res.status(201).json({
      success: true,
      appointment: result.rows[0],
      message: "Booking created successfully",
    });
  } catch (error) {
    console.error("Error creating booking:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create booking",
    });
  }
});

// GET /api/booking-slots/public/:slug - Get public booking slot data
app.get("/api/booking-slots/public/:slug", async (req, res) => {
  try {
    const { slug } = req.params;

    const query = `
      SELECT 
        id, title, slug, description, location, duration_minutes, 
        staff_name, is_active, company_id, created_at
      FROM booking_slots 
      WHERE slug = $1 AND is_active = true
    `;

    const result = await sqlDb.getRow(query, [slug]);

    if (!result) {
      return res.status(404).json({
        success: false,
        error: "Booking slot not found or inactive",
      });
    }

    res.json({
      success: true,
      bookingSlot: result,
    });
  } catch (error) {
    console.error("Error fetching public booking slot:", error);
    res.status(500).json({
      success: false,
      error: "Failed to fetch booking slot",
    });
  }
});

// POST /api/booking-slots/public/book - Create a booking from public page
app.post("/api/booking-slots/public/book", async (req, res) => {
  try {
    const {
      bookingSlotId,
      firstName,
      lastName,
      email,
      phone,
      selectedDate,
      selectedTime,
      message,
      staffName,
    } = req.body;

    // Validation
    if (
      !bookingSlotId ||
      !firstName ||
      !email ||
      !phone ||
      !selectedDate ||
      !selectedTime
    ) {
      return res.status(422).json({
        success: false,
        error:
          "bookingSlotId, firstName, email, phone, selectedDate, and selectedTime are required",
      });
    }

    // Get booking slot details
    const bookingSlot = await sqlDb.getRow(
      "SELECT * FROM booking_slots WHERE id = $1 AND is_active = true",
      [bookingSlotId]
    );

    if (!bookingSlot) {
      return res.status(404).json({
        success: false,
        error: "Booking slot not found or inactive",
      });
    }

    // Create appointment
    const appointmentId = require("uuid").v4();
    const contactName = `${firstName} ${lastName}`.trim();

    // Parse date and time
    const appointmentDateTime = new Date(`${selectedDate}T${selectedTime}`);
    const endDateTime = new Date(
      appointmentDateTime.getTime() + bookingSlot.duration_minutes * 60000
    );

    const appointmentData = {
      appointment_id: appointmentId,
      company_id: bookingSlot.company_id,
      contact_id: null, // Public bookings don't require existing contacts
      title: `${bookingSlot.title} - ${contactName}`,
      description:
        message || `Booking via public link for ${bookingSlot.title}`,
      scheduled_time: appointmentDateTime.toISOString(),
      duration_minutes: bookingSlot.duration_minutes,
      status: "scheduled",
      metadata: JSON.stringify({
        bookingSlotId: bookingSlotId,
        bookingSlotSlug: bookingSlot.slug,
        publicBooking: true,
        customerEmail: email,
        customerPhone: phone,
        staffName: staffName || bookingSlot.staff_name,
        location: bookingSlot.location,
      }),
      staff_assigned: JSON.stringify([staffName || bookingSlot.staff_name]),
      appointment_type: "booking",
    };

    const result = await sqlDb.query(
      `
      INSERT INTO appointments (
        appointment_id, company_id, contact_id, title, description, 
        scheduled_time, duration_minutes, status, metadata, staff_assigned, appointment_type
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING *
    `,
      [
        appointmentData.appointment_id,
        appointmentData.company_id,
        appointmentData.contact_id,
        appointmentData.title,
        appointmentData.description,
        appointmentData.scheduled_time,
        appointmentData.duration_minutes,
        appointmentData.status,
        appointmentData.metadata,
        appointmentData.staff_assigned,
        appointmentData.appointment_type,
      ]
    );

    res.status(201).json({
      success: true,
      appointment: result.rows[0],
      message: "Booking created successfully",
    });
  } catch (error) {
    console.error("Error creating public booking:", error);
    res.status(500).json({
      success: false,
      error: "Failed to create booking",
    });
  }
});